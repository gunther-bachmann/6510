#+title: MIL
/ideas and plans on how and what to implement as minimal lisp/

- references
  - http://6502.org/source/
  - https://github.com/davidgiven/cpm65
  - https://beebwiki.mdfs.net/Number_output_in_6502_machine_code#Print_8-bit_decimal
  - https://www.pagetable.com/?p=793
  - http://sta.c64.org/cbm64krnfunc.html
  - https://sta.c64.org/cbm64mem.html
  - http://www.ffd2.com/fridge/docs/c64-diss.html
  - https://www.c64-wiki.com/wiki/BASIC-ROM
  - https://www.codebase64.org/doku.php?id=base:6502_6510_maths
  - http://www.6502.org/tutorials/decimal_mode.html
  - http://www.6502.org/tutorials/decimal_mode.html#A
  - http://www.6502.org/tutorials/compare_beyond.html#2.1
  - https://www.pagetable.com/c64ref/6502/?tab=0
  - https://celso.io/retrocomputing/2019/12/23/c64-assembly
* minimal lisp with (reduced) racket
this is a minimal lisp implementation that makes use of a reduced set of racket features in order to be somewhat portable to the minimal
lisp itself
** core features of mil
*** constants
** driving samples
*** constant definitions, atoms
#+begin_src lisp
  (def letterA #\A)
  (def stringABC "ABC")
  (def eightBitNumber #x20)
  (def sexteenBitNumber #xFFD2)
  (def floatNumber 1.23e5)
  (def symbol 'aSymbol)
  (def emptyList '())
  (def true #t)
  (def false #f)
#+end_src
*** quote, quasiquote, list
- '() is shorthand for (list)
- 'some is shorthand for (quote some)
- `(,some) is shorthand for (quasiquote (list (unquote some)))
#+begin_src lisp
  (list) => '()
  (list some) => '(some)
  (quote some) => 'some
  (quote (list)) => '(list)
  (quote ()) => '()
  (quasiquote (list (unqote other))) => `(,other)
#+end_src
*** splice operator
#+begin_src lisp
  (def aList (list a b c))
  (def bList (@aList d e f)) => (a b c d e f)

  (def aMap (map a va b vb c vc))
  (def bMap (map @aMap c oc d vd e ve)) => (map a va b vb c oc d vd e ve)

  (def aArray (array a b c))
  (def bArray (array @aArray d e f)) => (array a b c d e f)

  (def aStruct (struct idA #:fieldA valueFieldA #:fieldB valueFieldB))
  (def bStruct (struct idB @aStruct #:fieldC valueFieldC #:fieldD valueFieldD))
#+end_src
*** orthogonal concepts
all defaults to immutable data
list, map, array and struct can be converted into another.
list: variable length o(1) to prepend a value (mutable)
map: variable length o(1) to read by key
struct: fixed length o(1) to read by key and write by key (mutable)
array: fixed length o(1) to read by index and write by index (mutable)
- a struct is a map of fields -> values
- a struct is a list of fieldId value ...
- an array is a list (of fixed len)
- a map is a list of key value ...
*** function definition
only tailcall recursion allowed (no check, yet)
#+begin_src lisp
  (def fn (lambda ([param1 typeA] [param2 typeB]) (fn param1 param2)))
#+end_src
*** let, let*
#+begin_src lisp
  (let ((nameA valueA)
        (nameB valueB))
    (useNameA nameA nameB))
#+end_src
#+begin_src lisp
  (let* ((nameA valueA)
         (nameB (fn valueA)))
    (fn nameA nameB))
#+end_src
*** if [when, unless]
#+begin_src lisp
  (if booleanExpr
      (fnA)
      (fnB))
#+end_src
*** mutable value (ideas)
#+begin_src lisp
  (mutable-byte #x00 byteId)
  (mutate:= byteId #x20)
  (mitable-word #xc000 wordId)
  (mutate:= wordId #xFFD2)
#+end_src
*** types
#+begin_src lisp
  (deftype id (sumtype a b c)) ;; a x b x c
  (deftype id (uniontype a b c)) ;; a | b | c
  void ;;
  any  ;; is subtype of all types
  none ;; is supertype of all types
#+end_src
*** structures
#+begin_src lisp
  (defstruct id
    field1
    field2)
#+end_src
*** lists, arrays, maps
#+begin_src lisp
  (def aList (a b c))
  (def aHash {a: valueA b: valueB c: valueC})
  (def anArray [a b c d])
#+end_src
** plan
- [-] define scheme-syntax for mil (concepts), e.g. use ~mil-~â€‹prefix ast
  - overview
    #+begin_src racket
      (mil-module
       modname
       (mil-import ...)
       (mil-export ...)

       (mil-definition
        'age-comment (list (mil-parameter 'age))
        "return a comment about your age"
        (mil-if (mil-l (mil-symbol '>) (mil-symbol 'age) (mil-uint8 17))
                (mil-string "erwachsen")
                (mil-string "kind"))))
    #+end_src
  - byte arithmetic
    #+begin_src lisp
      ;; integer arithmetic
      (mil-+ op1 op2 ... op-m)

      ;; mil--
    #+end_src
  - logical operators
    #+begin_src lisp
      ;; mil-or
      ;; mil-and
      ;; not
    #+end_src
  - binary bit operators
    #+begin_src lisp
    #+end_src
- [X] define interpreter for mil scheme-syntax ast
- [ ] define compiler mil scheme ast -> c64 assembler
  - expression stack?
  - implement most simple function
    function no parameter returning atomic value
  - function call = expression reduction
  - variable / function - lookup / environment
  - memory layout for normal forms (list, cons + atomic values),
    special forms are translated into code
    table of strings (ptr - >str)
    table of symbols (ptr/id -> symbol string)
    function table (ptr/id -> function code)
- [ ] define parser for actual syntax
- [ ] define translation: parsed -> mil ast
** (old) mil-ast -> c64
*** simple function
#+begin_src racket
  (mil-definition
   'const-a
   '()
   "constant a = 42"
   (mil-uint8 42))

  (mil-l (mil-symbol 'display) (mil-symbol 'const-a)) ;; print const-a
#+end_src
#+begin_src asm
                  ; put uint8 42 on expression stack, register A destroyed, probably some flags, too
  const-a:        lda #42
                  jmp PUT_MIL_CONST_ON_EXPR_STACK

  main:           jsr const-a ; eager eval of parameters
                  jsr DISPLAY ; runtime library to display last object(s) on the expression stack
#+end_src
*** value (expression) stack
- tos = ptr to top element of the stack
- tos = atomic value or string
- data representation [not optimized, simple]
  - e.g.
    - bool/char/byte value: [type-byte][value] (in sum 16 bits)
    - string value: [type-string][string-id] (in sum 16 bits), id into string table
    - cons-cell(list): [type-cons-cell][a][b]  (in sum 8 bit + len(a) + len(b))
      - a, b can be a bool/char/byte/string value or a cell-ptr
      - cell-ptr: [type-cell-pointer][low][high] (in sum 24 bits, with 16 bit ptr to next cell)
      - nil-cell-ptr: [type-nil-cell-pointer] (in sum 8 bit)
- value list construction (e.g. '(a b c)):
  - push nil-cell-ptr  on the expression stack [expression stack: [nil-cell-ptr]]
  - push value c on expression stack [expression stack: [c][nil-cell-ptr]]
  - call cons (replacing tos and tos-1 with cell-ptr to cons-cell [c][nil-cell-ptr])
  - push value b on expression stack
  - call cons (replacing tos and tos-1 with cell-ptr to cons-cell [b][cell-ptr, pointing to [c][nil-cell-ptr]] )
  - push value a on expression stack
  - call cons  (replacing tos and tos-1 with cell-ptr to cons-cell [a][cell-ptr, pointing to [b][cell-ptr, pointing to [c][nil-cell-ptr]]])
*** runtime methods for value stack
- push atomic value on the stack
- push nil-cell-ptr
- cons tos with tos-1
- (store tos-loc (for cleanup after function-call))?

*** memory layout for value stack
stack of pointers (e.g. just 256 bytes = 128 values)
| cell0     | cell1     | ... | cell n-1   | cell n   |
|-----------+-----------+-----+------------+----------|
| ptr->tos0 | ptr->tos1 | ... | ptr->tos-1 | ptr->tos |

heap of values pointed to by value stack (pointers)
| ptr        | *value stack heap* | size                    | layout                                                              |
|------------+--------------------+-------------------------+---------------------------------------------------------------------|
| ptr->tos   | (list a b c)       | 4 +len(a)+len(b)+len(c) | [type-cons-cell[a][type-cons-cell[b][type cons-cell[c][nil-cell]]]] |
| ptr->tos-1 | byte #$42          | 2                       | [type-byte-const][$42]                                              |
| ...        |                    |                         |                                                                     |

- pop on the stack means:
  - cell-n is dropped,
  - data ptr->tos points to is free again
  - new value stack allocation starts at ptr->tos
  => for allocation, the next free value stack heap location needs to be kept somewhere (or can be calculated)
*** c64 program layout
| address    | function                                  |
|------------+-------------------------------------------|
| E000..FFFF | Kernal                                    |
| D000..DFFF | unused, char rom, etc.                    |
| C200..CFFF | Strings (currently not garbage collected) |
| C000..C1FF | String ID -> ptr to Strings               |
| A000..BFFF | Basic                                     |
| 9F00..9FFF | value stack (growing down)                |
| 9EFF       | value heap (growing down)                 |
| 3000       | mil program start                         |
| 2000..2FFF | mil runtime (size not known yet)          |
| 0200..1FFF | basic area (not used)                     |
| 0100..01FF | 6510 call stack                           |
| 0000..00FF | zero page                                 |

*** hello world
#+begin_src racket
  (module
      'some
      ;; no provide no require
      (mil-definition 'hello-world
                      '()
                      "print hello world"
                      (mil-l (mil-symbol 'display) (mil-string "Hello World!")))
    (mil-l (mil-symbol 'hello-world)))

  ;; which corresponds to

  (define (hello-world)
    (display "Hello World!"))

  (hello-world)
#+end_src
should compile to
#+begin_src asm
                  jmp HELLO_WORLD

  HELLO_WORLD:    lda #STRING-ID_HELLO_WORLD
                  jsr MILRT_push_string
                  jmp MILRT_display
#+end_src
String table should hold one entry: "Hello World!" with ID 1 (STRING-ID_HELLO_WORLD
Symbol Table is not necessary yet (maybe if 'eval' is implemented)

** memory layout
- 0000-00ff ZP
  - free for use by mil (since only used by basic)
    07, 08 : used for searching with basic
    0c : basic dim array check
    0d : basic string / number indicator
    0e : basic integer / float indicator
    3b, 3c, 3d, 3e, 3f, 40, 41, 42: basic line number stuff, basic data command stuff
    fb, fc, fd, fe : unused
  - ~07..08~ : PTR for strings/symbols (during string/symbol processing and initialisation)
  - ~0d..0e~ : PTR to TOS of Expression Stack
  - ~3b..3c~ : PTR to next free cons-cell
  - ~3d..3e~ : PTR to free-cons-cells for pass2 of freeing
  - ~3f~     : HIGH-BYTE of to last free cons-cell (reaching this means, the heap needs to allocate new cons cells), done in 256 byte steps
  - ~40..41~ : PTR to cons cell (register 1)
- 0100-01ff 6510-STACK
- <used>
- 0800...    PROGRAM
- ...        EXPRESSION STACK (growing up) [atomic-values, or ptr to cons-cell]
- FREE
- ...        EXPRESSION-HEAP (growing down, with free cons-cells list)
- A000-BFFF
- C000... Strings/Symbols (growing up)
- .. CFFF MAP: String/Symbol-ID -> PTR (growing down)

*** expression stack
- 2 bytes
- either low-high of pointer (lowest two bits are 00), if completely 0 then = nil
- or atomic value (lowest two bits are set)
  - 01 atomic value (string(id), uint8, char, bool, symbol(id)) <- in second byte,
    - C-- 000 01 uint 8 (carry from last operation on that value)
    - --- 001 01 char
    - --- 010 01 bool
    - hhh 011 01 string-id (hhh are the high 3 bits, if # is getting too large)
    - hhh 100 01 symbol-id (hhh are the high 3 bits, if # is getting too large)
    - --- 101 01
    - --- 110 01
    - --- 111 01
  - 10
  - 11

*** expression heap is made of cons-cells (all of equal size, later on maybe use pages of cons-cells of different size).
- IDEA: 256 byte = 51 cons cells, 51 byte = reference counters + 1 byte pages status
  [xxxxxx00][high-byte]
  00110011
- each cons cell [4 bytes][+1 byte for reference count] <- where this byte is located needs to be decided on!!
  - [aaaaaaTT][aaaaaaaa][bbbbbbSS][bbbbbbbb]
  - TT = 00 => a = ptr to next cons cell
  - SS = 00 => b = ptr to next cons cell
  - TT/SS = 01 => is atomic value, same encoding as expression stack!
  - if a and TT is = 0 => nil, this cons cell is = nil
  - if b and SS is = 0 => this is the last element of a list
- a cons cell of the free list has only /a/ set, /b/ = nil. a points to the next free cons cell.
- if a is 0 this is the last free cons-cell. the last free cons-cell has in b pointer to the next block to allocate
- cells are located at
  - (+ (* 4 (* 3 17)) 51), 51 cells used
  - [00000] status byte

  - [0000 01]00 ... 0000 0111 -> 0000 0001
  - [0000 10]00 ... 0000 1011 -> 0000 0010
  - [0000 11]00 ... 0000 1111 -> 0000 0011

  - [0100 00]00 ... 0100 0011 -> 0001 0000
  - [0100 01]00 ... 0100 0111 -> 0001 0001
  - ...
  - [1000 00]00 ... 1000 0011 -> 0010 0000
  - [1100 00]00 ... 1100 0011 -> 0011 0000
  - [1111 11]00 ... 1111 1111 -> 0011 1111
  #+begin_src scheme

                        ;; init page at high-byte
                        ;; use zero page LOW_PTR, HIGH_PTR = LOW_PTR+1

                        ;; fill page with zeros!
                        (LDA !high-byte)
                        (STA HIGH_PTR
                        (LDA !$0)
                        (STA LOW_PTR)
                        (LDX !FF)
                        (LDA !0)
    (label _FILL0)
                        (STA (LOW_PTR),x)
                        (DEX)
                        (BNE _FILL0)

                        ;; set page status on first byte of the page
                        (LDA !page-status)
                        (STA (LOW_PTR),x)

                        ;; fill first 3 cells (special)

                        ;; now 0000 0100, 0000 0101 <- 0000 1000, high-byte
                        (LDX !$04)
                        (LDA !$08) ;; point to next cell at 0000 1000
                        (STA (LOW_PTR),x)
                        (INX)
                        (LDA !high-byte)
                        (STA (LOW_PTR),x)
                        ;; next 0000 1000, 0000 1001 <- 0000 1100, high-byte
                        (LDX !$08)
                        (LDA !$0a) ;; point to next cell at 0000 1100
                        (STA (LOW_PTR),x)
                        (INX)
                        (LDA !high-byte)
                        (STA (LOW_PTR),x)
                        ;; next 0000 1100, 0000 1101 <- 0100 000, high byte
                        (LDX !$0a)
                        (LDA !$40) ;; point to next cell at 0100 0000
                        (STA (LOW_PTR),x)
                        (TAY)
                        (INX)
                        (LDA !high-byte)
                        (STA (LOW_PTR),x)
                        ;; next 0100 0000, 0100 0001 <- 0100 0100, high byte

                        ;; fill the 48 other cells starting at 0100 0000
    (label _loop_init_cons)
                        (TYA)
                        (TAX)
                        (CLC)
                        (ADC !$04) ;; next cell at this+4
                        (STA (LOW_PTR),x) ;; point to next cell
                        (TAY) ;; keep ptr to next cell in Y
                        (INX)
                        (LDA !high-byte)
                        (STA (LOW_PTR),x) ;; point to next cell high byte
                        (CPX !$F9) ;; was last cell to point to next
                        (BNE _loop_init_cons

                        ;; last cell marked with two zeros
                        (RTS)

                        ;; next 0100 0100, 0100 0001 <- 0100 1000, high byte
                        ;; next 0100 1000, 0100 1001 <- 0100 1100, high byte
                        ;; next 0100 1100, 0100 1101 <- 0101 0000, high byte
                        ;; next 1100 0000, 1100 0001 <- 1100 0100, high byte
                        ;; next 1111 1000, 1111 1001 <- 1111 1100, high byte
                        ;; next 1111 1100, 1111 1101 <- 0, 0

  #+end_src
** runtime functions
- free-cons-cell-ptr :: points to the first free cons cell
- CR1..n :: cons register
- next-heap-page :: holds the high byte of the next free heap page 
- init RT
  - copy strings/symbols to string/symbol table
- initialize expression heap of cons cells
  - create free list
  - allocate cons-cell
    - when (lowbyte of) car of free-cons-cell-ptr is zero (no more free cons cells), grow heap and initialize new freelist
    - copy ~free-cons-cell-ptr~ into cons register
    - copy car of cons cell into ~free-cons-cell-ptr~
    - inc reference count (cons register lowbyte shift right 2 times)
  - add cons-cell (in cons register) to free-list
    - copy ~free-cons-cell-ptr~ into car of cons register, clear cdr of cons register (clear reference count, should be zero anyhow)
    - copy cons register into ~free-cons-cell-ptr~
  - free cons-cell (CR)
    - shift low byte right two times (now high low should point to reference count)
    - dec reference count
    - when zero, add cons cell to free-list
    - free car of cons-cell (if ptr), free cdr of cons-cell (if ptr) [no recursion: do this as a loop] 
    - example implementation
      - loop (1)
        - keep if car of cons cell (if it is a ptr)
        - if cdr holds ptr, add this to free-pass2-cons-cell list, car -> free-pass2-cons-cell list, free-pass-cons-cell list := CR
        - if cdr holds no ptr, free cons cell itself
        - loop to free car (if it is a ptr)
      - loop (2)
        - pop top of free-pass2-cons-cell list, call free on cdr of that cell (jump into loop 1) and thus add this cons cell to the free list
        - loop until free-pass2-cons-cell list is empty
  - grow heap for free list
    - check that next-heap-page does not collide with expression-stack (high byte) => out of memory error, gc?
    - initialize new page, mark last cell as such, set car of last cell to 0 (set $FC = 0) <- is set to 0 by init
  - collect cells for free-list (collection should be inplace, without additional space-usage)
- gc (e.g. mark and sweep) <- necessary? how would could a reference ring come into being? not for lists alone, what about structures
  #+begin_src scheme
    (struct A (a b val)) ;; a b can be cons cells

    (define A2 (A nil nil  2)) ;; A2 ref count 1
    (define A1 (A nil A2 15)) ;; A1 ref count 1, A2 ref count 2
    (define newA2 (struct-copy A A2 [a A1])) ;; newA2 ref count1, A1 refcount 2, A2 refcount 3

    newA2 -> A1 ->
          -> A2


    (discard A2) ;; A2 refcount 2 
    (discard A1) ;; A1 refcount 1

    (discard newA2) ;; newA2 refcount = 0
    (discard (A-a newA2)) ;; A1 refcount = 0
    (discard (A-b (A-a newA2))) ;; A2 refount = 1
    (discard (A-b newA2)) ;; A2 refcount = 0

    ;; given the fact that no modificaton is allowed, circular references cannot occur
    ;; => cannot implement double linked list
  #+end_src
  - gc only necessary, when starting to allow assignments (without copying)
    #+begin_src scheme
      (struct A (prev next val))
      (define A1 (A nil nil 5))
      (define A2 (A nil nil 6))
      (A-next-set! A1 A2) ;; set does mark as gc collectible? or simply offers no memory deallocation?
      (A-prev-set! A2 A1)
    #+end_src
- initialize expression stack
  - push atomic values
  - pop atomic values
  - push lists / cons-cells
- display (atomic values, cons-cells (lists))

* additional routines
** times 10 (decimal)
#+begin_src asm
  mul10:  PHA; save an in the stack
          ASL; multiply a by 8 shifting 3 times to the left
          ASL
          ASL
          STA temp; save an*8 in temp
          PLA; recover old A value from the stack
          ASL; multiply by 2 shiftings once to the left
          CLC ; clear carry
          ADC temp; add an*8 to a*2 to get a*10
          RTS ; return
#+end_src
