#lang racket

#|

 interpreter for mil ast command structure

 |#

(require "./mil-structures.rkt")
(require (only-in threading ~>>))
(require (only-in "../6510-utils.rkt" byte two-complement-of))
(provide interpret
         module-ctx
         (struct-out interpreter-ctx))

(module+ test
    (require "../6510-test-utils.rkt"))

(define atom-types '(uint8 string char))

(define atom-functions '(+ - display cdr car quote cons > < eq? and or not zero? identity))

(define special-forms '(let if def list)) ;; actually modelled by special mil structures

;; provide the type expression for the given expression
;; (define/contract (type-of expr)
;;   (-> mil-expression? mil-expression?)
;;   expr)

;; interpretation context
(struct interpreter-ctx
  (symbols)
  #:transparent
  #:guard (struct-guard/c hash?))

(define/contract (resolve sym ctxs)
  (-> mil-symbol? (listof interpreter-ctx?) mil-expression?)
  (when (empty? ctxs)
    (raise-user-error "symbol not found"))
  (define result (hash-ref (interpreter-ctx-symbols (car ctxs)) (mil-symbol-value sym) #f))
  (if result
      result
      (resolve sym (cdr ctxs))))

(module+ test #| resolve |#
  (check-exn exn:fail? (lambda () (resolve (mil-symbol 'a) (list (interpreter-ctx (hash))))))
  (check-equal? (resolve (mil-symbol 'a) (list (interpreter-ctx (hash 'a (mil-symbol 'a-found)))))
                (mil-symbol 'a-found))
  (check-equal? (resolve (mil-symbol 'a) (list (interpreter-ctx (hash)) (interpreter-ctx (hash 'a (mil-symbol 'a-found)))))
                (mil-symbol 'a-found)))

(define/contract (unbox-mil-atomic-value value)
  (-> mil-atomic-value? any/c)
  (cond ((mil-string? value) (mil-string-value value))
        ((mil-uint8? value) (mil-uint8-value value))
        ((mil-char? value) (mil-char-value value))
        (#t (raise-user-error "unknown atomic value"))))

(define/contract (apply-mil-function sym params ctxs)
  (-> mil-symbol? (listof mil-expression?) (listof interpreter-ctx?) mil-expression?)
  ;; eager eval of parameter
  (define reduced-params (map (lambda (param) (interpret param ctxs)) params))
  (cond ((eq? '+ (mil-symbol-value sym)) (mil-uint8 (byte (foldr (lambda (val acc) (+ acc (mil-uint8-value val))) 0 reduced-params))))
        ((eq? '- (mil-symbol-value sym))
         (define p1 (car reduced-params))
         (define rest (cdr reduced-params))
         (define result
           (cond ((empty? rest)
                  (- 0 (mil-uint8-value p1)))
                 (#t 
                  (foldr (lambda (val acc) (- acc (mil-uint8-value val))) (mil-uint8-value p1) rest))))
         (if (< result 0)
             (mil-uint8 (two-complement-of result))
             (mil-uint8 (byte result))))
        ((eq? 'display (mil-symbol-value sym))
         (define format (mil-string-value (car reduced-params)))
         (define values (map unbox-mil-atomic-value (cdr reduced-params)))
         (apply fprintf (cons (current-output-port) (cons format values)))
         (mil-void))
        ((eq? 'cdr (mil-symbol-value sym))
         (if (empty? reduced-params)
             (raise-user-error "cdr w/o parameter")
             (cond ((mil-list? (car reduced-params))
                    (mil-list (cdr (mil-list-elements (car reduced-params)))))
                   ((mil-cell? (car reduced-params))
                    (mil-cell-tail (car reduced-params)))
                   (#t (raise-user-error "cdr works on list only")))))
        ((eq? 'car (mil-symbol-value sym))
         (if (empty? reduced-params)
             (raise-user-error "car w/o parameter")
             (cond ((mil-list? (car reduced-params))
                    (car (mil-list-elements (car reduced-params))))
                   ((mil-cell? (car reduced-params))
                    (mil-cell-head (car reduced-params)))
                   (#t (raise-user-error "car works on list only")))))
        ((eq? 'cons (mil-symbol-value sym))
         (define p1 (car reduced-params))
         (define p2 (cadr reduced-params))
         (cond ((mil-list? p2)
                (mil-list (cons p1 (mil-list-elements p2))))
               ((mil-cell? p2)
                (mil-list (list p1 p2)))
               (#t (mil-cell p1 p2))))
        ((eq? '> (mil-symbol-value sym))
         (define p1 (car reduced-params))
         (define p2 (cadr reduced-params))
         (mil-bool (> (mil-uint8-value p1) (mil-uint8-value p2))))
        ((eq? '< (mil-symbol-value sym))
         (define p1 (car reduced-params))
         (define p2 (cadr reduced-params))
         (mil-bool (< (mil-uint8-value p1) (mil-uint8-value p2))))
        ((eq? 'eq? (mil-symbol-value sym))
         (define p1 (car reduced-params))
         (define p2 (cadr reduced-params))
         (mil-bool (cond ((mil-uint8? p1)
                          (eq? (mil-uint8-value p1) (mil-uint8-value p2)))
                         ((mil-string? p1)
                          (equal? (mil-string-value p1) (mil-string-value p2)))
                         ((mil-char? p1)
                          (eq? (mil-char-value p1) (mil-char-value p2)))
                         ((mil-bool? p1)
                          (eq? (mil-bool-value p1) (mil-bool-value p2)))
                         (#t (raise-user-error "cannot compare non atomic values")))))
        ((eq? 'and (mil-symbol-value sym))
         (mil-bool (foldl (lambda (val acc) (and acc val)) #t (map mil-bool-value reduced-params))))
        ((eq? 'or (mil-symbol-value sym))
         (mil-bool (foldl (lambda (val acc) (or acc val)) #f (map mil-bool-value reduced-params))))
        ((eq? 'not (mil-symbol-value sym))
         (mil-bool (not (mil-bool-value (car reduced-params)))))
        ((eq? 'zero? (mil-symbol-value sym))
         (mil-bool (zero? (mil-uint8-value (car reduced-params)))))
        (#t (apply-mil-user-function sym reduced-params ctxs))))


(define/contract (apply-mil-user-function sym reduced-params ctxs)
  (-> mil-symbol? (listof mil-expression?) (listof interpreter-ctx?) mil-expression?)
  (define user-fun (resolve sym ctxs))
  (unless (mil-definition? user-fun)
    (raise-user-error "symbol not a function definition"))
  ;; create hash with param names mapped to the
  (define key-value-pairs (map cons (map mil-parameter-id (mil-definition-parameters user-fun)) reduced-params))
  (define new-ctxs (cons (interpreter-ctx (make-hash key-value-pairs)) ctxs))  
  (interpret (mil-definition-body user-fun) new-ctxs))

(module+ test #| apply-mil-function |#
  (check-equal? (apply-mil-function (mil-symbol 'zero?)
                                    (list (mil-uint8 0))
                                    (list))
                (mil-bool #t))
  (check-equal? (apply-mil-function (mil-symbol 'zero?)
                                    (list (mil-uint8 1))
                                    (list))
                (mil-bool #f))
  (check-equal? (apply-mil-function (mil-symbol 'not)
                                    (list (mil-bool #f))
                                    (list))
                (mil-bool #t))
  (check-equal? (apply-mil-function (mil-symbol 'not)
                                    (list (mil-bool #t))
                                    (list))
                (mil-bool #f))
  (check-equal? (apply-mil-function (mil-symbol 'and)
                                    (list (mil-bool #t) (mil-bool #t))
                                    (list))
                (mil-bool #t))
  (check-equal? (apply-mil-function (mil-symbol 'and)
                                    (list (mil-bool #t) (mil-bool #f))
                                    (list))
                (mil-bool #f))
  (check-equal? (apply-mil-function (mil-symbol 'or)
                                    (list (mil-bool #t) (mil-bool #f))
                                    (list))
                (mil-bool #t))
  (check-equal? (apply-mil-function (mil-symbol 'or)
                                    (list (mil-bool #f) (mil-bool #f))
                                    (list))
                (mil-bool #f))
  (check-equal? (apply-mil-function (mil-symbol 'afn)
                                    '()
                                    (list (interpreter-ctx (hash 'afn (mil-definition 'afn '() "doc" (mil-uint8 #x80))))))
                (mil-uint8 #x80))
  (check-equal? (apply-mil-function (mil-symbol '+)
                                    (list (mil-uint8 1) (mil-uint8 2))
                                    (list))
                (mil-uint8 3))
  (check-equal? (apply-mil-function (mil-symbol '-)
                                    (list (mil-uint8 2) (mil-uint8 1))
                                    (list))
                (mil-uint8 1))
  (check-equal? (apply-mil-function (mil-symbol '-)
                                    (list (mil-uint8 2))
                                    (list))
                (mil-uint8 (two-complement-of -2)))
  (check-equal? (apply-mil-function (mil-symbol '-)
                                    (list (mil-uint8 2) (mil-uint8 3))
                                    (list))
                (mil-uint8 (two-complement-of -1)))
  (check-equal? (apply-mil-function (mil-symbol 'cdr)
                                    (list (mil-quote (mil-list (list (mil-uint8 2) (mil-uint8 3)))))
                                    (list))
                (mil-list (list (mil-uint8 3))))
  (check-equal? (apply-mil-function (mil-symbol 'car)
                                    (list (mil-quote (mil-list (list (mil-uint8 2) (mil-uint8 3)))))
                                    (list))
                (mil-uint8 2))
    (check-equal? (apply-mil-function (mil-symbol 'cdr)
                                      (list (mil-quote (mil-cell (mil-uint8 2) (mil-uint8 3))))
                                    (list))
                   (mil-uint8 3))
  (check-equal? (apply-mil-function (mil-symbol 'car)
                                    (list (mil-quote (mil-cell (mil-uint8 2) (mil-uint8 3))))
                                    (list))
                (mil-uint8 2))
    (check-equal? (apply-mil-function (mil-symbol 'cons)
                                      (list (mil-quote (mil-uint8 1)) (mil-quote (mil-list (list (mil-uint8 2) (mil-uint8 3)))))
                                    (list))
                  (mil-list (list (mil-uint8 1) (mil-uint8 2) (mil-uint8 3))))
    (check-equal? (apply-mil-function (mil-symbol 'eq?)
                                      (list (mil-uint8 1) (mil-uint8 2))
                                      (list))
                  (mil-bool #f))
        (check-equal? (apply-mil-function (mil-symbol 'eq?)
                                      (list (mil-uint8 1) (mil-uint8 1))
                                      (list))
                  (mil-bool #t)))

;; interpret/reduce the given expr in this context
(define/contract (interpret expr ctxs)
  (-> mil-expression? (listof interpreter-ctx?) mil-expression?)
  (cond ((mil-quote? expr) (mil-quote-quoted expr))
        ((mil-symbol? expr)    ;; resolve id
         (resolve expr ctxs))
        ((mil-atomic-value? expr)     ;; return the value
         expr)
        ((mil-let? expr)
         (interpret (mil-let-body (cons (let-ctx (mil-let-bindings expr) ctxs) ctxs))))
        ((mil-if? expr)
         (if (mil-bool-value (interpret (mil-if-predicate expr) ctxs))
             (interpret (mil-if-true-body expr) ctxs)
             (interpret (mil-if-false-body expr) ctxs)))
        ((mil-list? expr)      ;; function call (currently no heeding of special symbols
         (apply-mil-function (car (mil-list-elements expr)) (cdr (mil-list-elements expr)) ctxs))
        (#t (raise-user-error "cannot interpret expr"))))

(module+ test #| interpret |#
  (check-exn exn:fail? (lambda () (interpret (mil-list (list 'abc)) (list (interpreter-ctx (hash))))))
  (check-equal? (interpret (mil-symbol 'a) (list (interpreter-ctx (hash 'a (mil-uint8 #x80)))))
                (mil-uint8 #x80))
  (check-equal? (interpret (mil-list (list (mil-symbol 'a))) (list (interpreter-ctx (hash 'a (mil-definition 'a '() "doc" (mil-uint8 #x80))))))
                (mil-uint8 #x80)))


(define/contract (let-ctx bindings ctxs)
  (-> (listof mil-let-binding?) (listof interpreter-ctx?) interpreter-ctx?)
  (~>>
   (map cons (map mil-let-binding-id bindings)
        (map (lambda (val) (interpret val ctxs))  (map mil-let-binding-expr bindings)))
   (make-hash)
   (interpreter-ctx)))

(module+ test #| let-ctx |#
  (check-equal? (resolve (mil-symbol 'a) (list (let-ctx (list (mil-let-binding 'a (mil-uint8 #x80) )) (list (interpreter-ctx (hash))))))
                (mil-uint8 #x80)))

(define/contract (module-ctx module)
  (-> mil-module? interpreter-ctx?)
  (~>>
   (map cons (map mil-definition-id (mil-module-definitions module))
        (mil-module-definitions module))
   (make-hash)
   (interpreter-ctx)))

(module+ test #| module-ctx |#
  (check-equal? (resolve (mil-symbol 'a) (list (module-ctx (mil-module 'my-module
                                                                       (list)
                                                                       (list)
                                                                       (list (mil-definition 'a '() "doc" (mil-uint8 #x80)))
                                                                       (list)
                                                                       (list)))))
                (mil-definition 'a '() "doc" (mil-uint8 #x80)))
    (check-equal? (resolve (mil-symbol 'b) (list (module-ctx (mil-module 'my-module
                                                                       (list)
                                                                       (list)
                                                                       (list (mil-definition 'a '() "doc" (mil-uint8 #x80))
                                                                             (mil-definition 'b '() "doc" (mil-uint8 #x20)))
                                                                       (list)
                                                                       (list)))))
                (mil-definition 'b '() "doc" (mil-uint8 #x20))))
