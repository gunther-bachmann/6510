#+title: vm-object-index
* file description
- collection of all annotated elements
- @DC-FUN :: function annotation
  @DC_FUN: <fun-label>(, group: <fun-group>(-<fun-group)*)*
  example: ;; @DC-FUN: VM_INITIALIZE_MEMORY_MANAGER, group: pages
  may have multiple groups
  the file name is used for creating the racket require line
  the define (following) is used for racket require line
  the @DC-FUN line is used for the org-link
  the line following this @DC-FUN comment must:
  - have 1..n comments (describing the function)
  - have a single "define <some-label>" (which must include the fun-label in its body)
- @DC-ZP :: zero page annotation
  @DC-ZP: <zero-page-constant>(, group: <zp-group>(-<zp-group>)*)*
  example: ;; @DC-ZP: ZP_RA, group: registers-array
  the file name is used for creating the racket require line
  the enclosing define is used for racket require line
  the @DC-ZP line is used for the org-link
  the line following this @DC-ZP comment must:
  - have a single (byte-const <zero-page-constant>) followed by a describing comment
  - or have a single (word-const <zero-page-constant>) followed by a describing comment
- @DC-C :: constant
  @DC-C: <constant-label>(, group: <c-group>(-<cgroup>)*)*
  example: ;; @DC-C: TAG_BYTE_BYTE_CELL
  the file name is used for creating the racket require line
  the enclosing define is used for racket require line
  the @DC-C line is used for the org-link
  the line following this @DC-C comment must:
  - have a single (byte-const <zero-page-constant>) followed by a describing comment
  - or have a single (word-const <zero-page-constant>) followed by a describing comment
- @DC-M :: memory (locations)
  @DC-M: <mem-label>(, group: <m-group>(-<m-group)*)*
  example: ;; @DC-M: GLOBAL_CELLPAIR_PAGE_FOR_ALLOC, group: gc
  the file name is used for creating the racket require line
  the enclosing define is used for racket require line, must start with an org (<- allows for actual location derivation)
  the @DC-M line is used for the org-link
  the line following this @DC-M comment must:
  - be a line (label <mem-label>) with comments followed by
  - a single (byte ..) or (word ..) constant with comments
- @DC-B :: byte code
  @DC-B: <bc-label>(, group: <b-group>(-<b-group>)*)
  example: ;; @DC-B: BINC, group: byt
           ;; @DC-B: GET_AF_0, group: cell_array
  the file name is used for creating the racket require line
  the following define is used for racket require line and to extract the actual byte code
  the next define (starting with BC_) is used for assembler include
  the @DC-B line is used for the org-link
  the line following this @DC-B comment must:
* constants / tag bytes (by value)
- [[file:vm-memory-map.rkt::50][$ff]] :: TAG_BYTE_BYTE_CELL  low byte in a cell that indicates the cell to be a byte-cell
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  low byte in a cell that indicates the cell to be a byte-cell
* constants / tag bytes (by name)
- [[file:vm-memory-map.rkt::50][TAG_BYTE_BYTE_CELL]] :: $ff  low byte in a cell that indicates the cell to be a byte-cell
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  low byte in a cell that indicates the cell to be a byte-cell
* constants / tag bytes (by group)
** cell
- [[file:vm-memory-map.rkt::50][TAG_BYTE_BYTE_CELL]] :: $ff  low byte in a cell that indicates the cell to be a byte-cell
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  low byte in a cell that indicates the cell to be a byte-cell
* zero-page-locations (by address)
- [[file:vm-memory-map.rkt::66][$d9]] :: ZP_TEMP3  zero page location 3 for temp usage
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  zero page location 3 for temp usage
  may be used as pointer (in combination with ZP_TEMP4 => must be in adjacent memory locations)
- [[file:vm-memory-map.rkt::69][$da]] :: ZP_TEMP4  zero page location 4 for temp usage
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  zero page location 4 for temp usage
- [[file:vm-memory-map.rkt::72][$db]] :: ZP_CELL_STACK_TOS  byte (fe = empty stack, 0 = first element, 2 = second element, 4 = third element ...)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  byte (fe = empty stack, 0 = first element, 2 = second element, 4 = third element ...)
- [[file:vm-memory-map.rkt::87][$de]] :: ZP_VM_PC  the following twelve bytes need to be continuous, since they are saved into the call frame!
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  the following twelve bytes need to be continuous, since they are saved into the call frame!
  de..df program counter (ptr to currently executing byte code)
- [[file:vm-memory-map.rkt::90][$e0]] :: ZP_VM_FUNC_PTR  e0..e1 pointer to the currently running function
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e0..e1 pointer to the currently running function
- [[file:vm-memory-map.rkt::92][$e2]] :: ZP_LOCALS_LB_PTR  e2..e3 pointer to low byte of first local in call-frame
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e2..e3 pointer to low byte of first local in call-frame
- [[file:vm-memory-map.rkt::94][$e4]] :: ZP_LOCALS_HB_PTR  e4..e5 pointer to high byte of first local in call-frame
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e4..e5 pointer to high byte of first local in call-frame
- [[file:vm-memory-map.rkt::96][$e6]] :: ZP_CELL_STACK_LB_PTR  e6..e7 (pointer to low byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e6..e7 (pointer to low byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
- [[file:vm-memory-map.rkt::98][$e8]] :: ZP_CELL_STACK_HB_PTR  e8..e9 (pointer to high byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e8..e9 (pointer to high byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
- [[file:vm-memory-map.rkt::100][$ea]] :: ZP_CALL_FRAME_TOP_MARK  ea byte pointing to current top of call-frame (is swapped in/out of call-frame page $02)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  ea byte pointing to current top of call-frame (is swapped in/out of call-frame page $02)
- [[file:vm-memory-map.rkt::102][$eb]] :: ZP_LOCALS_TOP_MARK  eb byte pointing to the byte past the last local on the locals stack
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  eb byte pointing to the byte past the last local on the locals stack
- [[file:vm-memory-map.rkt::104][$f1]] :: ZP_CALL_FRAME  f1..f2
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  f1..f2
* zero-page-locations (by name)
- [[file:vm-memory-map.rkt::104][ZP_CALL_FRAME]] :: $f1  f1..f2
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  f1..f2
- [[file:vm-memory-map.rkt::100][ZP_CALL_FRAME_TOP_MARK]] :: $ea  ea byte pointing to current top of call-frame (is swapped in/out of call-frame page $02)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  ea byte pointing to current top of call-frame (is swapped in/out of call-frame page $02)
- [[file:vm-memory-map.rkt::98][ZP_CELL_STACK_HB_PTR]] :: $e8  e8..e9 (pointer to high byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e8..e9 (pointer to high byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
- [[file:vm-memory-map.rkt::96][ZP_CELL_STACK_LB_PTR]] :: $e6  e6..e7 (pointer to low byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e6..e7 (pointer to low byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
- [[file:vm-memory-map.rkt::72][ZP_CELL_STACK_TOS]] :: $db  byte (fe = empty stack, 0 = first element, 2 = second element, 4 = third element ...)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  byte (fe = empty stack, 0 = first element, 2 = second element, 4 = third element ...)
- [[file:vm-memory-map.rkt::94][ZP_LOCALS_HB_PTR]] :: $e4  e4..e5 pointer to high byte of first local in call-frame
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e4..e5 pointer to high byte of first local in call-frame
- [[file:vm-memory-map.rkt::92][ZP_LOCALS_LB_PTR]] :: $e2  e2..e3 pointer to low byte of first local in call-frame
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e2..e3 pointer to low byte of first local in call-frame
- [[file:vm-memory-map.rkt::102][ZP_LOCALS_TOP_MARK]] :: $eb  eb byte pointing to the byte past the last local on the locals stack
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  eb byte pointing to the byte past the last local on the locals stack
- [[file:vm-memory-map.rkt::66][ZP_TEMP3]] :: $d9  zero page location 3 for temp usage
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  zero page location 3 for temp usage
  may be used as pointer (in combination with ZP_TEMP4 => must be in adjacent memory locations)
- [[file:vm-memory-map.rkt::69][ZP_TEMP4]] :: $da  zero page location 4 for temp usage
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  zero page location 4 for temp usage
- [[file:vm-memory-map.rkt::90][ZP_VM_FUNC_PTR]] :: $e0  e0..e1 pointer to the currently running function
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e0..e1 pointer to the currently running function
- [[file:vm-memory-map.rkt::87][ZP_VM_PC]] :: $de  the following twelve bytes need to be continuous, since they are saved into the call frame!
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  the following twelve bytes need to be continuous, since they are saved into the call frame!
  de..df program counter (ptr to currently executing byte code)
* zero-page-locations (by group)
** locals
- [[file:vm-memory-map.rkt::94][ZP_LOCALS_HB_PTR]] :: $e4  e4..e5 pointer to high byte of first local in call-frame
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e4..e5 pointer to high byte of first local in call-frame
- [[file:vm-memory-map.rkt::92][ZP_LOCALS_LB_PTR]] :: $e2  e2..e3 pointer to low byte of first local in call-frame
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e2..e3 pointer to low byte of first local in call-frame
- [[file:vm-memory-map.rkt::102][ZP_LOCALS_TOP_MARK]] :: $eb  eb byte pointing to the byte past the last local on the locals stack
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  eb byte pointing to the byte past the last local on the locals stack
** call_frame
- [[file:vm-memory-map.rkt::104][ZP_CALL_FRAME]] :: $f1  f1..f2
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  f1..f2
- [[file:vm-memory-map.rkt::100][ZP_CALL_FRAME_TOP_MARK]] :: $ea  ea byte pointing to current top of call-frame (is swapped in/out of call-frame page $02)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  ea byte pointing to current top of call-frame (is swapped in/out of call-frame page $02)
- [[file:vm-memory-map.rkt::90][ZP_VM_FUNC_PTR]] :: $e0  e0..e1 pointer to the currently running function
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e0..e1 pointer to the currently running function
- [[file:vm-memory-map.rkt::87][ZP_VM_PC]] :: $de  the following twelve bytes need to be continuous, since they are saved into the call frame!
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  the following twelve bytes need to be continuous, since they are saved into the call frame!
  de..df program counter (ptr to currently executing byte code)
** evlstk
- [[file:vm-memory-map.rkt::98][ZP_CELL_STACK_HB_PTR]] :: $e8  e8..e9 (pointer to high byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e8..e9 (pointer to high byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
- [[file:vm-memory-map.rkt::96][ZP_CELL_STACK_LB_PTR]] :: $e6  e6..e7 (pointer to low byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  e6..e7 (pointer to low byte of the eval stack of the currently running function (+ZP_CELL_STACK_TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_RT!)
- [[file:vm-memory-map.rkt::72][ZP_CELL_STACK_TOS]] :: $db  byte (fe = empty stack, 0 = first element, 2 = second element, 4 = third element ...)
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  byte (fe = empty stack, 0 = first element, 2 = second element, 4 = third element ...)
** temp
- [[file:vm-memory-map.rkt::69][ZP_TEMP4]] :: $da  zero page location 4 for temp usage
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  zero page location 4 for temp usage
- [[file:vm-memory-map.rkt::66][ZP_TEMP3]] :: $d9  zero page location 3 for temp usage
  - len :: byte
  - racket require :: (require (only-in "vm-memory-map.rkt" VM_MEMORY_MANAGEMENT_CONSTANTS))
  - assembler include :: VM_MEMORY_MANAGEMENT_CONSTANTS
  zero page location 3 for temp usage
  may be used as pointer (in combination with ZP_TEMP4 => must be in adjacent memory locations)
* memory-locations (by address)
- [[file:vm-mm-pages.rkt::66][$cec0]] :: GLOBAL_CELL_PAGE_FOR_ALLOC  page with free cells
  - len :: byte
  - racket require :: (require (only-in "vm-mm-pages.rkt" VM_INITIAL_MM_REGS))
  - assembler include :: VM_INITIAL_MM_REGS
  page with free cells
- [[file:vm-mm-pages.rkt::85][$cec5]] :: GLOBAL_CELLPAIR_FREE_LIST  this queue holds only cell-pairs, cell0 is always the pointer to the next in queue of this free cells
  - len :: word
  - racket require :: (require (only-in "vm-mm-pages.rkt" VM_INITIAL_MM_REGS))
  - assembler include :: VM_INITIAL_MM_REGS
  this queue holds only cell-pairs, cell0 is always the pointer to the next in queue of this free cells
  cell1 is left untouched => may still hold live references => to reuse a cell-pair of this queue,
  cell1 must be checked (if ptr, decr ref count and possibly free, else ignore)
  list of cell-pairs that are unused but only potentially partially freed (second cell may still hold references to heap objects)
  if high byte is 0, the tree is empty!
* memory-locations (by name)
- [[file:vm-mm-pages.rkt::66][GLOBAL_CELL_PAGE_FOR_ALLOC]] :: $cec0  page with free cells
  - len :: byte
  - racket require :: (require (only-in "vm-mm-pages.rkt" VM_INITIAL_MM_REGS))
  - assembler include :: VM_INITIAL_MM_REGS
  page with free cells
- [[file:vm-mm-pages.rkt::85][GLOBAL_CELLPAIR_FREE_LIST]] :: $cec5  this queue holds only cell-pairs, cell0 is always the pointer to the next in queue of this free cells
  - len :: word
  - racket require :: (require (only-in "vm-mm-pages.rkt" VM_INITIAL_MM_REGS))
  - assembler include :: VM_INITIAL_MM_REGS
  this queue holds only cell-pairs, cell0 is always the pointer to the next in queue of this free cells
  cell1 is left untouched => may still hold live references => to reuse a cell-pair of this queue,
  cell1 must be checked (if ptr, decr ref count and possibly free, else ignore)
  list of cell-pairs that are unused but only potentially partially freed (second cell may still hold references to heap objects)
  if high byte is 0, the tree is empty!
* memory-locations (by group)
** cell_pair
- [[file:vm-mm-pages.rkt::85][GLOBAL_CELLPAIR_FREE_LIST]] :: $cec5  this queue holds only cell-pairs, cell0 is always the pointer to the next in queue of this free cells
  - len :: word
  - racket require :: (require (only-in "vm-mm-pages.rkt" VM_INITIAL_MM_REGS))
  - assembler include :: VM_INITIAL_MM_REGS
  this queue holds only cell-pairs, cell0 is always the pointer to the next in queue of this free cells
  cell1 is left untouched => may still hold live references => to reuse a cell-pair of this queue,
  cell1 must be checked (if ptr, decr ref count and possibly free, else ignore)
  list of cell-pairs that are unused but only potentially partially freed (second cell may still hold references to heap objects)
  if high byte is 0, the tree is empty!
** page
- [[file:vm-mm-pages.rkt::66][GLOBAL_CELL_PAGE_FOR_ALLOC]] :: $cec0  page with free cells
  - len :: byte
  - racket require :: (require (only-in "vm-mm-pages.rkt" VM_INITIAL_MM_REGS))
  - assembler include :: VM_INITIAL_MM_REGS
  page with free cells
* functions (by name)
- [[file:vm-mm-m1-slots.rkt::321][ADD_M1_SLOT_RZ_TO_PFL]] ::  add the given m1 slot in RZ back to the page free list of slots
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" ADD_M1_SLOT_RZ_TO_PFL))
  - assembler include :: ADD_M1_SLOT_RZ_TO_PFL
  add the given m1 slot in RZ back to the page free list of slots
  input:  RZ, page-meta-data
  usage:  A, X, Y, RZ
  output: page-meta-data
  funcs:
    DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_RZ
    PUT_PAGE_AS_HEAD_OF_M1_PAGE_RZ
- [[file:vm-mm-cells.rkt::775][ALLOC_CELL_AX_TO_RT]] ::  allocate the cell at A on page X
  - racket require :: (require (only-in "vm-mm-cells.rkt" ALLOC_CELL_AX_TO_RT))
  - assembler include :: ALLOC_CELL_AX_TO_RT
  allocate the cell at A on page X

  update next free cell in vm_page_slot_data
  update number of allocated cells on page X
  input:  A = lowbyte
          X = highbyte (page)
          # cells allocated on PAGE
  output: A = next free cell
          X = PAGE
          Y = 0
          VM_PAGE_SLOT_DATA + PAGE = next free cell
          # cells allocated on PAGE ++
- [[file:vm-mm-cells.rkt::585][ALLOC_CELL_TO_RT]] ::  allocate (or reuse from free-list) cell into rt
  - racket require :: (require (only-in "vm-mm-cells.rkt" ALLOC_CELL_TO_RT))
  - assembler include :: ALLOC_CELL_TO_RT
  allocate (or reuse from free-list) cell into rt

  input:  GLOBAL_CELL_FREE_LIST
          GLOBAL_CELL_PAGE_FOR_ALLOC
          VM_PAGE_SLOT_DATA
          # cells allocated on PAGE
  output: ZP_RT: ptr to heap allocated cell (cell itself is not initialized!)
          GLOBAL_CELL_FREE_LIST
          A, X, Y: ?
- [[file:vm-mm-cell-array.rkt::159][ALLOC_CELLARR_TO_RA]] ::  allocate an array of cells (also useful for structures)
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" ALLOC_CELLARR_TO_RA))
  - assembler include :: ALLOC_CELLARR_TO_RA
  allocate an array of cells (also useful for structures)
  this does overwrite RA without check RAs content!
  input:  A = number of cells (1..40)
  usage:  A, X, Y, RA
  output: RA -> points to an allocated array
  funcs:
    ALLOC_M1_SLOT_TO_RA
- [[file:vm-mm-cell-pairs.rkt::252][ALLOC_CELLPAIR_AX_TO_RT]] ::  allocate a cell-pair from this page (if page has no free cell-pairs, a new page is allocated and is used to get a free cell-pair!)
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" ALLOC_CELLPAIR_AX_TO_RT))
  - assembler include :: ALLOC_CELLPAIR_AX_TO_RT
  allocate a cell-pair from this page (if page has no free cell-pairs, a new page is allocated and is used to get a free cell-pair!)
  this will not check the free cell-pair tree!
  input:  X : page to allocate cell-pair on (a new page is allocated, if this page does not have any free cell-pairs)
          A : slot to allocated (must be the first free slot of this page)
  output: ZP_RT
  WARNING: ZP_RT IS OVERWRITTEN !! NO PUSH INTO THE CELL-STACK IS DONE!
- [[file:vm-mm-cell-pairs.rkt::295][ALLOC_CELLPAIR_TO_RT]] ::  try to reuse root of free tree: use root but make sure to deallocate cell1 of the root (since this might still point to some data)
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" ALLOC_CELLPAIR_TO_RT))
  - assembler include :: ALLOC_CELLPAIR_TO_RT
  try to reuse root of free tree: use root but make sure to deallocate cell1 of the root (since this might still point to some data)
  if no free tree available, find page with free cells (GLOBAL_CELLPAIR_PAGE_FOR_ALLOC)
  if no free cell page is available, allocate a new page and used the first free slot there
  NOTE: the cell-pair is not initialized (cell0 and/or cell1 may contain old data that needs to be overwritten!)
  input:  GLOBAL_CELLPAIR_FREE_LIST
  usage:  A, X, Y
  output: RT
  funcs:
    GET_FRESH_CELLPAIR_TO_AX
    ALLOC_CELLPAIR_AX_TO_RT
    WRITE_CELLPAIR_RT_CELL1_TO_RT
    DEC_REFCNT_RT
- [[file:vm-call-frame.rkt::116][ALLOC_LOCALS_STACK]] ::  allocate two pages for a cell-stack, store previous ZP_LOCALS_xB ptrs into these
  - racket require :: (require (only-in "vm-call-frame.rkt" ALLOC_LOCALS_STACK))
  - assembler include :: ALLOC_LOCALS_STACK
  allocate two pages for a cell-stack, store previous ZP_LOCALS_xB ptrs into these
  and initialise the new cell-stack
  input:  ZP_LOCALS_LB_PTR  ptr to old locals cell-stack
          ZP_LOCALS_HB_PTR
  usage:  A X Y
  output: ZP_LOCALS_LB_PTR  ptr to new locals cell-stack
          ZP_LOCALS_HB_PTR
- [[file:vm-mm-m1-slots.rkt::494][ALLOC_M1_SLOT_TO_RA]] ::  allocate a slot of min A size, allocating a new page if necessary
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" ALLOC_M1_SLOT_TO_RA))
  - assembler include :: ALLOC_M1_SLOT_TO_RA
  allocate a slot of min A size, allocating a new page if necessary
  input:  A = size
  usage:  A, X, Y, RA, GLOBAL_M1_PX_PAGE_FOR_ALLOC
  output: RA = available slot of the given size (or a bit more)
          Y = actual size
          GLOBAL_M1_PX_PAGE_FOR_ALLOC
  funcs:
    VM_REMOVE_FULL_PAGE_FOR_TYPE_X_SLOTS
    ALLOC_PAGE_TO_X
    INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX
- [[file:vm-mm-m1-slots.rkt::452][ALLOC_M1_SLOT_TO_RB]] ::  allocate a slot of min A size, allocating a new page if necessary
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" ALLOC_M1_SLOT_TO_RB))
  - assembler include :: ALLOC_M1_SLOT_TO_RB
  allocate a slot of min A size, allocating a new page if necessary
  input:  A = size
  usage:  A, X, Y, RB, GLOBAL_M1_PX_PAGE_FOR_ALLOC
  output: RB = available slot of the given size (or a bit more)
          Y = actual size
          GLOBAL_M1_PX_PAGE_FOR_ALLOC
  funcs:
    VM_REMOVE_FULL_PAGE_FOR_TYPE_X_SLOTS
    ALLOC_PAGE_TO_X
    INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX
    ALLOC_M1_SLOT_TO_RA,
    SWAP_RA_RB
- [[file:vm-mm-native-array.rkt::107][ALLOC_NATARR_TO_RA]] ::  allocate an array of bytes (native) (also useful for strings)
  - racket require :: (require (only-in "vm-mm-native-array.rkt" ALLOC_NATARR_TO_RA))
  - assembler include :: ALLOC_NATARR_TO_RA
  allocate an array of bytes (native) (also useful for strings)
  overwrite RA no matter whether RA was filled
  input:  A = number of bytes (1..81)
  usage:  A, X, Y, RA
  output: RA -> points to an allocated array (not initialized)
          RAI = 0
  funcs:
    ALLOC_M1_SLOT_TO_RA
- [[file:vm-mm-pages.rkt::238][ALLOC_PAGE_TO_X]] ::  does a linear search for the next free page
  - racket require :: (require (only-in "vm-mm-pages.rkt" ALLOC_PAGE_TO_X))
  - assembler include :: ALLOC_PAGE_TO_X
  does a linear search for the next free page
  allocate a page (completely uninitialized), just the page, update the memory page status in VM_PAGE_SLOT_DATA
  parameter: (none)
  result: X = allocated free page (uninitialized)
  uses: A, X
- [[file:vm-mm-native-array.rkt::334][CP_NATARR_RA_TO_RB]] ::  copy the whole lenght of the array ra into the array rb (same position)
  - racket require :: (require (only-in "vm-mm-native-array.rkt" CP_NATARR_RA_TO_RB))
  - assembler include :: CP_NATARR_RA_TO_RB
  copy the whole lenght of the array ra into the array rb (same position)
  input:  RA, RB
  usage:  A, Y
  output: start of RB is equal to RA (length of RB needs to >= RA)
- [[file:vm-mm-native-array.rkt::400][CP_NATARR_RANGE_RA_TO_RB]] ::  copy from nat array ra, range index x..y to the start of array rb
  - racket require :: (require (only-in "vm-mm-native-array.rkt" CP_NATARR_RANGE_RA_TO_RB))
  - assembler include :: CP_NATARR_RANGE_RA_TO_RB
  copy from nat array ra, range index x..y to the start of array rb
  input:  RA, RB, X, Y
  usage:  A, X, Y
  output: start of RB is equal to RA@X..Y (0-indexed), RB needs to have sufficient size (>=Y-X)
- [[file:vm-mm-register-functions.rkt::98][CP_RA_TO_RT]] ::  copy RA -> RT
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RA_TO_RT))
  - assembler include :: CP_RA_TO_RT
  copy RA -> RT
  input:  RA
  output: RT (copy of RA)
- [[file:vm-mm-register-functions.rkt::112][CP_RA_TO_RZ]] ::  copy RA -> RZ
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RA_TO_RZ))
  - assembler include :: CP_RA_TO_RZ
  copy RA -> RZ
  input:  RA
  output: RZ (copy of RA)
- [[file:vm-mm-register-functions.rkt::125][CP_RB_TO_RZ]] ::  copy RB -> RZ
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RB_TO_RZ))
  - assembler include :: CP_RB_TO_RZ
  copy RB -> RZ
  input:  RB
  output: RZ (copy of RA)
- [[file:vm-mm-register-functions.rkt::138][CP_RC_TO_RZ]] ::  copy RC -> RZ
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RC_TO_RZ))
  - assembler include :: CP_RC_TO_RZ
  copy RC -> RZ
  input:  RC
  output: RZ (copy of RA)
- [[file:vm-mm-register-functions.rkt::190][CP_RT_TO_RA]] ::  copy RT -> RA
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RT_TO_RA))
  - assembler include :: CP_RT_TO_RA
  copy RT -> RA
  input:  RT
  output: RA (copy of RT)
- [[file:vm-mm-register-functions.rkt::203][CP_RT_TO_RB]] ::  copy RT -> RB
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RT_TO_RB))
  - assembler include :: CP_RT_TO_RB
  copy RT -> RB
  input:  RT
  output: RB (copy of RT)
- [[file:vm-mm-register-functions.rkt::177][CP_RT_TO_RP]] ::  copy RT -> RP
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RT_TO_RP))
  - assembler include :: CP_RT_TO_RP
  copy RT -> RP
  input:  RT
  output: RP (copy of RT)
- [[file:vm-mm-register-functions.rkt::151][CP_RT_TO_RZ]] ::  copy RT -> RZ
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RT_TO_RZ))
  - assembler include :: CP_RT_TO_RZ
  copy RT -> RZ
  input:  RT
  output: RZ (copy of RT)
- [[file:vm-mm-register-functions.rkt::164][CP_RZ_TO_RT]] ::  copy RZ -> RT
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RZ_TO_RT))
  - assembler include :: CP_RZ_TO_RT
  copy RZ -> RT
  input:  RZ
  output: RT (copy of RZ)
- [[file:vm-memory-manager.rkt::377][DEC_REFCNT_RZ]] ::  decrement the refcount (if a pointer) in RZ, call respective free if refcount drops to 0
  - racket require :: (require (only-in "vm-memory-manager.rkt" FREE_M1_SLOT_RZm1))
  - assembler include :: FREE_M1_SLOT_RZm1
  decrement the refcount (if a pointer) in RZ, call respective free if refcount drops to 0
  input:  RZ (RA, RT)
  usage:  A, X, Y, RZ
  output:
  funcs:
    FREE_M1_SLOT_RZ >>
    FREE_CELL_RZ >>
    FREE_CELLPAIR_RZ >>
- [[file:vm-mm-m1-slots.rkt::409][DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_A]] ::  drop all full pages from the list of pages with available slots
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_A))
  - assembler include :: DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_A
  drop all full pages from the list of pages with available slots
  input:  RZ, GLOBAL_M1_PX_PAGE_FOR_ALLOC
  usage:  A, X, Y
  output: GLOBAL_M1_PX_PAGE_FOR_ALLOC of this profile holds page with free slots
  funcs:  -
- [[file:vm-mm-cells.rkt::393][FREE_CELL_RZ]] ::  free the given cell in RZ (RA, RT), and dec-refcnt its content (if it is a pointer)
  - racket require :: (require (only-in "vm-mm-cells.rkt" FREE_CELL_RT))
  - assembler include :: FREE_CELL_RT
  free the given cell in RZ (RA, RT), and dec-refcnt its content (if it is a pointer)
  it must not be a header cell of an array or something
  input: RZ
  usage: A, X, Y, RZ
  output: -
  funcs:
    DEC_REFCNT_RZ
    (CP_RA_TO_RZ)
    (CP_RT_TO_RZ)
- [[file:vm-mm-cell-pairs.rkt::954][FREE_CELLPAIR_RZ]] ::  put the given cellpair on the global free list
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" FREE_CELLPAIR_RT))
  - assembler include :: FREE_CELLPAIR_RT
  put the given cellpair on the global free list
  dec-refcnt cell0 if it is a ptr, defer dec-refcnt cell1 to allocation/reuse time
  input: RZ (RT RA), GLOBAL_CELLPAIR_FREE_LIST
  usage: A, X, Y, RZ
  output: GLOBAL_CELLPAIR_FREE_LIST << RZ
  funcs:
    DEC_REFCNT_RZ>>
- [[file:vm-mm-m1-slots.rkt::823][FREE_M1_SLOT_RA]] ::  free the m1 slot pointed to by ra, marking that slot free on the m1-page
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" FREE_M1_SLOT_RA))
  - assembler include :: FREE_M1_SLOT_RA
  free the m1 slot pointed to by ra, marking that slot free on the m1-page
  no check of the slot content is done! in case of cell-arrays: the elements of the array are not checked
  input:  RA
  usage: A, X, Y, RA
  output: RA is invalid
  funcs:
    VM_ENQUEUE_PAGE_AS_HEAD_FOR_RA_SLOTS
    VM_REMOVE_FULL_PAGES_FOR_RA_SLOTS
  currently once allocated pages are not garbage collected. this is bad and needs to be changed
  (e.g. keep count of used slots)? used slots = 0 => free page
  INFO: NO GC! (this must be done, freeing specific types (e.g. an array) <- knows the number of slots etc.
        REF COUNT IS SET TO ZERO (of this slot)
- [[file:vm-mm-m1-slots.rkt::1017][FREE_M1_SLOT_RZ]] ::  free the m1 slot referenced by RZ
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" FREE_M1_SLOT_RZ))
  - assembler include :: FREE_M1_SLOT_RZ
  free the m1 slot referenced by RZ
  input: RZ
  usage: A, X, Y, RZ
  output:
  funcs:
    GC_INCR_ARRAY_SLOT_RZ >>
    ADD_M1_SLOT_RZ_TO_PFL >>
- [[file:vm-mm-pages.rkt::268][FREE_PAGE_A]] ::  whether a page is free or used is kept in the 256 bytes starting at VM_PAGE_SLOT_DATA
  - racket require :: (require (only-in "vm-mm-pages.rkt" FREE_PAGE_A))
  - assembler include :: FREE_PAGE_A
  whether a page is free or used is kept in the 256 bytes starting at VM_PAGE_SLOT_DATA
  each byte represents one page
    00 = allocated (used) but no free slots
    01 = system page, not available for memory management
    ff = free page (not allocated yet)
  VM_HIGHEST_PAGE_IDX_FOR_ALLOC_SEARCH  (255..0) keeps the max idx to start looking for a page that is free
  parameter: a = page
  result: (none)
- [[file:vm-memory-manager.rkt::311][FREE_RT]] ::  free nonatomic (is cell-ptr, cell-pair-ptr, cell-array-ptr, native-array-ptr)
  - racket require :: (require (only-in "vm-memory-manager.rkt" FREE_RT))
  - assembler include :: FREE_RT
  free nonatomic (is cell-ptr, cell-pair-ptr, cell-array-ptr, native-array-ptr)
  parameter: zp_rt
- [[file:vm-memory-manager.rkt::606][GC_ALL]] ::  garbage collect all cells, all cell-pairs and all cell arrays marked for reuse or partially collected
  - racket require :: (require (only-in "vm-memory-manager.rkt" GC_ALL))
  - assembler include :: GC_ALL
  garbage collect all cells, all cell-pairs and all cell arrays marked for reuse or partially collected
  input:  GLOBAL_CELL_FREE_LIST, GLOBAL_CELLPAIR_FREE_LIST, ZP_PART_GCD_CELL_ARRAYS
  usage:  A, X, Y, RZ
  output: GLOBAL_CELL_FREE_LIST+1      = 0
          GLOBAL_CELLPAIR_FREE_LIST+1  = 0
          ZP_PART_GCD_CELL_ARRAYS+1    = 0
  funcs:
    GC_CELL_ARRAYS
    GC_CELL_ARRAY
    GC_INCR_ARRAY_SLOT_RZ
    GC_CELLPAIR_FREE_LIST
    DEC_REFCNT_RZ >>
    GC_CELLS
- [[file:vm-mm-cell-array.rkt::260][GC_CELL_ARRAY]] ::  keep collecting until the whole (single) array was collected but stop then!
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" GC_CELL_ARRAY))
  - assembler include :: GC_CELL_ARRAY
  keep collecting until the whole (single) array was collected but stop then!
  input:  ZP_PART_GCD_CELL_ARRAYS
  usage:  A, X, Y, RZ
  output: <<ZP_PART_GCD_CELL_ARRAYS<<
  funcs:
    GC_INCR_ARRAY_SLOT_RZ
- [[file:vm-mm-cell-array.rkt::235][GC_CELL_ARRAYS]] ::  do incremental collections until all cell arrays (and their slots) were garbage collected
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" GC_CELL_ARRAYS))
  - assembler include :: GC_CELL_ARRAYS
  do incremental collections until all cell arrays (and their slots) were garbage collected
  input:  ZP_PART_GCD_CELL_ARRAYS
  usage:  A, X, Y, RZ
  output: ZP_PART_GCD_CELL_ARRAYS+1 = 0  (no more arrays left that are partially gc'd)
  funcs:
    GC_CELL_ARRAY
    GC_INCR_ARRAY_SLOT_RZ
- [[file:vm-mm-cell-pairs.rkt::1204][GC_CELLPAIR_FREE_LIST]] ::  actively free all enqueued cell pairs of the free-list!
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" GC_CELLPAIR_FREE_LIST))
  - assembler include :: GC_CELLPAIR_FREE_LIST
  actively free all enqueued cell pairs of the free-list!
  can be useful to find out whether a whole page is not used at all. free cells are still marked as used on a page.
  input:  GLOBAL_CELLPAIR_FREE_LIST
  usage:  A, Y, RZ
  output: GLOBAL_CELLPAIR_FREE_LIST+1 = 0
  funcs:
    DEC_REFCNT_RZ >>
    GC_CELLPAIR_FREE_LIST
- [[file:vm-mm-cells.rkt::849][GC_CELLS]] ::  garbage collect all cells marked as reusable in GLOBAL_CELL_FFREE_LIST
  - racket require :: (require (only-in "vm-mm-cells.rkt" GC_CELLS))
  - assembler include :: GC_CELLS
  garbage collect all cells marked as reusable in GLOBAL_CELL_FFREE_LIST
  input:  GLOBAL_CELL_FFREE_LIST
  usage:  A, X, Y, RZ
  output: GLOBAL_CELL_FFREE_LIST+1 = 0   (no more cells left for reuse)
  funcs:  -
- [[file:vm-mm-cell-array.rkt::299][GC_INCR_ARRAY_SLOT_RA]] ::  incrementally garbage collect an array by slots (see GC_INCR_ARRAY_SLOT_RZ)
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" GC_INCR_ARRAY_SLOT_RZ))
  - assembler include :: GC_INCR_ARRAY_SLOT_RZ
  incrementally garbage collect an array by slots (see GC_INCR_ARRAY_SLOT_RZ)
- [[file:vm-mm-cell-array.rkt::302][GC_INCR_ARRAY_SLOT_RZ]] ::  incrementally garbage collect an array by slots
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" GC_INCR_ARRAY_SLOT_RZ))
  - assembler include :: GC_INCR_ARRAY_SLOT_RZ
  incrementally garbage collect an array by slots
  may destroy RZ (on dec refcnt of a cell in the array)
  will free this cell-array, if no refcnts need to be dec (anymore)
  will add this cell array to ZP_PART_GCD_CELL_ARRAYS if not completely gc'd
  input: RZ
  usage: A, X, Y, RZ
  output: -
  funcs:
    DEC_REFCNT_RZ
    ADD_M1_SLOT_RZ_TO_PLF
- [[file:vm-mm-cells.rkt::711][GET_FRESH_CELL_TO_AX]] ::  get the page and unused cell for allocation
  - racket require :: (require (only-in "vm-mm-cells.rkt" GET_FRESH_CELL_TO_AX))
  - assembler include :: GET_FRESH_CELL_TO_AX
  get the page and unused cell for allocation

  get the complete ptr, do not allocate this cell yet
  allocate a new page if necessary
  do not use any cell free list
  input:  GLOBAL_CELL_PAGE_FOR_ALLOC
          VM_PAGE_SLOT_DATA+PAGE
  output: A = lowbyte
          X = highbyte (page)
          Y = ?
- [[file:vm-mm-cell-pairs.rkt::588][GET_FRESH_CELLPAIR_TO_AX]] ::  get the page and unused cellpair for allocation
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" GET_FRESH_CELLPAIR_TO_AX))
  - assembler include :: GET_FRESH_CELLPAIR_TO_AX
  get the page and unused cellpair for allocation

  get the complete ptr, do not allocate this cellpair yet
  allocate a new page if necessary
  do not use any cellpair free list
  input:  VM_FREE_CELL__PAIR_PAGE
          VM_PAGE_SLOT_DATA+PAGE
  output: A = lowbyte
          X = highbyte (page)
          Y = ?
- [[file:vm-mm-m1-slots.rkt::964][INC_REFCNT_M1_SLOT_RA]] ::  increment refcount of m1 slot in RA
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" INC_REFCNT_M1_SLOT_RA))
  - assembler include :: INC_REFCNT_M1_SLOT_RA
  increment refcount of m1 slot in RA
  IDEA for optimization: keep m1 in RA, putting +1 offset on all accesses -> DEC/INC could be saved
  input:  RA (pointing to some m1 slot)
  usage:  A, Y, RA
  output: M1_SLOT Refcount++
  funcs: -
- [[file:vm-memory-manager.rkt::224][INC_REFCNT_RT]] ::  find out what kind of cell zp_rt points to,
  - racket require :: (require (only-in "vm-memory-manager.rkt" INC_REFCNT_CELLARR_RT))
  - assembler include :: INC_REFCNT_CELLARR_RT
  find out what kind of cell zp_rt points to,
  then call the right decrement refcounts function
  input:  ZP_RT
  output: the right refcount is decremented
          (in case of m1 pages, @ZP_RT-1)
          (in case of cell pages @ZP_RT>>1)
          (in case of cell-pair pages @ZP_RT>>2)
- [[file:vm-mm-cell-pairs.rkt::112][INIT_CELLPAIR_PAGE_X_TO_AX]] ::  cell-pair page layout  (new layout with cell-pair-ptr having bit0 always set and bit1 always unset!)
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" INIT_CELLPAIR_PAGE_X_TO_AX))
  - assembler include :: INIT_CELLPAIR_PAGE_X_TO_AX
  cell-pair page layout  (new layout with cell-pair-ptr having bit0 always set and bit1 always unset!)
  offset  content
  00      #b01xx xxxx page type + number of used slots
  01      ref-count cell-pair at 05 (cell-pair 0)
  02      ref-count cell-pair at 09 (cell-pair 1)
  03..04   unused (2)
  05..08   cell-pair 0     (#b0000 01[01] >> 2 = #b0000 0001)
  09..0c   cell-pair 1     (#b0000 10[01] >> 2 = #b0000 0010)
  0d..0f   unused (3)
  10      ref-count for cell-pair at 40 (cell-pair 2)
  11      ref-count for cell-pair at 44 (cell-pair 3)
  ..3e     ref-count for cell-pair at f9 (cell-pair 48)
  3f..40   unused (2)
  41..44   cell-pair 2     (#b0100 00[01] >> 2 = #b0001 0000)
  45..48   cell-pair 3     (#b0100 01[01] >> 2 = #b0001 0001)
  ...
  f9..fc   cell-pair 48    (#b1111 10[01] >> 2 = #b0011 1110)
  fd..fe   unused (2)
  ff      previous page of this type

  VM_PAGE_SLOT_DATA + pageidx: holds the index within the page of the first free cell-pair on that page (0 = no free cell-pair on this page)
  the free cell-pair holds in byte 0 of the cell-pair the offset of the next free cell-pair (0 = no other free cell-pair)

  allocate a complete new page and initialize it to hold reference counted cell-pairs
  connect all cell-pairs in a free-list
  also set the first free slot of this allocated page (in VM_PAGE_SLOT_DATA + pageidx)

  input:  X = page allocated but uninitialized
  output: X = page allocated and initialized for cell-pairs usage
          A = first free slot ($05)
  usage:  X, Y, ZP_TEMP, ZP_TEMP2
- [[file:vm-mm-cell-stack.rkt::78][INIT_CELLSTACK_PAGE_X]] ::  cell stack page(s)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" INIT_CELLSTACK_PAGE_X))
  - assembler include :: INIT_CELLSTACK_PAGE_X
  cell stack page(s)
  offset  content
  00      #b0001 1011
  01      previous page (of the stack)
  02..ff  payload (either lowbyte or highbyte of the cell)

  input:  A old stack page
          X new stack page
  output: X new stack page
  uses:   A, X, Y
          ZP_TEMP, ZP_TEMP+1
- [[file:vm-mm-m1-slots.rkt::88][INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX]] ::  page type slot w/ different sizes (refcount @ ptr-1) x cells
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX))
  - assembler include :: INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX
  page type slot w/ different sizes (refcount @ ptr-1) x cells
  math: first entry @FIRST_REF_COUNT_OFFSET__INIT_M1Px_PAGE_A + 1, refcount @ -1, next slot += INC_TO_NEXT_SLOT__INIT_M1Px_PAGE_A, slot-size = INC_TO_NEXT_SLOT__INIT_M1Px_PAGE_A -1
  input : Y = profile offset (0, 2, 4 ...)
          X = page
  uses  : A, X, Y, RZ
  output: X = page, initialized as m1 page of profile y
          A = first free slot
  funcs:  -
- [[file:vm-mm-cell-stack.rkt::502][POP_CELL_EVLSTK_TO_CELLy_RT]] ::  write the TOS of the EVLSTK (not RT) into CELL Y of cell-pair referenced by RT
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_CELLy_RT))
  - assembler include :: POP_CELL_EVLSTK_TO_CELLy_RT
  write the TOS of the EVLSTK (not RT) into CELL Y of cell-pair referenced by RT
  keep RT and pop TOS of EVLSTK ( RT+EVLSTK  -> RT+<<EVLSTK<<, and (Y=0) RT -> [<<EVLSTK][...], or (Y=1) RT -> [...][<<EVLSTK]
  no inc/dec refcnt needs to take place, since # references to RT nor the popped TOS of EVLSTK do change
  input:  cell-stack (TOS)
          RT (must be a cell-pair ptr
          y = (0 = cell0, 2 = cell1)
  usage:  A, Y
  output: cell-stack (one value less)
          cell0 of RA is set
  funcs:  -
- [[file:vm-mm-cell-stack.rkt::564][POP_CELL_EVLSTK_TO_RA]] ::  pop cell from stack (that is, discard RegT, move tos of call-frame stack into Reg A (if available))
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_RA))
  - assembler include :: POP_CELL_EVLSTK_TO_RA
  pop cell from stack (that is, discard RegT, move tos of call-frame stack into Reg A (if available))
  input: call-frame stack, RA
  output:  RA << EVLSTK, <<EVLSTK<<, RT unchanged!
  NO GC CHECKS!
- [[file:vm-mm-cell-stack.rkt::607][POP_CELL_EVLSTK_TO_RP]] ::  pop cell from stack (that is, discard RegT, move tos of call-frame stack into Reg A (if available))
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_RP))
  - assembler include :: POP_CELL_EVLSTK_TO_RP
  pop cell from stack (that is, discard RegT, move tos of call-frame stack into Reg A (if available))
  input: call-frame stack, RA
  output:  RP << EVLSTK, <<EVLSTK<<, RT unchanged!
  NO GC CHECKS!
- [[file:vm-mm-cell-stack.rkt::131][POP_CELL_EVLSTK_TO_RT]] ::  pop the topmost value of the evlstk into RT (no gc done)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_RT))
  - assembler include :: POP_CELL_EVLSTK_TO_RT
  pop the topmost value of the evlstk into RT (no gc done)
  input:  EVLSTK
  usage:  A,Y, RT
  output: RT <<EVLSTK<<
- [[file:vm-mm-cell-array.rkt::604][POP_EVLSTK_TO_ARR_ATa_RA]] ::  pop tos into array element a (0 indexed), array pointed to by RA
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" WRITE_RT_TO_ARR_ATa_RA))
  - assembler include :: WRITE_RT_TO_ARR_ATa_RA
  pop tos into array element a (0 indexed), array pointed to by RA
  it will dec-refcnt on previous array entry, if it is a pointer that is overwritten
  input:  A = index (0 indexed)
          RA = pointer to array
          RT = cell to store
          EVLSTK
  usage:  A, X, Y, RT, RA, RZ
  output: (RA),A <- RT, RT<<EVLSTK
  funcs:
    DEC_REFCNT_RZ
    WRITE_RT_ARR_ATa_RA
    POP_CELL_EVLSTK_TO_RT
  NO BOUNDS CHECK!
- [[file:vm-mm-cell-array.rkt::599][POP_EVLSTK_TO_ARR_ATa_RA__CHECK_BOUNDS]] ::  pop tos into array element a (0 indexed), array pointed to by RA
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" WRITE_RT_TO_ARR_ATa_RA))
  - assembler include :: WRITE_RT_TO_ARR_ATa_RA
  pop tos into array element a (0 indexed), array pointed to by RA
  same as POP_EVLSTK_TO_ARR_ATa_RA
  but with BOUNDS CHECK
- [[file:vm-mm-cell-array.rkt::812][PUSH_ARR_ATa_RA_TO_EVLSTK]] ::  push the cell at A of the array in RA onto the Stack (RT+EVLSTK)
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" PUSH_ARR_ATa_RA_TO_EVLSTK))
  - assembler include :: PUSH_ARR_ATa_RA_TO_EVLSTK
  push the cell at A of the array in RA onto the Stack (RT+EVLSTK)
  (RA),A -> RT+EVLSTK
  input:  A, RA, RT+EVLSTK
  usage:  A, X, Y
  output: RT+EVLSTK
  funcs:
    PUSH_RT_TO_EVLSTK_IF_NONEMPTY
- [[file:vm-mm-cell-stack.rkt::284][PUSH_BYTE_X_TO_EVLSTK]] ::  push cell byte X to evlstk (actually RT TO evlstk and cell byte X into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push cell byte X to evlstk (actually RT TO evlstk and cell byte X into RT)
- [[file:vm-mm-cell-stack.rkt::274][PUSH_INT_0_TO_EVLSTK]] ::  push cell int 0 to evlstk (actually RT TO evlstk and cell int 0 into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push cell int 0 to evlstk (actually RT TO evlstk and cell int 0 into RT)
- [[file:vm-mm-cell-stack.rkt::276][PUSH_INT_1_TO_EVLSTK]] ::  push cell int 1 to evlstk (actually RT TO evlstk and cell int 1 into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push cell int 1 to evlstk (actually RT TO evlstk and cell int 1 into RT)
- [[file:vm-mm-cell-stack.rkt::278][PUSH_INT_2_TO_EVLSTK]] ::  push cell int 2 to evlstk (actually RT TO evlstk and cell int 2 into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push cell int 2 to evlstk (actually RT TO evlstk and cell int 2 into RT)
- [[file:vm-mm-cell-stack.rkt::280][PUSH_INT_m1_TO_EVLSTK]] ::  push cell int -1 to evlstk (actually RT TO evlstk and cell int -1 into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push cell int -1 to evlstk (actually RT TO evlstk and cell int -1 into RT)
- [[file:vm-mm-cell-stack.rkt::286][PUSH_INT_TO_EVLSTK]] ::  ints are saved high byte first, then low byte !!!!
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  ints are saved high byte first, then low byte !!!!
  X = high byte of int (max 31 = $1f) (stored in low byte (tagged) position)
  A = low byte of int (0..255) (stored in high byte (untagged) position)
- [[file:vm-mm-cell-stack.rkt::272][PUSH_NIL_TO_EVLSTK]] ::  push nil to evlstk (actually RT TO evlstk and nil-cell into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push nil to evlstk (actually RT TO evlstk and nil-cell into RT)
- [[file:vm-mm-cell-stack.rkt::441][PUSH_RT_TO_EVLSTK]] ::  push rt onto the evlstack, no dec/inc refcnt is done!
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_RT_TO_EVLSTK))
  - assembler include :: PUSH_RT_TO_EVLSTK
  push rt onto the evlstack, no dec/inc refcnt is done!
  allocate new evlstk page if necessary
  input:  RT+EVLSTK
  usage:  A, X, Y
  output: RT +(EVLSTK << RT)
  funcs:
    ALLOC_PAGE_TO_X
    INIT_CELLSTACK_PAGE_X
  CHECK STACK PAGE OVERFLOW
- [[file:vm-mm-cell-stack.rkt::291][PUSH_XA_TO_EVLSTK]] ::  push an atomic cell onto the stack (that is push the RegT, if filled, and write the value into RegT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push an atomic cell onto the stack (that is push the RegT, if filled, and write the value into RegT)
  input: call-frame stack, RT
         A = high byte,
         X = tagged low
  output: call-frame stack, RT
- [[file:vm-mm-m1-slots.rkt::363][PUT_PAGE_AS_HEAD_OF_M1_PAGE_RZ]] ::  put this page to the head of free m1 pages of the same profile as RZ is
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" PUT_PAGE_AS_HEAD_OF_M1_PAGE_RZ))
  - assembler include :: PUT_PAGE_AS_HEAD_OF_M1_PAGE_RZ
  put this page to the head of free m1 pages of the same profile as RZ is
  input:  RZ, GLOBAL_M1_PX_PAGE_FOR_ALLOC
  usage:  A, X, Y, RZ
  output: GLOBAL_M1_PX_PAGE_FOR_ALLOC
          A = first free slot of that page
  funcs:  -
- [[file:vm-mm-register-functions.rkt::279][SWAP_ZP_WORD]] ::  swap 16 bits of two zero page locations
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" SWAP_ZP_WORD))
  - assembler include :: SWAP_ZP_WORD
  swap 16 bits of two zero page locations
  e.g. swapping RA with RB: A = !ZP_RA, X = !ZP_RB
  input:  A = zero-page address 1
          X = zero page address 2
  usage:  A, X, Y, TEMP..TEMP4
  output: swapped zero page 16 bit values
- [[file:vm-call-frame.rkt::170][VM_ALLOC_CALL_FRAME_N]] ::  allocate a new call frame,
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_ALLOC_CALL_FRAME_N))
  - assembler include :: VM_ALLOC_CALL_FRAME_N
  allocate a new call frame,
  close the current call frame (set top mark)
  and initialize the page accordingly
  input:  ZP_CALL_FRAME
          ZP_CALL_FRAME_TOP_MARK
  output: ZP_CALL_FRAME
          ZP_CALL_FRAME_TOP_MARK
          Y index for first byte available as payload (03) = ZP_CALL_FRAME_TOP_MARK
- [[file:vm-call-frame.rkt::756][VM_ALLOC_LOCALS]] ::  allocate A locals onto the locals stack
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_ALLOC_LOCALS))
  - assembler include :: VM_ALLOC_LOCALS
  allocate A locals onto the locals stack
  input:  A number of locals needed by this function
          zp_locals_lb_ptr
          zp_locals_hb_ptr
          zp_locals_top_mark
  output: A  new topmark
          zp_locals_lb_ptr
          zp_locals_hb_ptr
          zp_locals_top_mark
  uses:   A, X, Y
- [[file:vm-lists.rkt::116][VM_CAR]] ::  replace cell-pair on tos with CAR element
  - racket require :: (require (only-in "vm-lists.rkt" VM_CAR))
  - assembler include :: VM_CAR
  replace cell-pair on tos with CAR element
- [[file:vm-lists.rkt::140][VM_CDR]] ::  replace cell-pair on tos with CDR element
  - racket require :: (require (only-in "vm-lists.rkt" VM_CDR))
  - assembler include :: VM_CDR
  replace cell-pair on tos with CDR element
- [[file:vm-lists.rkt::202][VM_CONS__REFCNTD]] ::  cons value to cell-pair on the stack
  - racket require :: (require (only-in "vm-lists.rkt" VM_CONS__REFCNTD))
  - assembler include :: VM_CONS__REFCNTD
  cons value to cell-pair on the stack
  input: stack = value :: cell-pair
  output: stack = new cell-pair
          new cell-pair = [value:old cell-pair]
- [[file:vm-lists.rkt::169][VM_CxxR]] ::  execute caar, cadr, cdar or cddr depending on value in A
  - racket require :: (require (only-in "vm-lists.rkt" VM_CxxR))
  - assembler include :: VM_CxxR
  execute caar, cadr, cdar or cddr depending on value in A
  A = 00 -> caar
  A = 02 -> cadr
  A = 04 -> cdar
  A = 06 -> cddr
  input:  A, evlstk
  usage:  A X Y
  output: cell-pair on the stack replaced with its cxxr
- [[file:vm-mm-m1-slots.rkt::778][VM_ENQUEUE_PAGE_AS_HEAD_FOR_RA_SLOTS]] ::  put this page as head of the page free list for slots of type as in ZP_RA
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" VM_ENQUEUE_PAGE_AS_HEAD_FOR_RA_SLOTS))
  - assembler include :: VM_ENQUEUE_PAGE_AS_HEAD_FOR_RA_SLOTS
  put this page as head of the page free list for slots of type as in ZP_RA
  input:  RA
  usage:  A, X, Y, RA, TEMP
  output: GLOBAL_M1_PX_PAGE_FOR_ALLOC
  funcs: -
- [[file:vm-call-frame.rkt::809][VM_FREE_LOCALS]] ::  input:  A number of locals to keep after free (locals of current function?)
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_FREE_LOCALS))
  - assembler include :: VM_FREE_LOCALS
  input:  A number of locals to keep after free (locals of current function?)
          zp_locals_lb_ptr
          zp_locals_hb_ptr
          zp_locals_top_mark
  output: A  new topmark
          zp_locals_lb_ptr
          zp_locals_hb_ptr
          zp_locals_top_mark
  uses:   A, X, Y
- [[file:vm-call-frame.rkt::142][VM_INITIALIZE_CALL_FRAME]] ::  initialise first call frame
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_INITIALIZE_CALL_FRAME))
  - assembler include :: VM_INITIALIZE_CALL_FRAME
  initialise first call frame
  input:  -
  usage:  A X Y
  output: ZP_LOCALS_LB_PTR
          ZP_LOCALS_HB_PTR
          ZP_LOCALS_TOP_MARK
          ZP_CALL_FRAME
          ZP_CALL_FRAME_TOP_MARK
- [[file:vm-mm-pages.rkt::180][VM_INITIALIZE_MEMORY_MANAGER]] ::  initialize memory management (paging)
  - racket require :: (require (only-in "vm-mm-pages.rkt" VM_INITIALIZE_MEMORY_MANAGER))
  - assembler include :: VM_INITIALIZE_MEMORY_MANAGER
  initialize memory management (paging)
  - setup 'next free page' information, basically initializing the whole page with zeros
  - setup cell stack (to empty)

  destroys: A Y
- [[file:vm-interpreter.rkt::236][VM_INTERPRETER_INIT]] ::  initialize PC to $8000
  - racket require :: (require (only-in "vm-interpreter.rkt" VM_INTERPRETER_INIT))
  - assembler include :: VM_INTERPRETER_INIT
  initialize PC to $8000
- [[file:vm-lists.rkt::58][VM_NIL_P]] ::  is tos currently NIL?
  - racket require :: (require (only-in "vm-lists.rkt" VM_NIL_P))
  - assembler include :: VM_NIL_P
  is tos currently NIL?
- [[file:vm-call-frame.rkt::484][VM_POP_CALL_FRAME_N]] ::  pop the current call frame
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_POP_CALL_FRAME_N))
  - assembler include :: VM_POP_CALL_FRAME_N
  pop the current call frame
  input:  zp_call_frame_top_mark
          zp_call_frame
  output: zp_call_frame_top_mark
          zp_call_frame
          zp_vm_pc
          zp_func_ptr
          zp_locals_lb_ptr
          zp_locals_hb_ptr
          if slow frame is popped, additionally:
             zp_cell_stack_lb_ptr
             zp_cell_stack_hb_ptr
             zp_cell_stack_tos
  NOTE: pop call completely restores the invocation frame
        it does no GC check on locals!
- [[file:vm-call-frame.rkt::212][VM_PUSH_CALL_FRAME_N]] ::  push a call frame and allocate X locals
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_PUSH_CALL_FRAME_N))
  - assembler include :: VM_PUSH_CALL_FRAME_N
  push a call frame and allocate X locals
  input:  X = number of locals to allocate on locals frame
          zp_call_frame
          zp_call_frame_top_mark
          zp_locals_lb_ptr
          zp_cell_stack_tos
          zp_func_ptr
          zp_vm_pc
  output: zp_call_frame
          zp_call_frame_top_mark
          additionally:
             if call frame needs to be put on a new page:
                $02 on old page holds top mark of old call stack
  NOTE: for a complete call,
    1. push call frame (use this method)
    2. allocated # of locals needed, set zp_vm_locals_lb_ptr and zp_vm_locals_hb_ptr
    3. set zp_vm_pc to new function
- [[file:vm-interpreter.rkt::678][VM_REFCOUNT_DECR_ARRAY_REGS]] ::  decrement refcount to all array register (ra, rb, rc)
  - racket require :: (require (only-in "vm-interpreter.rkt" VM_REFCOUNT_DECR_ARRAY_REGS))
  - assembler include :: VM_REFCOUNT_DECR_ARRAY_REGS
  decrement refcount to all array register (ra, rb, rc)
  rb is only checked, if ra != 0,
  rc is only checked, if rb != 0,
- [[file:vm-interpreter.rkt::710][VM_REFCOUNT_DECR_CURRENT_LOCALS]] ::  decrement the refcount to all locals that are not initial (e.g. upon leaving a function)
  - racket require :: (require (only-in "vm-interpreter.rkt" VM_REFCOUNT_DECR_CURRENT_LOCALS))
  - assembler include :: VM_REFCOUNT_DECR_CURRENT_LOCALS
  decrement the refcount to all locals that are not initial (e.g. upon leaving a function)
- [[file:vm-mm-m1-slots.rkt::736][VM_REMOVE_FULL_PAGES_FOR_RA_SLOTS]] ::  remove full pages in the free list of pages of the same type as are currently in ZP_RA
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" VM_REMOVE_FULL_PAGES_FOR_RA_SLOTS))
  - assembler include :: VM_REMOVE_FULL_PAGES_FOR_RA_SLOTS
  remove full pages in the free list of pages of the same type as are currently in ZP_RA
  input: RA
  usage: A, X, Y, RA, GLOBAL_M1_PX_PAGE_FOR_ALLOC
  output: GLOBAL_M1_PX_PAGE_FOR_ALLOC
  funcs: -
- [[file:vm-mm-cell-stack.rkt::561][WRITE_00_TO_RA]] ::  write 00 00 into RA marking it as empty!
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_RA))
  - assembler include :: POP_CELL_EVLSTK_TO_RA
  write 00 00 into RA marking it as empty!
- [[file:vm-mm-cell-stack.rkt::604][WRITE_00_TO_RP]] ::  write 00 00 into RA marking it as empty!
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_RP))
  - assembler include :: POP_CELL_EVLSTK_TO_RP
  write 00 00 into RA marking it as empty!
- [[file:vm-mm-cell-stack.rkt::282][WRITE_BYTE_X_TO_RT]] ::  write cell byte X into RT (overwriting it)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  write cell byte X into RT (overwriting it)
- [[file:vm-mm-cell-pairs.rkt::762][WRITE_CELLPAIR_RP_CELLy_TO_RP]] ::  overwrite the given cell-pair ptr in RP with the value of the Y's cell pointed to by the cell-pair
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" WRITE_CELLPAIR_RP_CELL0_TO_RP))
  - assembler include :: WRITE_CELLPAIR_RP_CELL0_TO_RP
  overwrite the given cell-pair ptr in RP with the value of the Y's cell pointed to by the cell-pair
  no reference count is adjusted! this has to be taken care of by caller!
  input:  Y - 0 (cell0), 2 (cell1)
          RP (must be cell-pair ptr) -> [A][B]
  output: RP = A (Y=0) or B (Y=2)
- [[file:vm-mm-cell-pairs.rkt::707][WRITE_CELLPAIR_RT_CELLy_TO_RP]] ::  write into RP the value of the Y's cell pointed to by the cell-pair ptr RT
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" WRITE_CELLPAIR_RT_CELL1_TO_RP))
  - assembler include :: WRITE_CELLPAIR_RT_CELL1_TO_RP
  write into RP the value of the Y's cell pointed to by the cell-pair ptr RT
  no reference count is adjusted! this has to be taken care of by caller!
  input:  Y - 0 (cell0), 2 (cell1)
          RT (must be cell-pair ptr) -> [A][B]
  output: RP = A (Y=0) or B (Y=2)
- [[file:vm-mm-cell-pairs.rkt::651][WRITE_CELLPAIR_RT_CELLy_TO_RT]] ::  overwrite the given cell-pair ptr in RT with the value of the Y's cell pointed to by the cell-pair
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" WRITE_CELLPAIR_RT_CELL1_TO_RT))
  - assembler include :: WRITE_CELLPAIR_RT_CELL1_TO_RT
  overwrite the given cell-pair ptr in RT with the value of the Y's cell pointed to by the cell-pair
  no reference count is adjusted! this has to be taken care of by caller!
  input:  Y - 0 (cell0), 2 (cell1)
          RT (must be cell-pair ptr) -> [A][B]
  output: RT = A (Y=0) or B (Y=2)
- [[file:vm-mm-register-functions.rkt::229][WRITE_INT_AY_TO_RT]] ::  write the given int in A/Y into RT, ignoring what was in RT (no dec-refcnt)
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" WRITE_INT_AY_TO_RT))
  - assembler include :: WRITE_INT_AY_TO_RT
  write the given int in A/Y into RT, ignoring what was in RT (no dec-refcnt)
  input:  A = lowbyte of int (0..255), written into high byte of cell register RT
          Y = highbyte (0.31), written into lowbyte and tagged lowbyte of cell register
          X = (0 = RT, 2 = RA)
  usage:  A, X, Y
  output: RT = cell-int
- [[file:vm-mm-native-array.rkt::285][WRITE_NATARR_RAI_TO_RT]] ::  write/push byte referenced by RA at index RAI
  - racket require :: (require (only-in "vm-mm-native-array.rkt" PUSH_NATARR_RAI))
  - assembler include :: PUSH_NATARR_RAI
  write/push byte referenced by RA at index RAI
  onto the eval stack and increment RAI
  input:  RT, RA, RAi, EVLSTK
  usage:  A, Y
  output: EVLSTK<<RT, RT := (RA),RAi++,
- [[file:vm-mm-register-functions.rkt::61][WRITE_NIL_TO_RT]] ::  write NIL into register, not checking its content (no dec-refcnt)
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" WRITE_NIL_TO_RT))
  - assembler include :: WRITE_NIL_TO_RT
  write NIL into register, not checking its content (no dec-refcnt)
  input:  -
  output: RT (RP) = NIL
- [[file:vm-mm-cell-array.rkt::619][WRITE_RT_TO_ARR_ATa_RA]] ::  write the tos into array element a (0 indexed), array pointed to by RA
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" WRITE_RT_TO_ARR_ATa_RA))
  - assembler include :: WRITE_RT_TO_ARR_ATa_RA
  write the tos into array element a (0 indexed), array pointed to by RA
  it will dec-refcnt on previous array entry, if it is a pointer that is overwritten
  it will NOT inc-refcnt on RT even though it is now in RT and the array, this has to be taken care of by the caller!
  input:  A = index (0 indexed)
          RA = pointer to array
          RT = cell to store
  usage:  A, X, Y, RT, RA, RZ
  output: (RA),A <- RT
  funcs:
    DEC_REFCNT_RZ
  NO CHECKING (NO BOUNDS, NO TYPE ...)
- [[file:vm-mm-cell-array.rkt::594][WRITE_RT_TO_ARR_ATa_RA__CHECK_BOUNDS]] ::  write the tos into array element a (0 indexed), array pointed to by RA
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" WRITE_RT_TO_ARR_ATa_RA))
  - assembler include :: WRITE_RT_TO_ARR_ATa_RA
  write the tos into array element a (0 indexed), array pointed to by RA
  same as WRITE_RT_TO_ARR_ATa_RA
  but with BOUNDS CHECK
- [[file:vm-mm-cell-pairs.rkt::1149][WRITE_RT_TO_CELLy_CELLPAIR_RP]] ::  write the cell in RT into the CELL Y (0|2) of the cell-pair referenced in RP
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" WRITE_RT_TO_CELL0_CELLPAIR_RP))
  - assembler include :: WRITE_RT_TO_CELL0_CELLPAIR_RP
  write the cell in RT into the CELL Y (0|2) of the cell-pair referenced in RP
  input:  Y, RT, RP
  usage:  A, Y
  output: RP@Y <- RT    Y=0: RP -> [RT][...],  Y=2: RP -> [...][RT]
  funcs:  -
- [[file:vm-mm-native-array.rkt::189][WRITE_RT_TO_NATARR_RAI]] ::  write byte value of rt (high byte) into nat array
  - racket require :: (require (only-in "vm-mm-native-array.rkt" WRITE_RT_TO_NATARR_RAI))
  - assembler include :: WRITE_RT_TO_NATARR_RAI
  write byte value of rt (high byte) into nat array
  referenced by RA at index RAI and increment RAI
  input:  RT, RA, RAi
  usage:  A, Y
  output: (RA),RAi++ := (RT+1)
* functions (by group)
** native_array
- [[file:vm-mm-native-array.rkt::107][ALLOC_NATARR_TO_RA]] ::  allocate an array of bytes (native) (also useful for strings)
  - racket require :: (require (only-in "vm-mm-native-array.rkt" ALLOC_NATARR_TO_RA))
  - assembler include :: ALLOC_NATARR_TO_RA
  allocate an array of bytes (native) (also useful for strings)
  overwrite RA no matter whether RA was filled
  input:  A = number of bytes (1..81)
  usage:  A, X, Y, RA
  output: RA -> points to an allocated array (not initialized)
          RAI = 0
  funcs:
    ALLOC_M1_SLOT_TO_RA
- [[file:vm-mm-native-array.rkt::334][CP_NATARR_RA_TO_RB]] ::  copy the whole lenght of the array ra into the array rb (same position)
  - racket require :: (require (only-in "vm-mm-native-array.rkt" CP_NATARR_RA_TO_RB))
  - assembler include :: CP_NATARR_RA_TO_RB
  copy the whole lenght of the array ra into the array rb (same position)
  input:  RA, RB
  usage:  A, Y
  output: start of RB is equal to RA (length of RB needs to >= RA)
- [[file:vm-mm-native-array.rkt::400][CP_NATARR_RANGE_RA_TO_RB]] ::  copy from nat array ra, range index x..y to the start of array rb
  - racket require :: (require (only-in "vm-mm-native-array.rkt" CP_NATARR_RANGE_RA_TO_RB))
  - assembler include :: CP_NATARR_RANGE_RA_TO_RB
  copy from nat array ra, range index x..y to the start of array rb
  input:  RA, RB, X, Y
  usage:  A, X, Y
  output: start of RB is equal to RA@X..Y (0-indexed), RB needs to have sufficient size (>=Y-X)
- [[file:vm-mm-native-array.rkt::285][WRITE_NATARR_RAI_TO_RT]] ::  write/push byte referenced by RA at index RAI
  - racket require :: (require (only-in "vm-mm-native-array.rkt" PUSH_NATARR_RAI))
  - assembler include :: PUSH_NATARR_RAI
  write/push byte referenced by RA at index RAI
  onto the eval stack and increment RAI
  input:  RT, RA, RAi, EVLSTK
  usage:  A, Y
  output: EVLSTK<<RT, RT := (RA),RAi++,
- [[file:vm-mm-native-array.rkt::189][WRITE_RT_TO_NATARR_RAI]] ::  write byte value of rt (high byte) into nat array
  - racket require :: (require (only-in "vm-mm-native-array.rkt" WRITE_RT_TO_NATARR_RAI))
  - assembler include :: WRITE_RT_TO_NATARR_RAI
  write byte value of rt (high byte) into nat array
  referenced by RA at index RAI and increment RAI
  input:  RT, RA, RAi
  usage:  A, Y
  output: (RA),RAi++ := (RT+1)
** cell_pair
- [[file:vm-mm-cell-pairs.rkt::1149][WRITE_RT_TO_CELLy_CELLPAIR_RP]] ::  write the cell in RT into the CELL Y (0|2) of the cell-pair referenced in RP
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" WRITE_RT_TO_CELL0_CELLPAIR_RP))
  - assembler include :: WRITE_RT_TO_CELL0_CELLPAIR_RP
  write the cell in RT into the CELL Y (0|2) of the cell-pair referenced in RP
  input:  Y, RT, RP
  usage:  A, Y
  output: RP@Y <- RT    Y=0: RP -> [RT][...],  Y=2: RP -> [...][RT]
  funcs:  -
- [[file:vm-mm-cell-pairs.rkt::762][WRITE_CELLPAIR_RP_CELLy_TO_RP]] ::  overwrite the given cell-pair ptr in RP with the value of the Y's cell pointed to by the cell-pair
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" WRITE_CELLPAIR_RP_CELL0_TO_RP))
  - assembler include :: WRITE_CELLPAIR_RP_CELL0_TO_RP
  overwrite the given cell-pair ptr in RP with the value of the Y's cell pointed to by the cell-pair
  no reference count is adjusted! this has to be taken care of by caller!
  input:  Y - 0 (cell0), 2 (cell1)
          RP (must be cell-pair ptr) -> [A][B]
  output: RP = A (Y=0) or B (Y=2)
- [[file:vm-mm-cell-pairs.rkt::707][WRITE_CELLPAIR_RT_CELLy_TO_RP]] ::  write into RP the value of the Y's cell pointed to by the cell-pair ptr RT
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" WRITE_CELLPAIR_RT_CELL1_TO_RP))
  - assembler include :: WRITE_CELLPAIR_RT_CELL1_TO_RP
  write into RP the value of the Y's cell pointed to by the cell-pair ptr RT
  no reference count is adjusted! this has to be taken care of by caller!
  input:  Y - 0 (cell0), 2 (cell1)
          RT (must be cell-pair ptr) -> [A][B]
  output: RP = A (Y=0) or B (Y=2)
- [[file:vm-mm-cell-pairs.rkt::651][WRITE_CELLPAIR_RT_CELLy_TO_RT]] ::  overwrite the given cell-pair ptr in RT with the value of the Y's cell pointed to by the cell-pair
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" WRITE_CELLPAIR_RT_CELL1_TO_RT))
  - assembler include :: WRITE_CELLPAIR_RT_CELL1_TO_RT
  overwrite the given cell-pair ptr in RT with the value of the Y's cell pointed to by the cell-pair
  no reference count is adjusted! this has to be taken care of by caller!
  input:  Y - 0 (cell0), 2 (cell1)
          RT (must be cell-pair ptr) -> [A][B]
  output: RT = A (Y=0) or B (Y=2)
- [[file:vm-mm-cell-pairs.rkt::588][GET_FRESH_CELLPAIR_TO_AX]] ::  get the page and unused cellpair for allocation
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" GET_FRESH_CELLPAIR_TO_AX))
  - assembler include :: GET_FRESH_CELLPAIR_TO_AX
  get the page and unused cellpair for allocation

  get the complete ptr, do not allocate this cellpair yet
  allocate a new page if necessary
  do not use any cellpair free list
  input:  VM_FREE_CELL__PAIR_PAGE
          VM_PAGE_SLOT_DATA+PAGE
  output: A = lowbyte
          X = highbyte (page)
          Y = ?
- [[file:vm-mm-cell-pairs.rkt::295][ALLOC_CELLPAIR_TO_RT]] ::  try to reuse root of free tree: use root but make sure to deallocate cell1 of the root (since this might still point to some data)
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" ALLOC_CELLPAIR_TO_RT))
  - assembler include :: ALLOC_CELLPAIR_TO_RT
  try to reuse root of free tree: use root but make sure to deallocate cell1 of the root (since this might still point to some data)
  if no free tree available, find page with free cells (GLOBAL_CELLPAIR_PAGE_FOR_ALLOC)
  if no free cell page is available, allocate a new page and used the first free slot there
  NOTE: the cell-pair is not initialized (cell0 and/or cell1 may contain old data that needs to be overwritten!)
  input:  GLOBAL_CELLPAIR_FREE_LIST
  usage:  A, X, Y
  output: RT
  funcs:
    GET_FRESH_CELLPAIR_TO_AX
    ALLOC_CELLPAIR_AX_TO_RT
    WRITE_CELLPAIR_RT_CELL1_TO_RT
    DEC_REFCNT_RT
- [[file:vm-mm-cell-pairs.rkt::252][ALLOC_CELLPAIR_AX_TO_RT]] ::  allocate a cell-pair from this page (if page has no free cell-pairs, a new page is allocated and is used to get a free cell-pair!)
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" ALLOC_CELLPAIR_AX_TO_RT))
  - assembler include :: ALLOC_CELLPAIR_AX_TO_RT
  allocate a cell-pair from this page (if page has no free cell-pairs, a new page is allocated and is used to get a free cell-pair!)
  this will not check the free cell-pair tree!
  input:  X : page to allocate cell-pair on (a new page is allocated, if this page does not have any free cell-pairs)
          A : slot to allocated (must be the first free slot of this page)
  output: ZP_RT
  WARNING: ZP_RT IS OVERWRITTEN !! NO PUSH INTO THE CELL-STACK IS DONE!
- [[file:vm-mm-cell-pairs.rkt::112][INIT_CELLPAIR_PAGE_X_TO_AX]] ::  cell-pair page layout  (new layout with cell-pair-ptr having bit0 always set and bit1 always unset!)
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" INIT_CELLPAIR_PAGE_X_TO_AX))
  - assembler include :: INIT_CELLPAIR_PAGE_X_TO_AX
  cell-pair page layout  (new layout with cell-pair-ptr having bit0 always set and bit1 always unset!)
  offset  content
  00      #b01xx xxxx page type + number of used slots
  01      ref-count cell-pair at 05 (cell-pair 0)
  02      ref-count cell-pair at 09 (cell-pair 1)
  03..04   unused (2)
  05..08   cell-pair 0     (#b0000 01[01] >> 2 = #b0000 0001)
  09..0c   cell-pair 1     (#b0000 10[01] >> 2 = #b0000 0010)
  0d..0f   unused (3)
  10      ref-count for cell-pair at 40 (cell-pair 2)
  11      ref-count for cell-pair at 44 (cell-pair 3)
  ..3e     ref-count for cell-pair at f9 (cell-pair 48)
  3f..40   unused (2)
  41..44   cell-pair 2     (#b0100 00[01] >> 2 = #b0001 0000)
  45..48   cell-pair 3     (#b0100 01[01] >> 2 = #b0001 0001)
  ...
  f9..fc   cell-pair 48    (#b1111 10[01] >> 2 = #b0011 1110)
  fd..fe   unused (2)
  ff      previous page of this type

  VM_PAGE_SLOT_DATA + pageidx: holds the index within the page of the first free cell-pair on that page (0 = no free cell-pair on this page)
  the free cell-pair holds in byte 0 of the cell-pair the offset of the next free cell-pair (0 = no other free cell-pair)

  allocate a complete new page and initialize it to hold reference counted cell-pairs
  connect all cell-pairs in a free-list
  also set the first free slot of this allocated page (in VM_PAGE_SLOT_DATA + pageidx)

  input:  X = page allocated but uninitialized
  output: X = page allocated and initialized for cell-pairs usage
          A = first free slot ($05)
  usage:  X, Y, ZP_TEMP, ZP_TEMP2
** m1_slot
- [[file:vm-mm-m1-slots.rkt::778][VM_ENQUEUE_PAGE_AS_HEAD_FOR_RA_SLOTS]] ::  put this page as head of the page free list for slots of type as in ZP_RA
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" VM_ENQUEUE_PAGE_AS_HEAD_FOR_RA_SLOTS))
  - assembler include :: VM_ENQUEUE_PAGE_AS_HEAD_FOR_RA_SLOTS
  put this page as head of the page free list for slots of type as in ZP_RA
  input:  RA
  usage:  A, X, Y, RA, TEMP
  output: GLOBAL_M1_PX_PAGE_FOR_ALLOC
  funcs: -
- [[file:vm-mm-m1-slots.rkt::736][VM_REMOVE_FULL_PAGES_FOR_RA_SLOTS]] ::  remove full pages in the free list of pages of the same type as are currently in ZP_RA
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" VM_REMOVE_FULL_PAGES_FOR_RA_SLOTS))
  - assembler include :: VM_REMOVE_FULL_PAGES_FOR_RA_SLOTS
  remove full pages in the free list of pages of the same type as are currently in ZP_RA
  input: RA
  usage: A, X, Y, RA, GLOBAL_M1_PX_PAGE_FOR_ALLOC
  output: GLOBAL_M1_PX_PAGE_FOR_ALLOC
  funcs: -
- [[file:vm-mm-m1-slots.rkt::494][ALLOC_M1_SLOT_TO_RA]] ::  allocate a slot of min A size, allocating a new page if necessary
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" ALLOC_M1_SLOT_TO_RA))
  - assembler include :: ALLOC_M1_SLOT_TO_RA
  allocate a slot of min A size, allocating a new page if necessary
  input:  A = size
  usage:  A, X, Y, RA, GLOBAL_M1_PX_PAGE_FOR_ALLOC
  output: RA = available slot of the given size (or a bit more)
          Y = actual size
          GLOBAL_M1_PX_PAGE_FOR_ALLOC
  funcs:
    VM_REMOVE_FULL_PAGE_FOR_TYPE_X_SLOTS
    ALLOC_PAGE_TO_X
    INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX
- [[file:vm-mm-m1-slots.rkt::452][ALLOC_M1_SLOT_TO_RB]] ::  allocate a slot of min A size, allocating a new page if necessary
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" ALLOC_M1_SLOT_TO_RB))
  - assembler include :: ALLOC_M1_SLOT_TO_RB
  allocate a slot of min A size, allocating a new page if necessary
  input:  A = size
  usage:  A, X, Y, RB, GLOBAL_M1_PX_PAGE_FOR_ALLOC
  output: RB = available slot of the given size (or a bit more)
          Y = actual size
          GLOBAL_M1_PX_PAGE_FOR_ALLOC
  funcs:
    VM_REMOVE_FULL_PAGE_FOR_TYPE_X_SLOTS
    ALLOC_PAGE_TO_X
    INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX
    ALLOC_M1_SLOT_TO_RA,
    SWAP_RA_RB
- [[file:vm-mm-m1-slots.rkt::409][DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_A]] ::  drop all full pages from the list of pages with available slots
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_A))
  - assembler include :: DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_A
  drop all full pages from the list of pages with available slots
  input:  RZ, GLOBAL_M1_PX_PAGE_FOR_ALLOC
  usage:  A, X, Y
  output: GLOBAL_M1_PX_PAGE_FOR_ALLOC of this profile holds page with free slots
  funcs:  -
- [[file:vm-mm-m1-slots.rkt::363][PUT_PAGE_AS_HEAD_OF_M1_PAGE_RZ]] ::  put this page to the head of free m1 pages of the same profile as RZ is
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" PUT_PAGE_AS_HEAD_OF_M1_PAGE_RZ))
  - assembler include :: PUT_PAGE_AS_HEAD_OF_M1_PAGE_RZ
  put this page to the head of free m1 pages of the same profile as RZ is
  input:  RZ, GLOBAL_M1_PX_PAGE_FOR_ALLOC
  usage:  A, X, Y, RZ
  output: GLOBAL_M1_PX_PAGE_FOR_ALLOC
          A = first free slot of that page
  funcs:  -
- [[file:vm-mm-m1-slots.rkt::321][ADD_M1_SLOT_RZ_TO_PFL]] ::  add the given m1 slot in RZ back to the page free list of slots
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" ADD_M1_SLOT_RZ_TO_PFL))
  - assembler include :: ADD_M1_SLOT_RZ_TO_PFL
  add the given m1 slot in RZ back to the page free list of slots
  input:  RZ, page-meta-data
  usage:  A, X, Y, RZ
  output: page-meta-data
  funcs:
    DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_RZ
    PUT_PAGE_AS_HEAD_OF_M1_PAGE_RZ
- [[file:vm-mm-m1-slots.rkt::88][INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX]] ::  page type slot w/ different sizes (refcount @ ptr-1) x cells
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX))
  - assembler include :: INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX
  page type slot w/ different sizes (refcount @ ptr-1) x cells
  math: first entry @FIRST_REF_COUNT_OFFSET__INIT_M1Px_PAGE_A + 1, refcount @ -1, next slot += INC_TO_NEXT_SLOT__INIT_M1Px_PAGE_A, slot-size = INC_TO_NEXT_SLOT__INIT_M1Px_PAGE_A -1
  input : Y = profile offset (0, 2, 4 ...)
          X = page
  uses  : A, X, Y, RZ
  output: X = page, initialized as m1 page of profile y
          A = first free slot
  funcs:  -
** list
- [[file:vm-lists.rkt::202][VM_CONS__REFCNTD]] ::  cons value to cell-pair on the stack
  - racket require :: (require (only-in "vm-lists.rkt" VM_CONS__REFCNTD))
  - assembler include :: VM_CONS__REFCNTD
  cons value to cell-pair on the stack
  input: stack = value :: cell-pair
  output: stack = new cell-pair
          new cell-pair = [value:old cell-pair]
- [[file:vm-lists.rkt::169][VM_CxxR]] ::  execute caar, cadr, cdar or cddr depending on value in A
  - racket require :: (require (only-in "vm-lists.rkt" VM_CxxR))
  - assembler include :: VM_CxxR
  execute caar, cadr, cdar or cddr depending on value in A
  A = 00 -> caar
  A = 02 -> cadr
  A = 04 -> cdar
  A = 06 -> cddr
  input:  A, evlstk
  usage:  A X Y
  output: cell-pair on the stack replaced with its cxxr
- [[file:vm-lists.rkt::140][VM_CDR]] ::  replace cell-pair on tos with CDR element
  - racket require :: (require (only-in "vm-lists.rkt" VM_CDR))
  - assembler include :: VM_CDR
  replace cell-pair on tos with CDR element
- [[file:vm-lists.rkt::116][VM_CAR]] ::  replace cell-pair on tos with CAR element
  - racket require :: (require (only-in "vm-lists.rkt" VM_CAR))
  - assembler include :: VM_CAR
  replace cell-pair on tos with CAR element
** predicates
- [[file:vm-lists.rkt::58][VM_NIL_P]] ::  is tos currently NIL?
  - racket require :: (require (only-in "vm-lists.rkt" VM_NIL_P))
  - assembler include :: VM_NIL_P
  is tos currently NIL?
** register
- [[file:vm-mm-register-functions.rkt::279][SWAP_ZP_WORD]] ::  swap 16 bits of two zero page locations
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" SWAP_ZP_WORD))
  - assembler include :: SWAP_ZP_WORD
  swap 16 bits of two zero page locations
  e.g. swapping RA with RB: A = !ZP_RA, X = !ZP_RB
  input:  A = zero-page address 1
          X = zero page address 2
  usage:  A, X, Y, TEMP..TEMP4
  output: swapped zero page 16 bit values
- [[file:vm-mm-register-functions.rkt::229][WRITE_INT_AY_TO_RT]] ::  write the given int in A/Y into RT, ignoring what was in RT (no dec-refcnt)
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" WRITE_INT_AY_TO_RT))
  - assembler include :: WRITE_INT_AY_TO_RT
  write the given int in A/Y into RT, ignoring what was in RT (no dec-refcnt)
  input:  A = lowbyte of int (0..255), written into high byte of cell register RT
          Y = highbyte (0.31), written into lowbyte and tagged lowbyte of cell register
          X = (0 = RT, 2 = RA)
  usage:  A, X, Y
  output: RT = cell-int
- [[file:vm-mm-register-functions.rkt::203][CP_RT_TO_RB]] ::  copy RT -> RB
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RT_TO_RB))
  - assembler include :: CP_RT_TO_RB
  copy RT -> RB
  input:  RT
  output: RB (copy of RT)
- [[file:vm-mm-register-functions.rkt::190][CP_RT_TO_RA]] ::  copy RT -> RA
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RT_TO_RA))
  - assembler include :: CP_RT_TO_RA
  copy RT -> RA
  input:  RT
  output: RA (copy of RT)
- [[file:vm-mm-register-functions.rkt::177][CP_RT_TO_RP]] ::  copy RT -> RP
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RT_TO_RP))
  - assembler include :: CP_RT_TO_RP
  copy RT -> RP
  input:  RT
  output: RP (copy of RT)
- [[file:vm-mm-register-functions.rkt::164][CP_RZ_TO_RT]] ::  copy RZ -> RT
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RZ_TO_RT))
  - assembler include :: CP_RZ_TO_RT
  copy RZ -> RT
  input:  RZ
  output: RT (copy of RZ)
- [[file:vm-mm-register-functions.rkt::151][CP_RT_TO_RZ]] ::  copy RT -> RZ
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RT_TO_RZ))
  - assembler include :: CP_RT_TO_RZ
  copy RT -> RZ
  input:  RT
  output: RZ (copy of RT)
- [[file:vm-mm-register-functions.rkt::138][CP_RC_TO_RZ]] ::  copy RC -> RZ
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RC_TO_RZ))
  - assembler include :: CP_RC_TO_RZ
  copy RC -> RZ
  input:  RC
  output: RZ (copy of RA)
- [[file:vm-mm-register-functions.rkt::125][CP_RB_TO_RZ]] ::  copy RB -> RZ
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RB_TO_RZ))
  - assembler include :: CP_RB_TO_RZ
  copy RB -> RZ
  input:  RB
  output: RZ (copy of RA)
- [[file:vm-mm-register-functions.rkt::112][CP_RA_TO_RZ]] ::  copy RA -> RZ
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RA_TO_RZ))
  - assembler include :: CP_RA_TO_RZ
  copy RA -> RZ
  input:  RA
  output: RZ (copy of RA)
- [[file:vm-mm-register-functions.rkt::98][CP_RA_TO_RT]] ::  copy RA -> RT
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" CP_RA_TO_RT))
  - assembler include :: CP_RA_TO_RT
  copy RA -> RT
  input:  RA
  output: RT (copy of RA)
- [[file:vm-mm-register-functions.rkt::61][WRITE_NIL_TO_RT]] ::  write NIL into register, not checking its content (no dec-refcnt)
  - racket require :: (require (only-in "vm-mm-register-functions.rkt" WRITE_NIL_TO_RT))
  - assembler include :: WRITE_NIL_TO_RT
  write NIL into register, not checking its content (no dec-refcnt)
  input:  -
  output: RT (RP) = NIL
** call_frame
- [[file:vm-call-frame.rkt::756][VM_ALLOC_LOCALS]] ::  allocate A locals onto the locals stack
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_ALLOC_LOCALS))
  - assembler include :: VM_ALLOC_LOCALS
  allocate A locals onto the locals stack
  input:  A number of locals needed by this function
          zp_locals_lb_ptr
          zp_locals_hb_ptr
          zp_locals_top_mark
  output: A  new topmark
          zp_locals_lb_ptr
          zp_locals_hb_ptr
          zp_locals_top_mark
  uses:   A, X, Y
- [[file:vm-call-frame.rkt::484][VM_POP_CALL_FRAME_N]] ::  pop the current call frame
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_POP_CALL_FRAME_N))
  - assembler include :: VM_POP_CALL_FRAME_N
  pop the current call frame
  input:  zp_call_frame_top_mark
          zp_call_frame
  output: zp_call_frame_top_mark
          zp_call_frame
          zp_vm_pc
          zp_func_ptr
          zp_locals_lb_ptr
          zp_locals_hb_ptr
          if slow frame is popped, additionally:
             zp_cell_stack_lb_ptr
             zp_cell_stack_hb_ptr
             zp_cell_stack_tos
  NOTE: pop call completely restores the invocation frame
        it does no GC check on locals!
- [[file:vm-call-frame.rkt::212][VM_PUSH_CALL_FRAME_N]] ::  push a call frame and allocate X locals
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_PUSH_CALL_FRAME_N))
  - assembler include :: VM_PUSH_CALL_FRAME_N
  push a call frame and allocate X locals
  input:  X = number of locals to allocate on locals frame
          zp_call_frame
          zp_call_frame_top_mark
          zp_locals_lb_ptr
          zp_cell_stack_tos
          zp_func_ptr
          zp_vm_pc
  output: zp_call_frame
          zp_call_frame_top_mark
          additionally:
             if call frame needs to be put on a new page:
                $02 on old page holds top mark of old call stack
  NOTE: for a complete call,
            1. push call frame (use this method)
            2. allocated # of locals needed, set zp_vm_locals_lb_ptr and zp_vm_locals_hb_ptr
            3. set zp_vm_pc to new function
- [[file:vm-call-frame.rkt::170][VM_ALLOC_CALL_FRAME_N]] ::  allocate a new call frame,
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_ALLOC_CALL_FRAME_N))
  - assembler include :: VM_ALLOC_CALL_FRAME_N
  allocate a new call frame,
  close the current call frame (set top mark)
  and initialize the page accordingly
  input:  ZP_CALL_FRAME
          ZP_CALL_FRAME_TOP_MARK
  output: ZP_CALL_FRAME
          ZP_CALL_FRAME_TOP_MARK
          Y index for first byte available as payload (03) = ZP_CALL_FRAME_TOP_MARK
- [[file:vm-call-frame.rkt::142][VM_INITIALIZE_CALL_FRAME]] ::  initialise first call frame
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_INITIALIZE_CALL_FRAME))
  - assembler include :: VM_INITIALIZE_CALL_FRAME
  initialise first call frame
  input:  -
  usage:  A X Y
  output: ZP_LOCALS_LB_PTR
          ZP_LOCALS_HB_PTR
          ZP_LOCALS_TOP_MARK
          ZP_CALL_FRAME
          ZP_CALL_FRAME_TOP_MARK
- [[file:vm-call-frame.rkt::116][ALLOC_LOCALS_STACK]] ::  allocate two pages for a cell-stack, store previous ZP_LOCALS_xB ptrs into these
  - racket require :: (require (only-in "vm-call-frame.rkt" ALLOC_LOCALS_STACK))
  - assembler include :: ALLOC_LOCALS_STACK
  allocate two pages for a cell-stack, store previous ZP_LOCALS_xB ptrs into these
  and initialise the new cell-stack
  input:  ZP_LOCALS_LB_PTR  ptr to old locals cell-stack
          ZP_LOCALS_HB_PTR
  usage:  A X Y
  output: ZP_LOCALS_LB_PTR  ptr to new locals cell-stack
          ZP_LOCALS_HB_PTR
** cell_array
- [[file:vm-mm-cell-array.rkt::812][PUSH_ARR_ATa_RA_TO_EVLSTK]] ::  push the cell at A of the array in RA onto the Stack (RT+EVLSTK)
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" PUSH_ARR_ATa_RA_TO_EVLSTK))
  - assembler include :: PUSH_ARR_ATa_RA_TO_EVLSTK
  push the cell at A of the array in RA onto the Stack (RT+EVLSTK)
  (RA),A -> RT+EVLSTK
  input:  A, RA, RT+EVLSTK
  usage:  A, X, Y
  output: RT+EVLSTK
  funcs:
    PUSH_RT_TO_EVLSTK_IF_NONEMPTY
- [[file:vm-mm-cell-array.rkt::619][WRITE_RT_TO_ARR_ATa_RA]] ::  write the tos into array element a (0 indexed), array pointed to by RA
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" WRITE_RT_TO_ARR_ATa_RA))
  - assembler include :: WRITE_RT_TO_ARR_ATa_RA
  write the tos into array element a (0 indexed), array pointed to by RA
  it will dec-refcnt on previous array entry, if it is a pointer that is overwritten
  it will NOT inc-refcnt on RT even though it is now in RT and the array, this has to be taken care of by the caller!
  input:  A = index (0 indexed)
          RA = pointer to array
          RT = cell to store
  usage:  A, X, Y, RT, RA, RZ
  output: (RA),A <- RT
  funcs:
    DEC_REFCNT_RZ
  NO CHECKING (NO BOUNDS, NO TYPE ...)
- [[file:vm-mm-cell-array.rkt::604][POP_EVLSTK_TO_ARR_ATa_RA]] ::  pop tos into array element a (0 indexed), array pointed to by RA
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" WRITE_RT_TO_ARR_ATa_RA))
  - assembler include :: WRITE_RT_TO_ARR_ATa_RA
  pop tos into array element a (0 indexed), array pointed to by RA
  it will dec-refcnt on previous array entry, if it is a pointer that is overwritten
  input:  A = index (0 indexed)
          RA = pointer to array
          RT = cell to store
          EVLSTK
  usage:  A, X, Y, RT, RA, RZ
  output: (RA),A <- RT, RT<<EVLSTK
  funcs:
    DEC_REFCNT_RZ
    WRITE_RT_ARR_ATa_RA
    POP_CELL_EVLSTK_TO_RT
  NO BOUNDS CHECK!
- [[file:vm-mm-cell-array.rkt::599][POP_EVLSTK_TO_ARR_ATa_RA__CHECK_BOUNDS]] ::  pop tos into array element a (0 indexed), array pointed to by RA
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" WRITE_RT_TO_ARR_ATa_RA))
  - assembler include :: WRITE_RT_TO_ARR_ATa_RA
  pop tos into array element a (0 indexed), array pointed to by RA
  same as POP_EVLSTK_TO_ARR_ATa_RA
  but with BOUNDS CHECK
- [[file:vm-mm-cell-array.rkt::594][WRITE_RT_TO_ARR_ATa_RA__CHECK_BOUNDS]] ::  write the tos into array element a (0 indexed), array pointed to by RA
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" WRITE_RT_TO_ARR_ATa_RA))
  - assembler include :: WRITE_RT_TO_ARR_ATa_RA
  write the tos into array element a (0 indexed), array pointed to by RA
  same as WRITE_RT_TO_ARR_ATa_RA
  but with BOUNDS CHECK
- [[file:vm-mm-cell-array.rkt::159][ALLOC_CELLARR_TO_RA]] ::  allocate an array of cells (also useful for structures)
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" ALLOC_CELLARR_TO_RA))
  - assembler include :: ALLOC_CELLARR_TO_RA
  allocate an array of cells (also useful for structures)
  this does overwrite RA without check RAs content!
  input:  A = number of cells (1..40)
  usage:  A, X, Y, RA
  output: RA -> points to an allocated array
  funcs:
    ALLOC_M1_SLOT_TO_RA
- [[file:vm-mm-cell-stack.rkt::604][WRITE_00_TO_RP]] ::  write 00 00 into RA marking it as empty!
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_RP))
  - assembler include :: POP_CELL_EVLSTK_TO_RP
  write 00 00 into RA marking it as empty!
- [[file:vm-mm-cell-stack.rkt::561][WRITE_00_TO_RA]] ::  write 00 00 into RA marking it as empty!
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_RA))
  - assembler include :: POP_CELL_EVLSTK_TO_RA
  write 00 00 into RA marking it as empty!
** cell_stack
- [[file:vm-mm-cell-stack.rkt::607][POP_CELL_EVLSTK_TO_RP]] ::  pop cell from stack (that is, discard RegT, move tos of call-frame stack into Reg A (if available))
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_RP))
  - assembler include :: POP_CELL_EVLSTK_TO_RP
  pop cell from stack (that is, discard RegT, move tos of call-frame stack into Reg A (if available))
  input: call-frame stack, RA
  output:  RP << EVLSTK, <<EVLSTK<<, RT unchanged!
  NO GC CHECKS!
- [[file:vm-mm-cell-stack.rkt::564][POP_CELL_EVLSTK_TO_RA]] ::  pop cell from stack (that is, discard RegT, move tos of call-frame stack into Reg A (if available))
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_RA))
  - assembler include :: POP_CELL_EVLSTK_TO_RA
  pop cell from stack (that is, discard RegT, move tos of call-frame stack into Reg A (if available))
  input: call-frame stack, RA
  output:  RA << EVLSTK, <<EVLSTK<<, RT unchanged!
  NO GC CHECKS!
- [[file:vm-mm-cell-stack.rkt::502][POP_CELL_EVLSTK_TO_CELLy_RT]] ::  write the TOS of the EVLSTK (not RT) into CELL Y of cell-pair referenced by RT
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_CELLy_RT))
  - assembler include :: POP_CELL_EVLSTK_TO_CELLy_RT
  write the TOS of the EVLSTK (not RT) into CELL Y of cell-pair referenced by RT
  keep RT and pop TOS of EVLSTK ( RT+EVLSTK  -> RT+<<EVLSTK<<, and (Y=0) RT -> [<<EVLSTK][...], or (Y=1) RT -> [...][<<EVLSTK]
  no inc/dec refcnt needs to take place, since # references to RT nor the popped TOS of EVLSTK do change
  input:  cell-stack (TOS)
          RT (must be a cell-pair ptr
          y = (0 = cell0, 2 = cell1)
  usage:  A, Y
  output: cell-stack (one value less)
          cell0 of RA is set
  funcs:  -
- [[file:vm-mm-cell-stack.rkt::441][PUSH_RT_TO_EVLSTK]] ::  push rt onto the evlstack, no dec/inc refcnt is done!
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_RT_TO_EVLSTK))
  - assembler include :: PUSH_RT_TO_EVLSTK
  push rt onto the evlstack, no dec/inc refcnt is done!
  allocate new evlstk page if necessary
  input:  RT+EVLSTK
  usage:  A, X, Y
  output: RT +(EVLSTK << RT)
  funcs:
    ALLOC_PAGE_TO_X
    INIT_CELLSTACK_PAGE_X
  CHECK STACK PAGE OVERFLOW
- [[file:vm-mm-cell-stack.rkt::291][PUSH_XA_TO_EVLSTK]] ::  push an atomic cell onto the stack (that is push the RegT, if filled, and write the value into RegT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push an atomic cell onto the stack (that is push the RegT, if filled, and write the value into RegT)
  input: call-frame stack, RT
         A = high byte,
         X = tagged low
  output: call-frame stack, RT
- [[file:vm-mm-cell-stack.rkt::286][PUSH_INT_TO_EVLSTK]] ::  ints are saved high byte first, then low byte !!!!
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  ints are saved high byte first, then low byte !!!!
  X = high byte of int (max 31 = $1f) (stored in low byte (tagged) position)
  A = low byte of int (0..255) (stored in high byte (untagged) position)
- [[file:vm-mm-cell-stack.rkt::284][PUSH_BYTE_X_TO_EVLSTK]] ::  push cell byte X to evlstk (actually RT TO evlstk and cell byte X into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push cell byte X to evlstk (actually RT TO evlstk and cell byte X into RT)
- [[file:vm-mm-cell-stack.rkt::282][WRITE_BYTE_X_TO_RT]] ::  write cell byte X into RT (overwriting it)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  write cell byte X into RT (overwriting it)
- [[file:vm-mm-cell-stack.rkt::280][PUSH_INT_m1_TO_EVLSTK]] ::  push cell int -1 to evlstk (actually RT TO evlstk and cell int -1 into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push cell int -1 to evlstk (actually RT TO evlstk and cell int -1 into RT)
- [[file:vm-mm-cell-stack.rkt::278][PUSH_INT_2_TO_EVLSTK]] ::  push cell int 2 to evlstk (actually RT TO evlstk and cell int 2 into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push cell int 2 to evlstk (actually RT TO evlstk and cell int 2 into RT)
- [[file:vm-mm-cell-stack.rkt::276][PUSH_INT_1_TO_EVLSTK]] ::  push cell int 1 to evlstk (actually RT TO evlstk and cell int 1 into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push cell int 1 to evlstk (actually RT TO evlstk and cell int 1 into RT)
- [[file:vm-mm-cell-stack.rkt::274][PUSH_INT_0_TO_EVLSTK]] ::  push cell int 0 to evlstk (actually RT TO evlstk and cell int 0 into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push cell int 0 to evlstk (actually RT TO evlstk and cell int 0 into RT)
- [[file:vm-mm-cell-stack.rkt::272][PUSH_NIL_TO_EVLSTK]] ::  push nil to evlstk (actually RT TO evlstk and nil-cell into RT)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" PUSH_XA_TO_EVLSTK))
  - assembler include :: PUSH_XA_TO_EVLSTK
  push nil to evlstk (actually RT TO evlstk and nil-cell into RT)
- [[file:vm-mm-cell-stack.rkt::131][POP_CELL_EVLSTK_TO_RT]] ::  pop the topmost value of the evlstk into RT (no gc done)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" POP_CELL_EVLSTK_TO_RT))
  - assembler include :: POP_CELL_EVLSTK_TO_RT
  pop the topmost value of the evlstk into RT (no gc done)
  input:  EVLSTK
  usage:  A,Y, RT
  output: RT <<EVLSTK<<
- [[file:vm-mm-cell-stack.rkt::78][INIT_CELLSTACK_PAGE_X]] ::  cell stack page(s)
  - racket require :: (require (only-in "vm-mm-cell-stack.rkt" INIT_CELLSTACK_PAGE_X))
  - assembler include :: INIT_CELLSTACK_PAGE_X
  cell stack page(s)
  offset  content
  00      #b0001 1011
  01      previous page (of the stack)
  02..ff  payload (either lowbyte or highbyte of the cell)

  input:  A old stack page
          X new stack page
  output: X new stack page
  uses:   A, X, Y
          ZP_TEMP, ZP_TEMP+1
** pages
- [[file:vm-mm-pages.rkt::268][FREE_PAGE_A]] ::  whether a page is free or used is kept in the 256 bytes starting at VM_PAGE_SLOT_DATA
  - racket require :: (require (only-in "vm-mm-pages.rkt" FREE_PAGE_A))
  - assembler include :: FREE_PAGE_A
  whether a page is free or used is kept in the 256 bytes starting at VM_PAGE_SLOT_DATA
  each byte represents one page
    00 = allocated (used) but no free slots
    01 = system page, not available for memory management
    ff = free page (not allocated yet)
  VM_HIGHEST_PAGE_IDX_FOR_ALLOC_SEARCH  (255..0) keeps the max idx to start looking for a page that is free
  parameter: a = page
  result: (none)
- [[file:vm-mm-pages.rkt::238][ALLOC_PAGE_TO_X]] ::  does a linear search for the next free page
  - racket require :: (require (only-in "vm-mm-pages.rkt" ALLOC_PAGE_TO_X))
  - assembler include :: ALLOC_PAGE_TO_X
  does a linear search for the next free page
  allocate a page (completely uninitialized), just the page, update the memory page status in VM_PAGE_SLOT_DATA
  parameter: (none)
  result: X = allocated free page (uninitialized)
  uses: A, X
- [[file:vm-mm-pages.rkt::180][VM_INITIALIZE_MEMORY_MANAGER]] ::  initialize memory management (paging)
  - racket require :: (require (only-in "vm-mm-pages.rkt" VM_INITIALIZE_MEMORY_MANAGER))
  - assembler include :: VM_INITIALIZE_MEMORY_MANAGER
  initialize memory management (paging)
  - setup 'next free page' information, basically initializing the whole page with zeros
  - setup cell stack (to empty)

  destroys: A Y
** misc
- [[file:vm-interpreter.rkt::236][VM_INTERPRETER_INIT]] ::  initialize PC to $8000
  - racket require :: (require (only-in "vm-interpreter.rkt" VM_INTERPRETER_INIT))
  - assembler include :: VM_INTERPRETER_INIT
  initialize PC to $8000
** cell
- [[file:vm-mm-cells.rkt::775][ALLOC_CELL_AX_TO_RT]] ::  allocate the cell at A on page X
  - racket require :: (require (only-in "vm-mm-cells.rkt" ALLOC_CELL_AX_TO_RT))
  - assembler include :: ALLOC_CELL_AX_TO_RT
  allocate the cell at A on page X

  update next free cell in vm_page_slot_data
  update number of allocated cells on page X
  input:  A = lowbyte
          X = highbyte (page)
          # cells allocated on PAGE
  output: A = next free cell
          X = PAGE
          Y = 0
          VM_PAGE_SLOT_DATA + PAGE = next free cell
          # cells allocated on PAGE ++
- [[file:vm-mm-cells.rkt::711][GET_FRESH_CELL_TO_AX]] ::  get the page and unused cell for allocation
  - racket require :: (require (only-in "vm-mm-cells.rkt" GET_FRESH_CELL_TO_AX))
  - assembler include :: GET_FRESH_CELL_TO_AX
  get the page and unused cell for allocation

  get the complete ptr, do not allocate this cell yet
  allocate a new page if necessary
  do not use any cell free list
  input:  GLOBAL_CELL_PAGE_FOR_ALLOC
          VM_PAGE_SLOT_DATA+PAGE
  output: A = lowbyte
          X = highbyte (page)
          Y = ?
- [[file:vm-mm-cells.rkt::585][ALLOC_CELL_TO_RT]] ::  allocate (or reuse from free-list) cell into rt
  - racket require :: (require (only-in "vm-mm-cells.rkt" ALLOC_CELL_TO_RT))
  - assembler include :: ALLOC_CELL_TO_RT
  allocate (or reuse from free-list) cell into rt

  input:  GLOBAL_CELL_FREE_LIST
          GLOBAL_CELL_PAGE_FOR_ALLOC
          VM_PAGE_SLOT_DATA
          # cells allocated on PAGE
  output: ZP_RT: ptr to heap allocated cell (cell itself is not initialized!)
          GLOBAL_CELL_FREE_LIST
          A, X, Y: ?
** gc
- [[file:vm-mm-cell-pairs.rkt::1204][GC_CELLPAIR_FREE_LIST]] ::  actively free all enqueued cell pairs of the free-list!
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" GC_CELLPAIR_FREE_LIST))
  - assembler include :: GC_CELLPAIR_FREE_LIST
  actively free all enqueued cell pairs of the free-list!
  can be useful to find out whether a whole page is not used at all. free cells are still marked as used on a page.
  input:  GLOBAL_CELLPAIR_FREE_LIST
  usage:  A, Y, RZ
  output: GLOBAL_CELLPAIR_FREE_LIST+1 = 0
  funcs:
    DEC_REFCNT_RZ >>
    GC_CELLPAIR_FREE_LIST
- [[file:vm-mm-cell-pairs.rkt::954][FREE_CELLPAIR_RZ]] ::  put the given cellpair on the global free list
  - racket require :: (require (only-in "vm-mm-cell-pairs.rkt" FREE_CELLPAIR_RT))
  - assembler include :: FREE_CELLPAIR_RT
  put the given cellpair on the global free list
  dec-refcnt cell0 if it is a ptr, defer dec-refcnt cell1 to allocation/reuse time
  input: RZ (RT RA), GLOBAL_CELLPAIR_FREE_LIST
  usage: A, X, Y, RZ
  output: GLOBAL_CELLPAIR_FREE_LIST << RZ
  funcs:
    DEC_REFCNT_RZ>>
- [[file:vm-mm-m1-slots.rkt::1017][FREE_M1_SLOT_RZ]] ::  free the m1 slot referenced by RZ
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" FREE_M1_SLOT_RZ))
  - assembler include :: FREE_M1_SLOT_RZ
  free the m1 slot referenced by RZ
  input: RZ
  usage: A, X, Y, RZ
  output:
  funcs:
    GC_INCR_ARRAY_SLOT_RZ >>
    ADD_M1_SLOT_RZ_TO_PFL >>
- [[file:vm-mm-m1-slots.rkt::964][INC_REFCNT_M1_SLOT_RA]] ::  increment refcount of m1 slot in RA
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" INC_REFCNT_M1_SLOT_RA))
  - assembler include :: INC_REFCNT_M1_SLOT_RA
  increment refcount of m1 slot in RA
  IDEA for optimization: keep m1 in RA, putting +1 offset on all accesses -> DEC/INC could be saved
  input:  RA (pointing to some m1 slot)
  usage:  A, Y, RA
  output: M1_SLOT Refcount++
  funcs: -
- [[file:vm-mm-m1-slots.rkt::823][FREE_M1_SLOT_RA]] ::  free the m1 slot pointed to by ra, marking that slot free on the m1-page
  - racket require :: (require (only-in "vm-mm-m1-slots.rkt" FREE_M1_SLOT_RA))
  - assembler include :: FREE_M1_SLOT_RA
  free the m1 slot pointed to by ra, marking that slot free on the m1-page
  no check of the slot content is done! in case of cell-arrays: the elements of the array are not checked
  input:  RA
  usage: A, X, Y, RA
  output: RA is invalid
  funcs:
    VM_ENQUEUE_PAGE_AS_HEAD_FOR_RA_SLOTS
    VM_REMOVE_FULL_PAGES_FOR_RA_SLOTS
  currently once allocated pages are not garbage collected. this is bad and needs to be changed
  (e.g. keep count of used slots)? used slots = 0 => free page
  INFO: NO GC! (this must be done, freeing specific types (e.g. an array) <- knows the number of slots etc.
        REF COUNT IS SET TO ZERO (of this slot)
- [[file:vm-mm-cell-array.rkt::302][GC_INCR_ARRAY_SLOT_RZ]] ::  incrementally garbage collect an array by slots
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" GC_INCR_ARRAY_SLOT_RZ))
  - assembler include :: GC_INCR_ARRAY_SLOT_RZ
  incrementally garbage collect an array by slots
  may destroy RZ (on dec refcnt of a cell in the array)
  will free this cell-array, if no refcnts need to be dec (anymore)
  will add this cell array to ZP_PART_GCD_CELL_ARRAYS if not completely gc'd
  input: RZ
  usage: A, X, Y, RZ
  output: -
  funcs:
    DEC_REFCNT_RZ
    ADD_M1_SLOT_RZ_TO_PLF
- [[file:vm-mm-cell-array.rkt::299][GC_INCR_ARRAY_SLOT_RA]] ::  incrementally garbage collect an array by slots (see GC_INCR_ARRAY_SLOT_RZ)
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" GC_INCR_ARRAY_SLOT_RZ))
  - assembler include :: GC_INCR_ARRAY_SLOT_RZ
  incrementally garbage collect an array by slots (see GC_INCR_ARRAY_SLOT_RZ)
- [[file:vm-mm-cell-array.rkt::260][GC_CELL_ARRAY]] ::  keep collecting until the whole (single) array was collected but stop then!
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" GC_CELL_ARRAY))
  - assembler include :: GC_CELL_ARRAY
  keep collecting until the whole (single) array was collected but stop then!
  input:  ZP_PART_GCD_CELL_ARRAYS
  usage:  A, X, Y, RZ
  output: <<ZP_PART_GCD_CELL_ARRAYS<<
  funcs:
    GC_INCR_ARRAY_SLOT_RZ
- [[file:vm-mm-cell-array.rkt::235][GC_CELL_ARRAYS]] ::  do incremental collections until all cell arrays (and their slots) were garbage collected
  - racket require :: (require (only-in "vm-mm-cell-array.rkt" GC_CELL_ARRAYS))
  - assembler include :: GC_CELL_ARRAYS
  do incremental collections until all cell arrays (and their slots) were garbage collected
  input:  ZP_PART_GCD_CELL_ARRAYS
  usage:  A, X, Y, RZ
  output: ZP_PART_GCD_CELL_ARRAYS+1 = 0  (no more arrays left that are partially gc'd)
  funcs:
    GC_CELL_ARRAY
    GC_INCR_ARRAY_SLOT_RZ
- [[file:vm-call-frame.rkt::809][VM_FREE_LOCALS]] ::  input:  A number of locals to keep after free (locals of current function?)
  - racket require :: (require (only-in "vm-call-frame.rkt" VM_FREE_LOCALS))
  - assembler include :: VM_FREE_LOCALS
  input:  A number of locals to keep after free (locals of current function?)
          zp_locals_lb_ptr
          zp_locals_hb_ptr
          zp_locals_top_mark
  output: A  new topmark
          zp_locals_lb_ptr
          zp_locals_hb_ptr
          zp_locals_top_mark
  uses:   A, X, Y
- [[file:vm-interpreter.rkt::710][VM_REFCOUNT_DECR_CURRENT_LOCALS]] ::  decrement the refcount to all locals that are not initial (e.g. upon leaving a function)
  - racket require :: (require (only-in "vm-interpreter.rkt" VM_REFCOUNT_DECR_CURRENT_LOCALS))
  - assembler include :: VM_REFCOUNT_DECR_CURRENT_LOCALS
  decrement the refcount to all locals that are not initial (e.g. upon leaving a function)
- [[file:vm-interpreter.rkt::678][VM_REFCOUNT_DECR_ARRAY_REGS]] ::  decrement refcount to all array register (ra, rb, rc)
  - racket require :: (require (only-in "vm-interpreter.rkt" VM_REFCOUNT_DECR_ARRAY_REGS))
  - assembler include :: VM_REFCOUNT_DECR_ARRAY_REGS
  decrement refcount to all array register (ra, rb, rc)
  rb is only checked, if ra != 0,
  rc is only checked, if rb != 0,
- [[file:vm-mm-cells.rkt::849][GC_CELLS]] ::  garbage collect all cells marked as reusable in GLOBAL_CELL_FFREE_LIST
  - racket require :: (require (only-in "vm-mm-cells.rkt" GC_CELLS))
  - assembler include :: GC_CELLS
  garbage collect all cells marked as reusable in GLOBAL_CELL_FFREE_LIST
  input:  GLOBAL_CELL_FFREE_LIST
  usage:  A, X, Y, RZ
  output: GLOBAL_CELL_FFREE_LIST+1 = 0   (no more cells left for reuse)
  funcs:  -
- [[file:vm-mm-cells.rkt::393][FREE_CELL_RZ]] ::  free the given cell in RZ (RA, RT), and dec-refcnt its content (if it is a pointer)
  - racket require :: (require (only-in "vm-mm-cells.rkt" FREE_CELL_RT))
  - assembler include :: FREE_CELL_RT
  free the given cell in RZ (RA, RT), and dec-refcnt its content (if it is a pointer)
  it must not be a header cell of an array or something
  input: RZ
  usage: A, X, Y, RZ
  output: -
  funcs:
    DEC_REFCNT_RZ
    (CP_RA_TO_RZ)
    (CP_RT_TO_RZ)
- [[file:vm-memory-manager.rkt::606][GC_ALL]] ::  garbage collect all cells, all cell-pairs and all cell arrays marked for reuse or partially collected
  - racket require :: (require (only-in "vm-memory-manager.rkt" GC_ALL))
  - assembler include :: GC_ALL
  garbage collect all cells, all cell-pairs and all cell arrays marked for reuse or partially collected
  input:  GLOBAL_CELL_FREE_LIST, GLOBAL_CELLPAIR_FREE_LIST, ZP_PART_GCD_CELL_ARRAYS
  usage:  A, X, Y, RZ
  output: GLOBAL_CELL_FREE_LIST+1      = 0
          GLOBAL_CELLPAIR_FREE_LIST+1  = 0
          ZP_PART_GCD_CELL_ARRAYS+1    = 0
  funcs:
    GC_CELL_ARRAYS
    GC_CELL_ARRAY
    GC_INCR_ARRAY_SLOT_RZ
    GC_CELLPAIR_FREE_LIST
    DEC_REFCNT_RZ >>
    GC_CELLS
- [[file:vm-memory-manager.rkt::377][DEC_REFCNT_RZ]] ::  decrement the refcount (if a pointer) in RZ, call respective free if refcount drops to 0
  - racket require :: (require (only-in "vm-memory-manager.rkt" FREE_M1_SLOT_RZm1))
  - assembler include :: FREE_M1_SLOT_RZm1
  decrement the refcount (if a pointer) in RZ, call respective free if refcount drops to 0
  input:  RZ (RA, RT)
  usage:  A, X, Y, RZ
  output:
  funcs:
    FREE_M1_SLOT_RZ >>
    FREE_CELL_RZ >>
    FREE_CELLPAIR_RZ >>
- [[file:vm-memory-manager.rkt::311][FREE_RT]] ::  free nonatomic (is cell-ptr, cell-pair-ptr, cell-array-ptr, native-array-ptr)
  - racket require :: (require (only-in "vm-memory-manager.rkt" FREE_RT))
  - assembler include :: FREE_RT
  free nonatomic (is cell-ptr, cell-pair-ptr, cell-array-ptr, native-array-ptr)
  parameter: zp_rt
- [[file:vm-memory-manager.rkt::224][INC_REFCNT_RT]] ::  find out what kind of cell zp_rt points to,
  - racket require :: (require (only-in "vm-memory-manager.rkt" INC_REFCNT_CELLARR_RT))
  - assembler include :: INC_REFCNT_CELLARR_RT
  find out what kind of cell zp_rt points to,
  then call the right decrement refcounts function
  input:  ZP_RT
  output: the right refcount is decremented
          (in case of m1 pages, @ZP_RT-1)
          (in case of cell pages @ZP_RT>>1)
          (in case of cell-pair pages @ZP_RT>>2)
* byte codes (by code)
- [[file:vm-interpreter.rkt::2627][$01]] :: BNOP  *N*​o *OP*​eration
  - racket require :: (require (only-in "vm-interpreter.rkt" BNOP))
  - assembler include :: BC_BNOP
  *N*​o *OP*​eration
  len: 1
- [[file:vm-interpreter.rkt::2452][$01]] :: IMAX  *I*​nt *MAX*​imum, return the maximum of two ints
  - racket require :: (require (only-in "vm-interpreter.rkt" IMAX))
  - assembler include :: BC_IMAX
  *I*​nt *MAX*​imum, return the maximum of two ints
  len: 2 (extended)
  extended
- [[file:vm-interpreter.rkt::795][$02]] :: BREAK  collision with 6510 BRK code
  - racket require :: (require (only-in "vm-interpreter.rkt" BREAK))
  - assembler include :: BC_BREAK
  collision with 6510 BRK code
- [[file:vm-interpreter.rkt::2385][$02]] :: IINC  *I*​nt *INC*​rement
  - racket require :: (require (only-in "vm-interpreter.rkt" IINC))
  - assembler include :: BC_IINC
  *I*​nt *INC*​rement
  len: 2 (extended)
  extended (could be mapped to regular byte code, if needed very often!)
- [[file:vm-interpreter.rkt::2555][$03]] :: GC_FL  garbage collect the freelist
  - racket require :: (require (only-in "vm-interpreter.rkt" GC_FL))
  - assembler include :: BC_GC_FL
  garbage collect the freelist
  len: 2 (extended)
  extended
- [[file:vm-interpreter.rkt::1538][$03]] :: SWAP  swap tos with tos-1
  - racket require :: (require (only-in "vm-interpreter.rkt" SWAP))
  - assembler include :: BC_SWAP
  swap tos with tos-1
- [[file:vm-interpreter.rkt::2585][$04]] :: EXT  extension byte code, the next byte is the actual command (decoded from the extended byte code jump table)
  - racket require :: (require (only-in "vm-interpreter.rkt" EXT))
  - assembler include :: BC_EXT
  extension byte code, the next byte is the actual command (decoded from the extended byte code jump table)
- [[file:vm-interpreter.rkt::1243][$06]] :: PUSH_I  *PUSH* *I*​nt onto evlstk, op1=low byte op2=high byte, stack [] -> [cell-int]
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I))
  - assembler include :: BC_PUSH_I
  *PUSH* *I*​nt onto evlstk, op1=low byte op2=high byte, stack [] -> [cell-int]
  len: 3
- [[file:vm-interpreter.rkt::1803][$07]] :: INT_P  is top of evlstk an *INT*​eger (*P*​redicate)?
  - racket require :: (require (only-in "vm-interpreter.rkt" INT_P))
  - assembler include :: BC_INT_P
  is top of evlstk an *INT*​eger (*P*​redicate)?
- [[file:vm-interpreter.rkt::2364][$09]] :: PUSH_NIL  *PUSH* *NIL* to evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_NIL))
  - assembler include :: BC_PUSH_NIL
  *PUSH* *NIL* to evlstk
  len: 1
  stack: [] -> [NIL]
- [[file:vm-interpreter.rkt::2341][$0a]] :: CONS_PAIR_P  *CONS* *PAIR* *P*​redicate
  - racket require :: (require (only-in "vm-interpreter.rkt" CONS_PAIR_P))
  - assembler include :: BC_CONS_PAIR_P
  *CONS* *PAIR* *P*​redicate
  len: 1
- [[file:vm-interpreter.rkt::1861][$0b]] :: T_P_RET  *T*​rue *P*​redicate *RET*​urn
  - racket require :: (require (only-in "vm-interpreter.rkt" T_P_RET))
  - assembler include :: BC_T_P_RET
  *T*​rue *P*​redicate *RET*​urn
  len: 1
- [[file:vm-interpreter.rkt::2170][$0c]] :: T_P_BRA  *T*​rue *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" T_P_BRA))
  - assembler include :: BC_T_P_BRA
  *T*​rue *P*​redicate *BRA*​nch
  len: 2
- [[file:vm-interpreter.rkt::2037][$0d]] :: F_P_BRA  *F*​alse *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" F_P_BRA))
  - assembler include :: BC_F_P_BRA
  *F*​alse *P*​redicate *BRA*​nch
  len: 1
- [[file:vm-interpreter.rkt::1844][$0e]] :: F_P_RET  *F*​alse *P*​redicate *RET*​urn
  - racket require :: (require (only-in "vm-interpreter.rkt" F_P_RET))
  - assembler include :: BC_F_P_RET
  *F*​alse *P*​redicate *RET*​urn
- [[file:vm-interpreter.rkt::2482][$0f]] :: DUP  *DUP*​licate top of stack
  - racket require :: (require (only-in "vm-interpreter.rkt" DUP))
  - assembler include :: BC_DUP
  *DUP*​licate top of stack
  len: 1
- [[file:vm-interpreter.rkt::2663][$11]] :: POP  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" POP))
  - assembler include :: BC_POP
  len: 1
- [[file:vm-interpreter.rkt::2493][$12]] :: CELL_EQ_P  *CELL* *EQ*​ual *P*​redicate
  - racket require :: (require (only-in "vm-interpreter.rkt" CELL_EQ_P))
  - assembler include :: BC_CELL_EQ_P
  *CELL* *EQ*​ual *P*​redicate
  len: 1
- [[file:vm-interpreter.rkt::1827][$13]] :: F_P_RET_F  *F*​alse *P*​redicate *RET*​urn *F*​alse
  - racket require :: (require (only-in "vm-interpreter.rkt" F_P_RET_F))
  - assembler include :: BC_F_P_RET_F
  *F*​alse *P*​redicate *RET*​urn *F*​alse
- [[file:vm-interpreter.rkt::2884][$15]] :: PUSH_AF  stack: index (byte) :: cell-ptr -> cell-array
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_AF))
  - assembler include :: BC_PUSH_AF
  stack: index (byte) :: cell-ptr -> cell-array
  ->     value (cell)
  op = field-idx, stack [array-ref] -> [cell-]
- [[file:vm-interpreter.rkt::2837][$16]] :: POP_TO_AF  *POP* *TO* *A*​rray *F*​ield using the stack
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_AF))
  - assembler include :: BC_POP_TO_AF
  *POP* *TO* *A*​rray *F*​ield using the stack
  len: 1
  stack: index(byte) :: cell-ptr->cell-array  :: value (cell)
  ->     []
         cell-array @ index = value
  op = array-idx, stack [cell- array-ptr-] -> []
- [[file:vm-interpreter.rkt::2797][$17]] :: PUSH_B  *PUSH* *B*​yte, following the instruction
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_B))
  - assembler include :: BC_PUSH_B
  *PUSH* *B*​yte, following the instruction
  len: 2
- [[file:vm-interpreter.rkt::3255][$1a]] :: BDEC  *B*​yte *DEC*​rement, increment byte RT (no checks)
  - racket require :: (require (only-in "vm-interpreter.rkt" BDEC))
  - assembler include :: BC_BDEC
  *B*​yte *DEC*​rement, increment byte RT (no checks)
  len: 1
- [[file:vm-interpreter.rkt::3400][$1b]] :: Z_P_BRA  *Z*​ero *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_BRA))
  - assembler include :: BC_Z_P_BRA
  *Z*​ero *P*​redicate *BRA*​nch
  len: 2
- [[file:vm-interpreter.rkt::3277][$1c]] :: BINC  *B*​yte *INC*​rement, increment byte RT (no checks)
  - racket require :: (require (only-in "vm-interpreter.rkt" BINC))
  - assembler include :: BC_BINC
  *B*​yte *INC*​rement, increment byte RT (no checks)
  len: 1
- [[file:vm-interpreter.rkt::3421][$1d]] :: NZ_P_BRA  *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_BRA))
  - assembler include :: BC_NZ_P_BRA
  *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  on branch, it does no pop
  on fall through, it removes the 0 from the stack
  len: 2
- [[file:vm-interpreter.rkt::1419][$21]] :: NIL_P  stack [cell-list-ptr] -> [cell-boolean]
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P))
  - assembler include :: BC_NIL_P
  stack [cell-list-ptr] -> [cell-boolean]
- [[file:vm-interpreter.rkt::2528][$22]] :: I_Z_P  *I*​nt *Z*​ero *P*​redicate
  - racket require :: (require (only-in "vm-interpreter.rkt" I_Z_P))
  - assembler include :: BC_I_Z_P
  *I*​nt *Z*​ero *P*​redicate
  len: 1
- [[file:vm-interpreter.rkt::3228][$23]] :: BADD  *B*​yte *ADD* top two values on stack (no checks)
  - racket require :: (require (only-in "vm-interpreter.rkt" BADD))
  - assembler include :: BC_BADD
  *B*​yte *ADD* top two values on stack (no checks)
  len: 1
- [[file:vm-interpreter.rkt::1559][$24]] :: B_GT_P  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" B_GT_P))
  - assembler include :: BC_B_GT_P
  no doc
- [[file:vm-interpreter.rkt::1617][$25]] :: B_LT_P  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" B_LT_P))
  - assembler include :: BC_B_LT_P
  no doc
- [[file:vm-interpreter.rkt::1646][$26]] :: B_GE_P  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" B_GE_P))
  - assembler include :: BC_B_GE_P
  no doc
- [[file:vm-interpreter.rkt::1634][$27]] :: BSHR  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" BSHR))
  - assembler include :: BC_BSHR
  no doc
- [[file:vm-interpreter.rkt::1880][$32]] :: GOTO  goto relative by byte following in code
  - racket require :: (require (only-in "vm-interpreter.rkt" GOTO))
  - assembler include :: BC_GOTO
  goto relative by byte following in code
  len: 2
  op = relative offset
- [[file:vm-interpreter.rkt::752][$33]] :: RET  stack [cell paramN, ... cell param1, cell param0] -> []
  - racket require :: (require (only-in "vm-interpreter.rkt" RET))
  - assembler include :: BC_RET
  stack [cell paramN, ... cell param1, cell param0] -> []
- [[file:vm-interpreter.rkt::509][$34]] :: CALL  stack [int-cell: function index, cell paramN, ... cell param1, cell param0] -> [cell paramN, ... cell param1, cell param0]
  - racket require :: (require (only-in "vm-interpreter.rkt" CALL))
  - assembler include :: BC_CALL
  stack [int-cell: function index, cell paramN, ... cell param1, cell param0] -> [cell paramN, ... cell param1, cell param0]
- [[file:vm-interpreter.rkt::393][$35]] :: TAIL_CALL  stack [new-paramN .. new-param0, ..., original-paramN ... original-param0] -> [new-paramN .. new-param0]
  - racket require :: (require (only-in "vm-interpreter.rkt" TAIL_CALL))
  - assembler include :: BC_TAIL_CALL
  stack [new-paramN .. new-param0, ..., original-paramN ... original-param0] -> [new-paramN .. new-param0]
- [[file:vm-interpreter.rkt::1513][$41]] :: CDR  stack [cell-list-ptr] -> [cell-list-ptr cdr of list pointed at]
  - racket require :: (require (only-in "vm-interpreter.rkt" CDR))
  - assembler include :: BC_CDR
  stack [cell-list-ptr] -> [cell-list-ptr cdr of list pointed at]
- [[file:vm-interpreter.rkt::1465][$42]] :: CONS  stack [cell- car, cell-list-ptr cdr] -> stack [cell-list-ptr new-list]
  - racket require :: (require (only-in "vm-interpreter.rkt" CONS))
  - assembler include :: BC_CONS
  stack [cell- car, cell-list-ptr cdr] -> stack [cell-list-ptr new-list]
- [[file:vm-interpreter.rkt::1488][$43]] :: CAR  stack [cell-list-ptr] -> [cell- car of list pointed at]
  - racket require :: (require (only-in "vm-interpreter.rkt" CAR))
  - assembler include :: BC_CAR
  stack [cell-list-ptr] -> [cell- car of list pointed at]
- [[file:vm-interpreter.rkt::1456][$44]] :: COONS  execute two CONS in a row
  - racket require :: (require (only-in "vm-interpreter.rkt" COONS))
  - assembler include :: BC_COONS
  execute two CONS in a row
- [[file:vm-interpreter.rkt::2645][$45]] :: SWAP_RA_RB  swap array register RA with RB
  - racket require :: (require (only-in "vm-interpreter.rkt" SWAP_RA_RB))
  - assembler include :: BC_SWAP_RA_RB
  swap array register RA with RB
- [[file:vm-interpreter.rkt::2659][$46]] :: POP_TO_RB  *POP* top of evlstk *TO* *RB*, setting RAI=0
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RB))
  - assembler include :: BC_POP_TO_RB
  *POP* top of evlstk *TO* *RB*, setting RAI=0
  len: 1
- [[file:vm-interpreter.rkt::2997][$47]] :: PUSH_RA  *PUSH* *R*​egister *A* to stack
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_RA))
  - assembler include :: BC_PUSH_RA
  *PUSH* *R*​egister *A* to stack
- [[file:vm-interpreter.rkt::3136][$49]] :: BINC_RAI  *B*​yte *INC*​rement *RA* *I*​ndex register
  - racket require :: (require (only-in "vm-interpreter.rkt" BINC_RAI))
  - assembler include :: BC_BINC_RAI
  *B*​yte *INC*​rement *RA* *I*​ndex register
- [[file:vm-interpreter.rkt::3189][$4a]] :: NATIVE  following bytes are native 6510 commands, JSR RETURN_TO_BC ends this sequence
  - racket require :: (require (only-in "vm-interpreter.rkt" NATIVE))
  - assembler include :: BC_NATIVE
  following bytes are native 6510 commands, JSR RETURN_TO_BC ends this sequence
  len: 1
- [[file:vm-interpreter.rkt::2655][$4b]] :: POP_TO_RA  *POP* top of evlstk *TO* *RA*, setting RAI=0
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RA))
  - assembler include :: BC_POP_TO_RA
  *POP* top of evlstk *TO* *RA*, setting RAI=0
  len: 1
- [[file:vm-interpreter.rkt::3120][$4c]] :: ALLOC_ARA  *ALLOC*​ate cell *A*​rray into *RA* and pops the byte size off the stack
  - racket require :: (require (only-in "vm-interpreter.rkt" ALLOC_ARA))
  - assembler include :: BC_ALLOC_ARA
  *ALLOC*​ate cell *A*​rray into *RA* and pops the byte size off the stack
  stack: <byte-size> -> -
  len: 1
- [[file:vm-interpreter.rkt::3009][$4d]] :: PUSH_RA_AF  *PUSH* from array *RA* *A*​rray *F*​ield indexed by RAI to evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_RA_AF))
  - assembler include :: BC_PUSH_RA_AF
  *PUSH* from array *RA* *A*​rray *F*​ield indexed by RAI to evlstk
  stack -> (RA),RAI :: stack
- [[file:vm-interpreter.rkt::2825][$4e]] :: POP_TO_RA_AF  *POP* top of evlstk *TO* *RA* *A*​rray *F*​ield
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RA_AF))
  - assembler include :: BC_POP_TO_RA_AF
  *POP* top of evlstk *TO* *RA* *A*​rray *F*​ield
  len: 1
- [[file:vm-interpreter.rkt::3145][$4f]] :: POP_TO_RAI  *POP* top of evlstk byte *TO* *RA* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RAI))
  - assembler include :: BC_POP_TO_RAI
  *POP* top of evlstk byte *TO* *RA* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::3157][$51]] :: WRITE_TO_RAI  *WRITE* top of evlstk byte *TO* *RA* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_RAI))
  - assembler include :: BC_WRITE_TO_RAI
  *WRITE* top of evlstk byte *TO* *RA* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::3179][$52]] :: DEC_RAI  *DEC*​rement *RA* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" DEC_RAI))
  - assembler include :: BC_DEC_RAI
  *DEC*​rement *RA* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::3168][$53]] :: WRITE_TO_RBI  *WRITE* top of evlstk byte *TO* *RB* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_RBI))
  - assembler include :: BC_WRITE_TO_RBI
  *WRITE* top of evlstk byte *TO* *RB* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::3445][$54]] :: DEC_RBI_NZ_P_BRA  *DEC*​rement *RBI* and *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" DEC_RBI_NZ_P_BRA))
  - assembler include :: BC_DEC_RBI_NZ_P_BRA
  *DEC*​rement *RBI* and *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  len: 2
- [[file:vm-interpreter.rkt::2994][$55]] :: WRITE_RA  *WRITE* *R*​egister *A* to stack
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_RA))
  - assembler include :: BC_WRITE_RA
  *WRITE* *R*​egister *A* to stack
- [[file:vm-interpreter.rkt::1344][$61]] :: ISUB  stack [cell-int a, cell-int b] -> [difference]
  - racket require :: (require (only-in "vm-interpreter.rkt" ISUB))
  - assembler include :: BC_ISUB
  stack [cell-int a, cell-int b] -> [difference]
- [[file:vm-interpreter.rkt::1269][$62]] :: IADD  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" IADD))
  - assembler include :: BC_IADD
  len: 1
  stack [cell-int a, cell-int b] -> [sum]
- [[file:vm-interpreter.rkt::1704][$63]] :: I_GT_P  *I*​nt *G*​reater *T*​han *P*​redicates
  - racket require :: (require (only-in "vm-interpreter.rkt" I_GT_P))
  - assembler include :: BC_I_GT_P
  *I*​nt *G*​reater *T*​han *P*​redicates
- [[file:vm-interpreter.rkt::887][$80]] :: PUSH_L0  *PUSH* *L*​ocal *0* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L0))
  - assembler include :: BC_PUSH_L0
  *PUSH* *L*​ocal *0* on evlstk
- [[file:vm-interpreter.rkt::896][$81]] :: WRITE_L0  *WRITE* *L*​ocal *0* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L0))
  - assembler include :: BC_WRITE_L0
  *WRITE* *L*​ocal *0* into rt
- [[file:vm-interpreter.rkt::889][$82]] :: PUSH_L1  *PUSH* *L*​ocal *1* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L1))
  - assembler include :: BC_PUSH_L1
  *PUSH* *L*​ocal *1* on evlstk
- [[file:vm-interpreter.rkt::898][$83]] :: WRITE_L1  *WRITE* *L*​ocal *1* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L1))
  - assembler include :: BC_WRITE_L1
  *WRITE* *L*​ocal *1* into rt
- [[file:vm-interpreter.rkt::891][$84]] :: PUSH_L2  *PUSH* *L*​ocal *2* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L2))
  - assembler include :: BC_PUSH_L2
  *PUSH* *L*​ocal *2* on evlstk
- [[file:vm-interpreter.rkt::900][$85]] :: WRITE_L2  *WRITE* *L*​ocal *2* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L2))
  - assembler include :: BC_WRITE_L2
  *WRITE* *L*​ocal *2* into rt
- [[file:vm-interpreter.rkt::893][$86]] :: PUSH_L3  *PUSH* *L*​ocal *3* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L3))
  - assembler include :: BC_PUSH_L3
  *PUSH* *L*​ocal *3* on evlstk
- [[file:vm-interpreter.rkt::902][$87]] :: WRITE_L3  *WRITE* *L*​ocal *3* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L3))
  - assembler include :: BC_WRITE_L3
  *WRITE* *L*​ocal *3* into rt
- [[file:vm-interpreter.rkt::938][$90]] :: POP_TO_L0  *POP* *TO* *L*​ocal *0* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L0))
  - assembler include :: BC_POP_TO_L0
  *POP* *TO* *L*​ocal *0* from evlstk
- [[file:vm-interpreter.rkt::946][$91]] :: WRITE_TO_L0  *WRITE* *TO* *L*​ocal *0* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L0))
  - assembler include :: BC_WRITE_TO_L0
  *WRITE* *TO* *L*​ocal *0* from evlstk
- [[file:vm-interpreter.rkt::940][$92]] :: POP_TO_L1  *POP* *TO* *L*​ocal *1* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L1))
  - assembler include :: BC_POP_TO_L1
  *POP* *TO* *L*​ocal *1* from evlstk
- [[file:vm-interpreter.rkt::948][$93]] :: WRITE_TO_L1  *WRITE* *TO* *L*​ocal *1* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L1))
  - assembler include :: BC_WRITE_TO_L1
  *WRITE* *TO* *L*​ocal *1* from evlstk
- [[file:vm-interpreter.rkt::942][$94]] :: POP_TO_L2  *POP* *TO* *L*​ocal *2* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L2))
  - assembler include :: BC_POP_TO_L2
  *POP* *TO* *L*​ocal *2* from evlstk
- [[file:vm-interpreter.rkt::950][$95]] :: WRITE_TO_L2  *WRITE* *TO* *L*​ocal *2* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L2))
  - assembler include :: BC_WRITE_TO_L2
  *WRITE* *TO* *L*​ocal *2* from evlstk
- [[file:vm-interpreter.rkt::944][$96]] :: POP_TO_L3  *POP* *TO* *L*​ocal *3* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L3))
  - assembler include :: BC_POP_TO_L3
  *POP* *TO* *L*​ocal *3* from evlstk
- [[file:vm-interpreter.rkt::952][$97]] :: WRITE_TO_L3  *WRITE* *TO* *L*​ocal *3* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L3))
  - assembler include :: BC_WRITE_TO_L3
  *WRITE* *TO* *L*​ocal *3* from evlstk
- [[file:vm-interpreter.rkt::255][$98]] :: NIL_P_RET_L0_POP_1  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *1* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_1))
  - assembler include :: BC_NIL_P_RET_L0_POP_1
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *1* from evlstk
- [[file:vm-interpreter.rkt::257][$9a]] :: NIL_P_RET_L0_POP_2  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *2* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_2))
  - assembler include :: BC_NIL_P_RET_L0_POP_2
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *2* from evlstk
- [[file:vm-interpreter.rkt::259][$9c]] :: NIL_P_RET_L0_POP_3  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *3* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_3))
  - assembler include :: BC_NIL_P_RET_L0_POP_3
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *3* from evlstk
- [[file:vm-interpreter.rkt::261][$9e]] :: NIL_P_RET_L0_POP_4  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *4* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_4))
  - assembler include :: BC_NIL_P_RET_L0_POP_4
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *4* from evlstk
- [[file:vm-interpreter.rkt::836][$a0]] :: PUSH_L0_CAR  *PUSH* *L*​ocal *0* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L0_CAR))
  - assembler include :: BC_PUSH_L0_CAR
  *PUSH* *L*​ocal *0* and *CAR*
- [[file:vm-interpreter.rkt::845][$a1]] :: PUSH_L0_CDR  *PUSH* *L*​ocal *0* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L0_CDR))
  - assembler include :: BC_PUSH_L0_CDR
  *PUSH* *L*​ocal *0* and *CDR*
- [[file:vm-interpreter.rkt::838][$a2]] :: PUSH_L1_CAR  *PUSH* *L*​ocal *1* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L1_CAR))
  - assembler include :: BC_PUSH_L1_CAR
  *PUSH* *L*​ocal *1* and *CAR*
- [[file:vm-interpreter.rkt::847][$a3]] :: PUSH_L1_CDR  *PUSH* *L*​ocal *1* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L1_CDR))
  - assembler include :: BC_PUSH_L1_CDR
  *PUSH* *L*​ocal *1* and *CDR*
- [[file:vm-interpreter.rkt::840][$a4]] :: PUSH_L2_CAR  *PUSH* *L*​ocal *2* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L2_CAR))
  - assembler include :: BC_PUSH_L2_CAR
  *PUSH* *L*​ocal *2* and *CAR*
- [[file:vm-interpreter.rkt::849][$a5]] :: PUSH_L2_CDR  *PUSH* *L*​ocal *2* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L2_CDR))
  - assembler include :: BC_PUSH_L2_CDR
  *PUSH* *L*​ocal *2* and *CDR*
- [[file:vm-interpreter.rkt::842][$a6]] :: PUSH_L3_CAR  *PUSH* *L*​ocal *3* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L3_CAR))
  - assembler include :: BC_PUSH_L3_CAR
  *PUSH* *L*​ocal *3* and *CAR*
- [[file:vm-interpreter.rkt::851][$a7]] :: PUSH_L3_CDR  *PUSH* *L*​ocal *3* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L3_CDR))
  - assembler include :: BC_PUSH_L3_CDR
  *PUSH* *L*​ocal *3* and *CDR*
- [[file:vm-interpreter.rkt::2720][$a8]] :: CAAR  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CAAR))
  - assembler include :: BC_CAAR
  len: 1
- [[file:vm-interpreter.rkt::2722][$aa]] :: CADR  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CADR))
  - assembler include :: BC_CADR
  len: 1
- [[file:vm-interpreter.rkt::2724][$ac]] :: CDAR  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CDAR))
  - assembler include :: BC_CDAR
  len: 1
- [[file:vm-interpreter.rkt::2726][$ae]] :: CDDR  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CDDR))
  - assembler include :: BC_CDDR
  len: 1
- [[file:vm-interpreter.rkt::3022][$b0]] :: GET_AF_0  *GET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_0))
  - assembler include :: BC_GET_AF_0
  *GET* *A*​rray *F*​ield 0
  stack: [array-ptr] -> [cell@0 of array]  (replace tos with value from array)
- [[file:vm-interpreter.rkt::3034][$b1]] :: SET_AF_0  *SET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_0))
  - assembler include :: BC_SET_AF_0
  *SET* *A*​rray *F*​ield 0
  stack: [array-ptr] :: [value] -> [cell@0 of array]
- [[file:vm-interpreter.rkt::3025][$b2]] :: GET_AF_1  *GET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_1))
  - assembler include :: BC_GET_AF_1
  *GET* *A*​rray *F*​ield 1
  stack: [array-ptr] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3037][$b3]] :: SET_AF_1  *SET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_1))
  - assembler include :: BC_SET_AF_1
  *SET* *A*​rray *F*​ield 1
  stack: [array-ptr] :: [value] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3028][$b4]] :: GET_AF_2  *GET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_2))
  - assembler include :: BC_GET_AF_2
  *GET* *A*​rray *F*​ield 2
  stack: [array-ptr] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3040][$b5]] :: SET_AF_2  *SET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_2))
  - assembler include :: BC_SET_AF_2
  *SET* *A*​rray *F*​ield 2
  stack: [array-ptr] :: [value] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3031][$b6]] :: GET_AF_3  *GET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_3))
  - assembler include :: BC_GET_AF_3
  *GET* *A*​rray *F*​ield 3
  stack: [array-ptr] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::3043][$b7]] :: SET_AF_3  *SET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_3))
  - assembler include :: BC_SET_AF_3
  *SET* *A*​rray *F*​ield 3
  stack: [array-ptr] :: [value] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::1191][$b8]] :: PUSH_I0  *PUSH* *I*​nt *0* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I0))
  - assembler include :: BC_PUSH_I0
  *PUSH* *I*​nt *0* onto evlstk
- [[file:vm-interpreter.rkt::1193][$b9]] :: PUSH_I1  *PUSH* *I*​nt *1* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I1))
  - assembler include :: BC_PUSH_I1
  *PUSH* *I*​nt *1* onto evlstk
- [[file:vm-interpreter.rkt::1195][$ba]] :: PUSH_I2  *PUSH* *I*​nt *2* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I2))
  - assembler include :: BC_PUSH_I2
  *PUSH* *I*​nt *2* onto evlstk
- [[file:vm-interpreter.rkt::1197][$bb]] :: PUSH_IM1  *PUSH* *I*​nt *-1* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_IM1))
  - assembler include :: BC_PUSH_IM1
  *PUSH* *I*​nt *-1* onto evlstk
- [[file:vm-interpreter.rkt::3311][$c0]] :: NZ_P_RET_POP_0  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return without popping anything
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_0))
  - assembler include :: BC_NZ_P_RET_POP_0
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return without popping anything
  len: 1
- [[file:vm-interpreter.rkt::3299][$c1]] :: Z_P_RET_POP_0  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return without popping anything
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_0))
  - assembler include :: BC_Z_P_RET_POP_0
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return without popping anything
  len: 1
- [[file:vm-interpreter.rkt::3314][$c2]] :: NZ_P_RET_POP_1  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 1 value from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_1))
  - assembler include :: BC_NZ_P_RET_POP_1
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 1 value from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3302][$c3]] :: Z_P_RET_POP_1  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 1 value from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_1))
  - assembler include :: BC_Z_P_RET_POP_1
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 1 value from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3317][$c4]] :: NZ_P_RET_POP_2  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 2 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_2))
  - assembler include :: BC_NZ_P_RET_POP_2
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 2 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3305][$c5]] :: Z_P_RET_POP_2  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 2 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_2))
  - assembler include :: BC_Z_P_RET_POP_2
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 2 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3320][$c6]] :: NZ_P_RET_POP_3  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 3 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_3))
  - assembler include :: BC_NZ_P_RET_POP_3
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 3 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3308][$c7]] :: Z_P_RET_POP_3  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 3 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_3))
  - assembler include :: BC_Z_P_RET_POP_3
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 3 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3077][$c8]] :: GET_RA_AF_0  *GET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_0))
  - assembler include :: BC_GET_RA_AF_0
  *GET* *A*​rray *F*​ield 0
  stack: [array-ptr] -> [cell@0 of array]
- [[file:vm-interpreter.rkt::3089][$c9]] :: SET_RA_AF_0  *SET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_0))
  - assembler include :: BC_SET_RA_AF_0
  *SET* *A*​rray *F*​ield 0
  stack: [array-ptr] :: [value] -> [cell@0 of array]
- [[file:vm-interpreter.rkt::3080][$ca]] :: GET_RA_AF_1  *GET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_1))
  - assembler include :: BC_GET_RA_AF_1
  *GET* *A*​rray *F*​ield 1
  stack: [array-ptr] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3092][$cb]] :: SET_RA_AF_1  *SET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_1))
  - assembler include :: BC_SET_RA_AF_1
  *SET* *A*​rray *F*​ield 1
  stack: [array-ptr] :: [value] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3083][$cc]] :: GET_RA_AF_2  *GET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_2))
  - assembler include :: BC_GET_RA_AF_2
  *GET* *A*​rray *F*​ield 2
  stack: [array-ptr] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3095][$cd]] :: SET_RA_AF_2  *SET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_2))
  - assembler include :: BC_SET_RA_AF_2
  *SET* *A*​rray *F*​ield 2
  stack: [array-ptr] :: [value] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3086][$ce]] :: GET_RA_AF_3  *GET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_3))
  - assembler include :: BC_GET_RA_AF_3
  *GET* *A*​rray *F*​ield 3
  stack: [array-ptr] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::3098][$cf]] :: SET_RA_AF_3  *SET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_3))
  - assembler include :: BC_SET_RA_AF_3
  *SET* *A*​rray *F*​ield 3
  stack: [array-ptr] :: [value] -> [cell@3 of array]
* byte codes (by name)
- [[file:vm-interpreter.rkt::3120][ALLOC_ARA]] :: $4c  *ALLOC*​ate cell *A*​rray into *RA* and pops the byte size off the stack
  - racket require :: (require (only-in "vm-interpreter.rkt" ALLOC_ARA))
  - assembler include :: BC_ALLOC_ARA
  *ALLOC*​ate cell *A*​rray into *RA* and pops the byte size off the stack
  stack: <byte-size> -> -
  len: 1
- [[file:vm-interpreter.rkt::1646][B_GE_P]] :: $26  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" B_GE_P))
  - assembler include :: BC_B_GE_P
- [[file:vm-interpreter.rkt::1559][B_GT_P]] :: $24  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" B_GT_P))
  - assembler include :: BC_B_GT_P
- [[file:vm-interpreter.rkt::1617][B_LT_P]] :: $25  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" B_LT_P))
  - assembler include :: BC_B_LT_P
- [[file:vm-interpreter.rkt::3228][BADD]] :: $23  *B*​yte *ADD* top two values on stack (no checks)
  - racket require :: (require (only-in "vm-interpreter.rkt" BADD))
  - assembler include :: BC_BADD
  *B*​yte *ADD* top two values on stack (no checks)
  len: 1
- [[file:vm-interpreter.rkt::3255][BDEC]] :: $1a  *B*​yte *DEC*​rement, increment byte RT (no checks)
  - racket require :: (require (only-in "vm-interpreter.rkt" BDEC))
  - assembler include :: BC_BDEC
  *B*​yte *DEC*​rement, increment byte RT (no checks)
  len: 1
- [[file:vm-interpreter.rkt::3277][BINC]] :: $1c  *B*​yte *INC*​rement, increment byte RT (no checks)
  - racket require :: (require (only-in "vm-interpreter.rkt" BINC))
  - assembler include :: BC_BINC
  *B*​yte *INC*​rement, increment byte RT (no checks)
  len: 1
- [[file:vm-interpreter.rkt::3136][BINC_RAI]] :: $49  *B*​yte *INC*​rement *RA* *I*​ndex register
  - racket require :: (require (only-in "vm-interpreter.rkt" BINC_RAI))
  - assembler include :: BC_BINC_RAI
  *B*​yte *INC*​rement *RA* *I*​ndex register
- [[file:vm-interpreter.rkt::2627][BNOP]] :: $01  *N*​o *OP*​eration
  - racket require :: (require (only-in "vm-interpreter.rkt" BNOP))
  - assembler include :: BC_BNOP
  *N*​o *OP*​eration
  len: 1
- [[file:vm-interpreter.rkt::795][BREAK]] :: $02  collision with 6510 BRK code
  - racket require :: (require (only-in "vm-interpreter.rkt" BREAK))
  - assembler include :: BC_BREAK
  collision with 6510 BRK code
- [[file:vm-interpreter.rkt::1634][BSHR]] :: $27  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" BSHR))
  - assembler include :: BC_BSHR
- [[file:vm-interpreter.rkt::2720][CAAR]] :: $a8  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CAAR))
  - assembler include :: BC_CAAR
  len: 1
- [[file:vm-interpreter.rkt::2722][CADR]] :: $aa  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CADR))
  - assembler include :: BC_CADR
  len: 1
- [[file:vm-interpreter.rkt::509][CALL]] :: $34  stack [int-cell: function index, cell paramN, ... cell param1, cell param0] -> [cell paramN, ... cell param1, cell param0]
  - racket require :: (require (only-in "vm-interpreter.rkt" CALL))
  - assembler include :: BC_CALL
  stack [int-cell: function index, cell paramN, ... cell param1, cell param0] -> [cell paramN, ... cell param1, cell param0]
- [[file:vm-interpreter.rkt::1488][CAR]] :: $43  stack [cell-list-ptr] -> [cell- car of list pointed at]
  - racket require :: (require (only-in "vm-interpreter.rkt" CAR))
  - assembler include :: BC_CAR
  stack [cell-list-ptr] -> [cell- car of list pointed at]
- [[file:vm-interpreter.rkt::2724][CDAR]] :: $ac  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CDAR))
  - assembler include :: BC_CDAR
  len: 1
- [[file:vm-interpreter.rkt::2726][CDDR]] :: $ae  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CDDR))
  - assembler include :: BC_CDDR
  len: 1
- [[file:vm-interpreter.rkt::1513][CDR]] :: $41  stack [cell-list-ptr] -> [cell-list-ptr cdr of list pointed at]
  - racket require :: (require (only-in "vm-interpreter.rkt" CDR))
  - assembler include :: BC_CDR
  stack [cell-list-ptr] -> [cell-list-ptr cdr of list pointed at]
- [[file:vm-interpreter.rkt::2493][CELL_EQ_P]] :: $12  *CELL* *EQ*​ual *P*​redicate
  - racket require :: (require (only-in "vm-interpreter.rkt" CELL_EQ_P))
  - assembler include :: BC_CELL_EQ_P
  *CELL* *EQ*​ual *P*​redicate
  len: 1
- [[file:vm-interpreter.rkt::1465][CONS]] :: $42  stack [cell- car, cell-list-ptr cdr] -> stack [cell-list-ptr new-list]
  - racket require :: (require (only-in "vm-interpreter.rkt" CONS))
  - assembler include :: BC_CONS
  stack [cell- car, cell-list-ptr cdr] -> stack [cell-list-ptr new-list]
- [[file:vm-interpreter.rkt::2341][CONS_PAIR_P]] :: $0a  *CONS* *PAIR* *P*​redicate
  - racket require :: (require (only-in "vm-interpreter.rkt" CONS_PAIR_P))
  - assembler include :: BC_CONS_PAIR_P
  *CONS* *PAIR* *P*​redicate
  len: 1
- [[file:vm-interpreter.rkt::1456][COONS]] :: $44  execute two CONS in a row
  - racket require :: (require (only-in "vm-interpreter.rkt" COONS))
  - assembler include :: BC_COONS
  execute two CONS in a row
- [[file:vm-interpreter.rkt::3179][DEC_RAI]] :: $52  *DEC*​rement *RA* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" DEC_RAI))
  - assembler include :: BC_DEC_RAI
  *DEC*​rement *RA* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::3445][DEC_RBI_NZ_P_BRA]] :: $54  *DEC*​rement *RBI* and *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" DEC_RBI_NZ_P_BRA))
  - assembler include :: BC_DEC_RBI_NZ_P_BRA
  *DEC*​rement *RBI* and *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  len: 2
- [[file:vm-interpreter.rkt::2482][DUP]] :: $0f  *DUP*​licate top of stack
  - racket require :: (require (only-in "vm-interpreter.rkt" DUP))
  - assembler include :: BC_DUP
  *DUP*​licate top of stack
  len: 1
- [[file:vm-interpreter.rkt::2585][EXT]] :: $04  extension byte code, the next byte is the actual command (decoded from the extended byte code jump table)
  - racket require :: (require (only-in "vm-interpreter.rkt" EXT))
  - assembler include :: BC_EXT
  extension byte code, the next byte is the actual command (decoded from the extended byte code jump table)
- [[file:vm-interpreter.rkt::2037][F_P_BRA]] :: $0d  *F*​alse *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" F_P_BRA))
  - assembler include :: BC_F_P_BRA
  *F*​alse *P*​redicate *BRA*​nch
  len: 1
- [[file:vm-interpreter.rkt::1844][F_P_RET]] :: $0e  *F*​alse *P*​redicate *RET*​urn
  - racket require :: (require (only-in "vm-interpreter.rkt" F_P_RET))
  - assembler include :: BC_F_P_RET
  *F*​alse *P*​redicate *RET*​urn
- [[file:vm-interpreter.rkt::1827][F_P_RET_F]] :: $13  *F*​alse *P*​redicate *RET*​urn *F*​alse
  - racket require :: (require (only-in "vm-interpreter.rkt" F_P_RET_F))
  - assembler include :: BC_F_P_RET_F
  *F*​alse *P*​redicate *RET*​urn *F*​alse
- [[file:vm-interpreter.rkt::2555][GC_FL]] :: $03  garbage collect the freelist
  - racket require :: (require (only-in "vm-interpreter.rkt" GC_FL))
  - assembler include :: BC_GC_FL
  garbage collect the freelist
  len: 2 (extended)
  extended
- [[file:vm-interpreter.rkt::3022][GET_AF_0]] :: $b0  *GET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_0))
  - assembler include :: BC_GET_AF_0
  *GET* *A*​rray *F*​ield 0
  stack: [array-ptr] -> [cell@0 of array]  (replace tos with value from array)
- [[file:vm-interpreter.rkt::3025][GET_AF_1]] :: $b2  *GET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_1))
  - assembler include :: BC_GET_AF_1
  *GET* *A*​rray *F*​ield 1
  stack: [array-ptr] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3028][GET_AF_2]] :: $b4  *GET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_2))
  - assembler include :: BC_GET_AF_2
  *GET* *A*​rray *F*​ield 2
  stack: [array-ptr] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3031][GET_AF_3]] :: $b6  *GET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_3))
  - assembler include :: BC_GET_AF_3
  *GET* *A*​rray *F*​ield 3
  stack: [array-ptr] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::3077][GET_RA_AF_0]] :: $c8  *GET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_0))
  - assembler include :: BC_GET_RA_AF_0
  *GET* *A*​rray *F*​ield 0
  stack: [array-ptr] -> [cell@0 of array]
- [[file:vm-interpreter.rkt::3080][GET_RA_AF_1]] :: $ca  *GET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_1))
  - assembler include :: BC_GET_RA_AF_1
  *GET* *A*​rray *F*​ield 1
  stack: [array-ptr] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3083][GET_RA_AF_2]] :: $cc  *GET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_2))
  - assembler include :: BC_GET_RA_AF_2
  *GET* *A*​rray *F*​ield 2
  stack: [array-ptr] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3086][GET_RA_AF_3]] :: $ce  *GET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_3))
  - assembler include :: BC_GET_RA_AF_3
  *GET* *A*​rray *F*​ield 3
  stack: [array-ptr] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::1880][GOTO]] :: $32  goto relative by byte following in code
  - racket require :: (require (only-in "vm-interpreter.rkt" GOTO))
  - assembler include :: BC_GOTO
  goto relative by byte following in code
  len: 2
  op = relative offset
- [[file:vm-interpreter.rkt::1704][I_GT_P]] :: $63  *I*​nt *G*​reater *T*​han *P*​redicates
  - racket require :: (require (only-in "vm-interpreter.rkt" I_GT_P))
  - assembler include :: BC_I_GT_P
  *I*​nt *G*​reater *T*​han *P*​redicates
- [[file:vm-interpreter.rkt::2528][I_Z_P]] :: $22  *I*​nt *Z*​ero *P*​redicate
  - racket require :: (require (only-in "vm-interpreter.rkt" I_Z_P))
  - assembler include :: BC_I_Z_P
  *I*​nt *Z*​ero *P*​redicate
  len: 1
- [[file:vm-interpreter.rkt::1269][IADD]] :: $62  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" IADD))
  - assembler include :: BC_IADD
  len: 1
  stack [cell-int a, cell-int b] -> [sum]
- [[file:vm-interpreter.rkt::2385][IINC]] :: $02  *I*​nt *INC*​rement
  - racket require :: (require (only-in "vm-interpreter.rkt" IINC))
  - assembler include :: BC_IINC
  *I*​nt *INC*​rement
  len: 2 (extended)
  extended (could be mapped to regular byte code, if needed very often!)
- [[file:vm-interpreter.rkt::2452][IMAX]] :: $01  *I*​nt *MAX*​imum, return the maximum of two ints
  - racket require :: (require (only-in "vm-interpreter.rkt" IMAX))
  - assembler include :: BC_IMAX
  *I*​nt *MAX*​imum, return the maximum of two ints
  len: 2 (extended)
  extended
- [[file:vm-interpreter.rkt::1803][INT_P]] :: $07  is top of evlstk an *INT*​eger (*P*​redicate)?
  - racket require :: (require (only-in "vm-interpreter.rkt" INT_P))
  - assembler include :: BC_INT_P
  is top of evlstk an *INT*​eger (*P*​redicate)?
- [[file:vm-interpreter.rkt::1344][ISUB]] :: $61  stack [cell-int a, cell-int b] -> [difference]
  - racket require :: (require (only-in "vm-interpreter.rkt" ISUB))
  - assembler include :: BC_ISUB
  stack [cell-int a, cell-int b] -> [difference]
- [[file:vm-interpreter.rkt::3189][NATIVE]] :: $4a  following bytes are native 6510 commands, JSR RETURN_TO_BC ends this sequence
  - racket require :: (require (only-in "vm-interpreter.rkt" NATIVE))
  - assembler include :: BC_NATIVE
  following bytes are native 6510 commands, JSR RETURN_TO_BC ends this sequence
  len: 1
- [[file:vm-interpreter.rkt::1419][NIL_P]] :: $21  stack [cell-list-ptr] -> [cell-boolean]
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P))
  - assembler include :: BC_NIL_P
  stack [cell-list-ptr] -> [cell-boolean]
- [[file:vm-interpreter.rkt::255][NIL_P_RET_L0_POP_1]] :: $98  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *1* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_1))
  - assembler include :: BC_NIL_P_RET_L0_POP_1
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *1* from evlstk
- [[file:vm-interpreter.rkt::257][NIL_P_RET_L0_POP_2]] :: $9a  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *2* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_2))
  - assembler include :: BC_NIL_P_RET_L0_POP_2
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *2* from evlstk
- [[file:vm-interpreter.rkt::259][NIL_P_RET_L0_POP_3]] :: $9c  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *3* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_3))
  - assembler include :: BC_NIL_P_RET_L0_POP_3
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *3* from evlstk
- [[file:vm-interpreter.rkt::261][NIL_P_RET_L0_POP_4]] :: $9e  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *4* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_4))
  - assembler include :: BC_NIL_P_RET_L0_POP_4
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *4* from evlstk
- [[file:vm-interpreter.rkt::3421][NZ_P_BRA]] :: $1d  *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_BRA))
  - assembler include :: BC_NZ_P_BRA
  *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  on branch, it does no pop
  on fall through, it removes the 0 from the stack
  len: 2
- [[file:vm-interpreter.rkt::3311][NZ_P_RET_POP_0]] :: $c0  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return without popping anything
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_0))
  - assembler include :: BC_NZ_P_RET_POP_0
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return without popping anything
  len: 1
- [[file:vm-interpreter.rkt::3314][NZ_P_RET_POP_1]] :: $c2  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 1 value from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_1))
  - assembler include :: BC_NZ_P_RET_POP_1
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 1 value from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3317][NZ_P_RET_POP_2]] :: $c4  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 2 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_2))
  - assembler include :: BC_NZ_P_RET_POP_2
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 2 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3320][NZ_P_RET_POP_3]] :: $c6  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 3 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_3))
  - assembler include :: BC_NZ_P_RET_POP_3
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 3 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::2663][POP]] :: $11  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" POP))
  - assembler include :: BC_POP
  len: 1
- [[file:vm-interpreter.rkt::2837][POP_TO_AF]] :: $16  *POP* *TO* *A*​rray *F*​ield using the stack
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_AF))
  - assembler include :: BC_POP_TO_AF
  *POP* *TO* *A*​rray *F*​ield using the stack
  len: 1
  stack: index(byte) :: cell-ptr->cell-array  :: value (cell)
  ->     []
         cell-array @ index = value
  op = array-idx, stack [cell- array-ptr-] -> []
- [[file:vm-interpreter.rkt::938][POP_TO_L0]] :: $90  *POP* *TO* *L*​ocal *0* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L0))
  - assembler include :: BC_POP_TO_L0
  *POP* *TO* *L*​ocal *0* from evlstk
- [[file:vm-interpreter.rkt::940][POP_TO_L1]] :: $92  *POP* *TO* *L*​ocal *1* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L1))
  - assembler include :: BC_POP_TO_L1
  *POP* *TO* *L*​ocal *1* from evlstk
- [[file:vm-interpreter.rkt::942][POP_TO_L2]] :: $94  *POP* *TO* *L*​ocal *2* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L2))
  - assembler include :: BC_POP_TO_L2
  *POP* *TO* *L*​ocal *2* from evlstk
- [[file:vm-interpreter.rkt::944][POP_TO_L3]] :: $96  *POP* *TO* *L*​ocal *3* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L3))
  - assembler include :: BC_POP_TO_L3
  *POP* *TO* *L*​ocal *3* from evlstk
- [[file:vm-interpreter.rkt::2655][POP_TO_RA]] :: $4b  *POP* top of evlstk *TO* *RA*, setting RAI=0
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RA))
  - assembler include :: BC_POP_TO_RA
  *POP* top of evlstk *TO* *RA*, setting RAI=0
  len: 1
- [[file:vm-interpreter.rkt::2825][POP_TO_RA_AF]] :: $4e  *POP* top of evlstk *TO* *RA* *A*​rray *F*​ield
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RA_AF))
  - assembler include :: BC_POP_TO_RA_AF
  *POP* top of evlstk *TO* *RA* *A*​rray *F*​ield
  len: 1
- [[file:vm-interpreter.rkt::3145][POP_TO_RAI]] :: $4f  *POP* top of evlstk byte *TO* *RA* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RAI))
  - assembler include :: BC_POP_TO_RAI
  *POP* top of evlstk byte *TO* *RA* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::2659][POP_TO_RB]] :: $46  *POP* top of evlstk *TO* *RB*, setting RAI=0
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RB))
  - assembler include :: BC_POP_TO_RB
  *POP* top of evlstk *TO* *RB*, setting RAI=0
  len: 1
- [[file:vm-interpreter.rkt::2884][PUSH_AF]] :: $15  stack: index (byte) :: cell-ptr -> cell-array
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_AF))
  - assembler include :: BC_PUSH_AF
  stack: index (byte) :: cell-ptr -> cell-array
  ->     value (cell)
  op = field-idx, stack [array-ref] -> [cell-]
- [[file:vm-interpreter.rkt::2797][PUSH_B]] :: $17  *PUSH* *B*​yte, following the instruction
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_B))
  - assembler include :: BC_PUSH_B
  *PUSH* *B*​yte, following the instruction
  len: 2
- [[file:vm-interpreter.rkt::1243][PUSH_I]] :: $06  *PUSH* *I*​nt onto evlstk, op1=low byte op2=high byte, stack [] -> [cell-int]
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I))
  - assembler include :: BC_PUSH_I
  *PUSH* *I*​nt onto evlstk, op1=low byte op2=high byte, stack [] -> [cell-int]
  len: 3
- [[file:vm-interpreter.rkt::1191][PUSH_I0]] :: $b8  *PUSH* *I*​nt *0* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I0))
  - assembler include :: BC_PUSH_I0
  *PUSH* *I*​nt *0* onto evlstk

- [[file:vm-interpreter.rkt::1193][PUSH_I1]] :: $b9  *PUSH* *I*​nt *1* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I1))
  - assembler include :: BC_PUSH_I1
  *PUSH* *I*​nt *1* onto evlstk

- [[file:vm-interpreter.rkt::1195][PUSH_I2]] :: $ba  *PUSH* *I*​nt *2* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I2))
  - assembler include :: BC_PUSH_I2
  *PUSH* *I*​nt *2* onto evlstk

- [[file:vm-interpreter.rkt::1197][PUSH_IM1]] :: $bb  *PUSH* *I*​nt *-1* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_IM1))
  - assembler include :: BC_PUSH_IM1
  *PUSH* *I*​nt *-1* onto evlstk

- [[file:vm-interpreter.rkt::887][PUSH_L0]] :: $80  *PUSH* *L*​ocal *0* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L0))
  - assembler include :: BC_PUSH_L0
  *PUSH* *L*​ocal *0* on evlstk
- [[file:vm-interpreter.rkt::836][PUSH_L0_CAR]] :: $a0  *PUSH* *L*​ocal *0* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L0_CAR))
  - assembler include :: BC_PUSH_L0_CAR
  *PUSH* *L*​ocal *0* and *CAR*
- [[file:vm-interpreter.rkt::845][PUSH_L0_CDR]] :: $a1  *PUSH* *L*​ocal *0* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L0_CDR))
  - assembler include :: BC_PUSH_L0_CDR
  *PUSH* *L*​ocal *0* and *CDR*
- [[file:vm-interpreter.rkt::889][PUSH_L1]] :: $82  *PUSH* *L*​ocal *1* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L1))
  - assembler include :: BC_PUSH_L1
  *PUSH* *L*​ocal *1* on evlstk
- [[file:vm-interpreter.rkt::838][PUSH_L1_CAR]] :: $a2  *PUSH* *L*​ocal *1* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L1_CAR))
  - assembler include :: BC_PUSH_L1_CAR
  *PUSH* *L*​ocal *1* and *CAR*
- [[file:vm-interpreter.rkt::847][PUSH_L1_CDR]] :: $a3  *PUSH* *L*​ocal *1* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L1_CDR))
  - assembler include :: BC_PUSH_L1_CDR
  *PUSH* *L*​ocal *1* and *CDR*
- [[file:vm-interpreter.rkt::891][PUSH_L2]] :: $84  *PUSH* *L*​ocal *2* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L2))
  - assembler include :: BC_PUSH_L2
  *PUSH* *L*​ocal *2* on evlstk
- [[file:vm-interpreter.rkt::840][PUSH_L2_CAR]] :: $a4  *PUSH* *L*​ocal *2* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L2_CAR))
  - assembler include :: BC_PUSH_L2_CAR
  *PUSH* *L*​ocal *2* and *CAR*
- [[file:vm-interpreter.rkt::849][PUSH_L2_CDR]] :: $a5  *PUSH* *L*​ocal *2* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L2_CDR))
  - assembler include :: BC_PUSH_L2_CDR
  *PUSH* *L*​ocal *2* and *CDR*
- [[file:vm-interpreter.rkt::893][PUSH_L3]] :: $86  *PUSH* *L*​ocal *3* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L3))
  - assembler include :: BC_PUSH_L3
  *PUSH* *L*​ocal *3* on evlstk
- [[file:vm-interpreter.rkt::842][PUSH_L3_CAR]] :: $a6  *PUSH* *L*​ocal *3* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L3_CAR))
  - assembler include :: BC_PUSH_L3_CAR
  *PUSH* *L*​ocal *3* and *CAR*
- [[file:vm-interpreter.rkt::851][PUSH_L3_CDR]] :: $a7  *PUSH* *L*​ocal *3* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L3_CDR))
  - assembler include :: BC_PUSH_L3_CDR
  *PUSH* *L*​ocal *3* and *CDR*
- [[file:vm-interpreter.rkt::2364][PUSH_NIL]] :: $09  *PUSH* *NIL* to evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_NIL))
  - assembler include :: BC_PUSH_NIL
  *PUSH* *NIL* to evlstk
  len: 1
  stack: [] -> [NIL]
- [[file:vm-interpreter.rkt::2997][PUSH_RA]] :: $47  *PUSH* *R*​egister *A* to stack
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_RA))
  - assembler include :: BC_PUSH_RA
  *PUSH* *R*​egister *A* to stack
- [[file:vm-interpreter.rkt::3009][PUSH_RA_AF]] :: $4d  *PUSH* from array *RA* *A*​rray *F*​ield indexed by RAI to evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_RA_AF))
  - assembler include :: BC_PUSH_RA_AF
  *PUSH* from array *RA* *A*​rray *F*​ield indexed by RAI to evlstk
  stack -> (RA),RAI :: stack
- [[file:vm-interpreter.rkt::752][RET]] :: $33  stack [cell paramN, ... cell param1, cell param0] -> []
  - racket require :: (require (only-in "vm-interpreter.rkt" RET))
  - assembler include :: BC_RET
  stack [cell paramN, ... cell param1, cell param0] -> []
- [[file:vm-interpreter.rkt::3034][SET_AF_0]] :: $b1  *SET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_0))
  - assembler include :: BC_SET_AF_0
  *SET* *A*​rray *F*​ield 0
  stack: [array-ptr] :: [value] -> [cell@0 of array]
- [[file:vm-interpreter.rkt::3037][SET_AF_1]] :: $b3  *SET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_1))
  - assembler include :: BC_SET_AF_1
  *SET* *A*​rray *F*​ield 1
  stack: [array-ptr] :: [value] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3040][SET_AF_2]] :: $b5  *SET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_2))
  - assembler include :: BC_SET_AF_2
  *SET* *A*​rray *F*​ield 2
  stack: [array-ptr] :: [value] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3043][SET_AF_3]] :: $b7  *SET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_3))
  - assembler include :: BC_SET_AF_3
  *SET* *A*​rray *F*​ield 3
  stack: [array-ptr] :: [value] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::3089][SET_RA_AF_0]] :: $c9  *SET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_0))
  - assembler include :: BC_SET_RA_AF_0
  *SET* *A*​rray *F*​ield 0
  stack: [array-ptr] :: [value] -> [cell@0 of array]
- [[file:vm-interpreter.rkt::3092][SET_RA_AF_1]] :: $cb  *SET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_1))
  - assembler include :: BC_SET_RA_AF_1
  *SET* *A*​rray *F*​ield 1
  stack: [array-ptr] :: [value] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3095][SET_RA_AF_2]] :: $cd  *SET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_2))
  - assembler include :: BC_SET_RA_AF_2
  *SET* *A*​rray *F*​ield 2
  stack: [array-ptr] :: [value] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3098][SET_RA_AF_3]] :: $cf  *SET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_3))
  - assembler include :: BC_SET_RA_AF_3
  *SET* *A*​rray *F*​ield 3
  stack: [array-ptr] :: [value] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::1538][SWAP]] :: $03  swap tos with tos-1
  - racket require :: (require (only-in "vm-interpreter.rkt" SWAP))
  - assembler include :: BC_SWAP
  swap tos with tos-1
- [[file:vm-interpreter.rkt::2645][SWAP_RA_RB]] :: $45  swap array register RA with RB
  - racket require :: (require (only-in "vm-interpreter.rkt" SWAP_RA_RB))
  - assembler include :: BC_SWAP_RA_RB
  swap array register RA with RB
- [[file:vm-interpreter.rkt::2170][T_P_BRA]] :: $0c  *T*​rue *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" T_P_BRA))
  - assembler include :: BC_T_P_BRA
  *T*​rue *P*​redicate *BRA*​nch
  len: 2
- [[file:vm-interpreter.rkt::1861][T_P_RET]] :: $0b  *T*​rue *P*​redicate *RET*​urn
  - racket require :: (require (only-in "vm-interpreter.rkt" T_P_RET))
  - assembler include :: BC_T_P_RET
  *T*​rue *P*​redicate *RET*​urn
  len: 1
- [[file:vm-interpreter.rkt::393][TAIL_CALL]] :: $35  stack [new-paramN .. new-param0, ..., original-paramN ... original-param0] -> [new-paramN .. new-param0]
  - racket require :: (require (only-in "vm-interpreter.rkt" TAIL_CALL))
  - assembler include :: BC_TAIL_CALL
  stack [new-paramN .. new-param0, ..., original-paramN ... original-param0] -> [new-paramN .. new-param0]
- [[file:vm-interpreter.rkt::896][WRITE_L0]] :: $81  *WRITE* *L*​ocal *0* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L0))
  - assembler include :: BC_WRITE_L0
  *WRITE* *L*​ocal *0* into rt
- [[file:vm-interpreter.rkt::898][WRITE_L1]] :: $83  *WRITE* *L*​ocal *1* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L1))
  - assembler include :: BC_WRITE_L1
  *WRITE* *L*​ocal *1* into rt
- [[file:vm-interpreter.rkt::900][WRITE_L2]] :: $85  *WRITE* *L*​ocal *2* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L2))
  - assembler include :: BC_WRITE_L2
  *WRITE* *L*​ocal *2* into rt
- [[file:vm-interpreter.rkt::902][WRITE_L3]] :: $87  *WRITE* *L*​ocal *3* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L3))
  - assembler include :: BC_WRITE_L3
  *WRITE* *L*​ocal *3* into rt
- [[file:vm-interpreter.rkt::2994][WRITE_RA]] :: $55  *WRITE* *R*​egister *A* to stack
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_RA))
  - assembler include :: BC_WRITE_RA
  *WRITE* *R*​egister *A* to stack
- [[file:vm-interpreter.rkt::946][WRITE_TO_L0]] :: $91  *WRITE* *TO* *L*​ocal *0* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L0))
  - assembler include :: BC_WRITE_TO_L0
  *WRITE* *TO* *L*​ocal *0* from evlstk
- [[file:vm-interpreter.rkt::948][WRITE_TO_L1]] :: $93  *WRITE* *TO* *L*​ocal *1* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L1))
  - assembler include :: BC_WRITE_TO_L1
  *WRITE* *TO* *L*​ocal *1* from evlstk
- [[file:vm-interpreter.rkt::950][WRITE_TO_L2]] :: $95  *WRITE* *TO* *L*​ocal *2* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L2))
  - assembler include :: BC_WRITE_TO_L2
  *WRITE* *TO* *L*​ocal *2* from evlstk
- [[file:vm-interpreter.rkt::952][WRITE_TO_L3]] :: $97  *WRITE* *TO* *L*​ocal *3* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L3))
  - assembler include :: BC_WRITE_TO_L3
  *WRITE* *TO* *L*​ocal *3* from evlstk
- [[file:vm-interpreter.rkt::3157][WRITE_TO_RAI]] :: $51  *WRITE* top of evlstk byte *TO* *RA* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_RAI))
  - assembler include :: BC_WRITE_TO_RAI
  *WRITE* top of evlstk byte *TO* *RA* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::3168][WRITE_TO_RBI]] :: $53  *WRITE* top of evlstk byte *TO* *RB* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_RBI))
  - assembler include :: BC_WRITE_TO_RBI
  *WRITE* top of evlstk byte *TO* *RB* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::3400][Z_P_BRA]] :: $1b  *Z*​ero *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_BRA))
  - assembler include :: BC_Z_P_BRA
  *Z*​ero *P*​redicate *BRA*​nch
  len: 2
- [[file:vm-interpreter.rkt::3299][Z_P_RET_POP_0]] :: $c1  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return without popping anything
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_0))
  - assembler include :: BC_Z_P_RET_POP_0
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return without popping anything
  len: 1
- [[file:vm-interpreter.rkt::3302][Z_P_RET_POP_1]] :: $c3  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 1 value from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_1))
  - assembler include :: BC_Z_P_RET_POP_1
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 1 value from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3305][Z_P_RET_POP_2]] :: $c5  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 2 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_2))
  - assembler include :: BC_Z_P_RET_POP_2
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 2 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3308][Z_P_RET_POP_3]] :: $c7  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 3 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_3))
  - assembler include :: BC_Z_P_RET_POP_3
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 3 values from evlstk
  len: 1
* byte codes (by group)
** cell_array
- [[file:vm-interpreter.rkt::3120][ALLOC_ARA]] :: $4c  *ALLOC*​ate cell *A*​rray into *RA* and pops the byte size off the stack
  - racket require :: (require (only-in "vm-interpreter.rkt" ALLOC_ARA))
  - assembler include :: BC_ALLOC_ARA
  *ALLOC*​ate cell *A*​rray into *RA* and pops the byte size off the stack
  stack: <byte-size> -> -
  len: 1
- [[file:vm-interpreter.rkt::3136][BINC_RAI]] :: $49  *B*​yte *INC*​rement *RA* *I*​ndex register
  - racket require :: (require (only-in "vm-interpreter.rkt" BINC_RAI))
  - assembler include :: BC_BINC_RAI
  *B*​yte *INC*​rement *RA* *I*​ndex register
- [[file:vm-interpreter.rkt::3179][DEC_RAI]] :: $52  *DEC*​rement *RA* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" DEC_RAI))
  - assembler include :: BC_DEC_RAI
  *DEC*​rement *RA* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::3022][GET_AF_0]] :: $b0  *GET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_0))
  - assembler include :: BC_GET_AF_0
  *GET* *A*​rray *F*​ield 0
  stack: [array-ptr] -> [cell@0 of array]  (replace tos with value from array)
- [[file:vm-interpreter.rkt::3025][GET_AF_1]] :: $b2  *GET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_1))
  - assembler include :: BC_GET_AF_1
  *GET* *A*​rray *F*​ield 1
  stack: [array-ptr] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3028][GET_AF_2]] :: $b4  *GET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_2))
  - assembler include :: BC_GET_AF_2
  *GET* *A*​rray *F*​ield 2
  stack: [array-ptr] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3031][GET_AF_3]] :: $b6  *GET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_AF_3))
  - assembler include :: BC_GET_AF_3
  *GET* *A*​rray *F*​ield 3
  stack: [array-ptr] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::3077][GET_RA_AF_0]] :: $c8  *GET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_0))
  - assembler include :: BC_GET_RA_AF_0
  *GET* *A*​rray *F*​ield 0
  stack: [array-ptr] -> [cell@0 of array]
- [[file:vm-interpreter.rkt::3080][GET_RA_AF_1]] :: $ca  *GET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_1))
  - assembler include :: BC_GET_RA_AF_1
  *GET* *A*​rray *F*​ield 1
  stack: [array-ptr] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3083][GET_RA_AF_2]] :: $cc  *GET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_2))
  - assembler include :: BC_GET_RA_AF_2
  *GET* *A*​rray *F*​ield 2
  stack: [array-ptr] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3086][GET_RA_AF_3]] :: $ce  *GET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" GET_RA_AF_3))
  - assembler include :: BC_GET_RA_AF_3
  *GET* *A*​rray *F*​ield 3
  stack: [array-ptr] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::2837][POP_TO_AF]] :: $16  *POP* *TO* *A*​rray *F*​ield using the stack
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_AF))
  - assembler include :: BC_POP_TO_AF
  *POP* *TO* *A*​rray *F*​ield using the stack
  len: 1
  stack: index(byte) :: cell-ptr->cell-array  :: value (cell)
  ->     []
         cell-array @ index = value
  op = array-idx, stack [cell- array-ptr-] -> []
- [[file:vm-interpreter.rkt::2655][POP_TO_RA]] :: $4b  *POP* top of evlstk *TO* *RA*, setting RAI=0
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RA))
  - assembler include :: BC_POP_TO_RA
  *POP* top of evlstk *TO* *RA*, setting RAI=0
  len: 1
- [[file:vm-interpreter.rkt::2825][POP_TO_RA_AF]] :: $4e  *POP* top of evlstk *TO* *RA* *A*​rray *F*​ield
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RA_AF))
  - assembler include :: BC_POP_TO_RA_AF
  *POP* top of evlstk *TO* *RA* *A*​rray *F*​ield
  len: 1
- [[file:vm-interpreter.rkt::3145][POP_TO_RAI]] :: $4f  *POP* top of evlstk byte *TO* *RA* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RAI))
  - assembler include :: BC_POP_TO_RAI
  *POP* top of evlstk byte *TO* *RA* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::2659][POP_TO_RB]] :: $46  *POP* top of evlstk *TO* *RB*, setting RAI=0
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_RB))
  - assembler include :: BC_POP_TO_RB
  *POP* top of evlstk *TO* *RB*, setting RAI=0
  len: 1
- [[file:vm-interpreter.rkt::2884][PUSH_AF]] :: $15  stack: index (byte) :: cell-ptr -> cell-array
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_AF))
  - assembler include :: BC_PUSH_AF
  stack: index (byte) :: cell-ptr -> cell-array
  ->     value (cell)
  op = field-idx, stack [array-ref] -> [cell-]
- [[file:vm-interpreter.rkt::2997][PUSH_RA]] :: $47  *PUSH* *R*​egister *A* to stack
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_RA))
  - assembler include :: BC_PUSH_RA
  *PUSH* *R*​egister *A* to stack
- [[file:vm-interpreter.rkt::3009][PUSH_RA_AF]] :: $4d  *PUSH* from array *RA* *A*​rray *F*​ield indexed by RAI to evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_RA_AF))
  - assembler include :: BC_PUSH_RA_AF
  *PUSH* from array *RA* *A*​rray *F*​ield indexed by RAI to evlstk
  stack -> (RA),RAI :: stack
- [[file:vm-interpreter.rkt::3034][SET_AF_0]] :: $b1  *SET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_0))
  - assembler include :: BC_SET_AF_0
  *SET* *A*​rray *F*​ield 0
  stack: [array-ptr] :: [value] -> [cell@0 of array]
- [[file:vm-interpreter.rkt::3037][SET_AF_1]] :: $b3  *SET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_1))
  - assembler include :: BC_SET_AF_1
  *SET* *A*​rray *F*​ield 1
  stack: [array-ptr] :: [value] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3040][SET_AF_2]] :: $b5  *SET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_2))
  - assembler include :: BC_SET_AF_2
  *SET* *A*​rray *F*​ield 2
  stack: [array-ptr] :: [value] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3043][SET_AF_3]] :: $b7  *SET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_AF_3))
  - assembler include :: BC_SET_AF_3
  *SET* *A*​rray *F*​ield 3
  stack: [array-ptr] :: [value] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::3089][SET_RA_AF_0]] :: $c9  *SET* *A*​rray *F*​ield 0
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_0))
  - assembler include :: BC_SET_RA_AF_0
  *SET* *A*​rray *F*​ield 0
  stack: [array-ptr] :: [value] -> [cell@0 of array]
- [[file:vm-interpreter.rkt::3092][SET_RA_AF_1]] :: $cb  *SET* *A*​rray *F*​ield 1
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_1))
  - assembler include :: BC_SET_RA_AF_1
  *SET* *A*​rray *F*​ield 1
  stack: [array-ptr] :: [value] -> [cell@1 of array]
- [[file:vm-interpreter.rkt::3095][SET_RA_AF_2]] :: $cd  *SET* *A*​rray *F*​ield 2
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_2))
  - assembler include :: BC_SET_RA_AF_2
  *SET* *A*​rray *F*​ield 2
  stack: [array-ptr] :: [value] -> [cell@2 of array]
- [[file:vm-interpreter.rkt::3098][SET_RA_AF_3]] :: $cf  *SET* *A*​rray *F*​ield 3
  - racket require :: (require (only-in "vm-interpreter.rkt" SET_RA_AF_3))
  - assembler include :: BC_SET_RA_AF_3
  *SET* *A*​rray *F*​ield 3
  stack: [array-ptr] :: [value] -> [cell@3 of array]
- [[file:vm-interpreter.rkt::2994][WRITE_RA]] :: $55  *WRITE* *R*​egister *A* to stack
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_RA))
  - assembler include :: BC_WRITE_RA
  *WRITE* *R*​egister *A* to stack
- [[file:vm-interpreter.rkt::3157][WRITE_TO_RAI]] :: $51  *WRITE* top of evlstk byte *TO* *RA* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_RAI))
  - assembler include :: BC_WRITE_TO_RAI
  *WRITE* top of evlstk byte *TO* *RA* *I*​ndex
  len: 1
- [[file:vm-interpreter.rkt::3168][WRITE_TO_RBI]] :: $53  *WRITE* top of evlstk byte *TO* *RB* *I*​ndex
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_RBI))
  - assembler include :: BC_WRITE_TO_RBI
  *WRITE* top of evlstk byte *TO* *RB* *I*​ndex
  len: 1
** array
- [[file:vm-interpreter.rkt::2645][SWAP_RA_RB]] :: $45  swap array register RA with RB
  - racket require :: (require (only-in "vm-interpreter.rkt" SWAP_RA_RB))
  - assembler include :: BC_SWAP_RA_RB
  swap array register RA with RB
** gc
- [[file:vm-interpreter.rkt::2555][GC_FL]] :: $03  garbage collect the freelist
  - racket require :: (require (only-in "vm-interpreter.rkt" GC_FL))
  - assembler include :: BC_GC_FL
  garbage collect the freelist
  len: 2 (extended)
  extended
** byte
- [[file:vm-interpreter.rkt::3277][BINC]] :: $1c  *B*​yte *INC*​rement, increment byte RT (no checks)
  - racket require :: (require (only-in "vm-interpreter.rkt" BINC))
  - assembler include :: BC_BINC
  *B*​yte *INC*​rement, increment byte RT (no checks)
  len: 1
- [[file:vm-interpreter.rkt::3255][BDEC]] :: $1a  *B*​yte *DEC*​rement, increment byte RT (no checks)
  - racket require :: (require (only-in "vm-interpreter.rkt" BDEC))
  - assembler include :: BC_BDEC
  *B*​yte *DEC*​rement, increment byte RT (no checks)
  len: 1
- [[file:vm-interpreter.rkt::3228][BADD]] :: $23  *B*​yte *ADD* top two values on stack (no checks)
  - racket require :: (require (only-in "vm-interpreter.rkt" BADD))
  - assembler include :: BC_BADD
  *B*​yte *ADD* top two values on stack (no checks)
  len: 1
- [[file:vm-interpreter.rkt::1634][BSHR]] :: $27  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" BSHR))
  - assembler include :: BC_BSHR

** cell_pair
- [[file:vm-interpreter.rkt::2726][CDDR]] :: $ae  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CDDR))
  - assembler include :: BC_CDDR
  len: 1
- [[file:vm-interpreter.rkt::2724][CDAR]] :: $ac  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CDAR))
  - assembler include :: BC_CDAR
  len: 1
- [[file:vm-interpreter.rkt::2722][CADR]] :: $aa  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CADR))
  - assembler include :: BC_CADR
  len: 1
- [[file:vm-interpreter.rkt::2720][CAAR]] :: $a8  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" CAAR))
  - assembler include :: BC_CAAR
  len: 1
- [[file:vm-interpreter.rkt::1513][CDR]] :: $41  stack [cell-list-ptr] -> [cell-list-ptr cdr of list pointed at]
  - racket require :: (require (only-in "vm-interpreter.rkt" CDR))
  - assembler include :: BC_CDR
  stack [cell-list-ptr] -> [cell-list-ptr cdr of list pointed at]
- [[file:vm-interpreter.rkt::1488][CAR]] :: $43  stack [cell-list-ptr] -> [cell- car of list pointed at]
  - racket require :: (require (only-in "vm-interpreter.rkt" CAR))
  - assembler include :: BC_CAR
  stack [cell-list-ptr] -> [cell- car of list pointed at]
- [[file:vm-interpreter.rkt::1465][CONS]] :: $42  stack [cell- car, cell-list-ptr cdr] -> stack [cell-list-ptr new-list]
  - racket require :: (require (only-in "vm-interpreter.rkt" CONS))
  - assembler include :: BC_CONS
  stack [cell- car, cell-list-ptr cdr] -> stack [cell-list-ptr new-list]
- [[file:vm-interpreter.rkt::1456][COONS]] :: $44  execute two CONS in a row
  - racket require :: (require (only-in "vm-interpreter.rkt" COONS))
  - assembler include :: BC_COONS
  execute two CONS in a row
** predicates
- [[file:vm-interpreter.rkt::2528][I_Z_P]] :: $22  *I*​nt *Z*​ero *P*​redicate
  - racket require :: (require (only-in "vm-interpreter.rkt" I_Z_P))
  - assembler include :: BC_I_Z_P
  *I*​nt *Z*​ero *P*​redicate
  len: 1
- [[file:vm-interpreter.rkt::2493][CELL_EQ_P]] :: $12  *CELL* *EQ*​ual *P*​redicate
  - racket require :: (require (only-in "vm-interpreter.rkt" CELL_EQ_P))
  - assembler include :: BC_CELL_EQ_P
  *CELL* *EQ*​ual *P*​redicate
  len: 1
- [[file:vm-interpreter.rkt::2341][CONS_PAIR_P]] :: $0a  *CONS* *PAIR* *P*​redicate
  - racket require :: (require (only-in "vm-interpreter.rkt" CONS_PAIR_P))
  - assembler include :: BC_CONS_PAIR_P
  *CONS* *PAIR* *P*​redicate
  len: 1
- [[file:vm-interpreter.rkt::1803][INT_P]] :: $07  is top of evlstk an *INT*​eger (*P*​redicate)?
  - racket require :: (require (only-in "vm-interpreter.rkt" INT_P))
  - assembler include :: BC_INT_P
  is top of evlstk an *INT*​eger (*P*​redicate)?
- [[file:vm-interpreter.rkt::1704][I_GT_P]] :: $63  *I*​nt *G*​reater *T*​han *P*​redicates
  - racket require :: (require (only-in "vm-interpreter.rkt" I_GT_P))
  - assembler include :: BC_I_GT_P
  *I*​nt *G*​reater *T*​han *P*​redicates
- [[file:vm-interpreter.rkt::1646][B_GE_P]] :: $26  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" B_GE_P))
  - assembler include :: BC_B_GE_P

- [[file:vm-interpreter.rkt::1617][B_LT_P]] :: $25  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" B_LT_P))
  - assembler include :: BC_B_LT_P

- [[file:vm-interpreter.rkt::1559][B_GT_P]] :: $24  no doc
  - racket require :: (require (only-in "vm-interpreter.rkt" B_GT_P))
  - assembler include :: BC_B_GT_P

- [[file:vm-interpreter.rkt::1419][NIL_P]] :: $21  stack [cell-list-ptr] -> [cell-boolean]
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P))
  - assembler include :: BC_NIL_P
  stack [cell-list-ptr] -> [cell-boolean]
** int
- [[file:vm-interpreter.rkt::2452][IMAX]] :: $01  *I*​nt *MAX*​imum, return the maximum of two ints
  - racket require :: (require (only-in "vm-interpreter.rkt" IMAX))
  - assembler include :: BC_IMAX
  *I*​nt *MAX*​imum, return the maximum of two ints
  len: 2 (extended)
  extended
- [[file:vm-interpreter.rkt::2385][IINC]] :: $02  *I*​nt *INC*​rement
  - racket require :: (require (only-in "vm-interpreter.rkt" IINC))
  - assembler include :: BC_IINC
  *I*​nt *INC*​rement
  len: 2 (extended)
  extended (could be mapped to regular byte code, if needed very often!)
- [[file:vm-interpreter.rkt::1344][ISUB]] :: $61  stack [cell-int a, cell-int b] -> [difference]
  - racket require :: (require (only-in "vm-interpreter.rkt" ISUB))
  - assembler include :: BC_ISUB
  stack [cell-int a, cell-int b] -> [difference]
- [[file:vm-interpreter.rkt::1269][IADD]] :: $62  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" IADD))
  - assembler include :: BC_IADD
  len: 1
  stack [cell-int a, cell-int b] -> [sum]
** stack
- [[file:vm-interpreter.rkt::2663][POP]] :: $11  len: 1
  - racket require :: (require (only-in "vm-interpreter.rkt" POP))
  - assembler include :: BC_POP
  len: 1
- [[file:vm-interpreter.rkt::2482][DUP]] :: $0f  *DUP*​licate top of stack
  - racket require :: (require (only-in "vm-interpreter.rkt" DUP))
  - assembler include :: BC_DUP
  *DUP*​licate top of stack
  len: 1
- [[file:vm-interpreter.rkt::2364][PUSH_NIL]] :: $09  *PUSH* *NIL* to evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_NIL))
  - assembler include :: BC_PUSH_NIL
  *PUSH* *NIL* to evlstk
  len: 1
  stack: [] -> [NIL]
- [[file:vm-interpreter.rkt::1538][SWAP]] :: $03  swap tos with tos-1
  - racket require :: (require (only-in "vm-interpreter.rkt" SWAP))
  - assembler include :: BC_SWAP
  swap tos with tos-1
- [[file:vm-interpreter.rkt::1243][PUSH_I]] :: $06  *PUSH* *I*​nt onto evlstk, op1=low byte op2=high byte, stack [] -> [cell-int]
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I))
  - assembler include :: BC_PUSH_I
  *PUSH* *I*​nt onto evlstk, op1=low byte op2=high byte, stack [] -> [cell-int]
  len: 3
- [[file:vm-interpreter.rkt::1197][PUSH_IM1]] :: $bb  *PUSH* *I*​nt *-1* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_IM1))
  - assembler include :: BC_PUSH_IM1
  *PUSH* *I*​nt *-1* onto evlstk
- [[file:vm-interpreter.rkt::1195][PUSH_I2]] :: $ba  *PUSH* *I*​nt *2* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I2))
  - assembler include :: BC_PUSH_I2
  *PUSH* *I*​nt *2* onto evlstk
- [[file:vm-interpreter.rkt::1193][PUSH_I1]] :: $b9  *PUSH* *I*​nt *1* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I1))
  - assembler include :: BC_PUSH_I1
  *PUSH* *I*​nt *1* onto evlstk
- [[file:vm-interpreter.rkt::1191][PUSH_I0]] :: $b8  *PUSH* *I*​nt *0* onto evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_I0))
  - assembler include :: BC_PUSH_I0
  *PUSH* *I*​nt *0* onto evlstk
- [[file:vm-interpreter.rkt::952][WRITE_TO_L3]] :: $97  *WRITE* *TO* *L*​ocal *3* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L3))
  - assembler include :: BC_WRITE_TO_L3
  *WRITE* *TO* *L*​ocal *3* from evlstk
- [[file:vm-interpreter.rkt::950][WRITE_TO_L2]] :: $95  *WRITE* *TO* *L*​ocal *2* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L2))
  - assembler include :: BC_WRITE_TO_L2
  *WRITE* *TO* *L*​ocal *2* from evlstk
- [[file:vm-interpreter.rkt::948][WRITE_TO_L1]] :: $93  *WRITE* *TO* *L*​ocal *1* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L1))
  - assembler include :: BC_WRITE_TO_L1
  *WRITE* *TO* *L*​ocal *1* from evlstk
- [[file:vm-interpreter.rkt::946][WRITE_TO_L0]] :: $91  *WRITE* *TO* *L*​ocal *0* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_TO_L0))
  - assembler include :: BC_WRITE_TO_L0
  *WRITE* *TO* *L*​ocal *0* from evlstk
- [[file:vm-interpreter.rkt::944][POP_TO_L3]] :: $96  *POP* *TO* *L*​ocal *3* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L3))
  - assembler include :: BC_POP_TO_L3
  *POP* *TO* *L*​ocal *3* from evlstk
- [[file:vm-interpreter.rkt::942][POP_TO_L2]] :: $94  *POP* *TO* *L*​ocal *2* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L2))
  - assembler include :: BC_POP_TO_L2
  *POP* *TO* *L*​ocal *2* from evlstk
- [[file:vm-interpreter.rkt::940][POP_TO_L1]] :: $92  *POP* *TO* *L*​ocal *1* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L1))
  - assembler include :: BC_POP_TO_L1
  *POP* *TO* *L*​ocal *1* from evlstk
- [[file:vm-interpreter.rkt::938][POP_TO_L0]] :: $90  *POP* *TO* *L*​ocal *0* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" POP_TO_L0))
  - assembler include :: BC_POP_TO_L0
  *POP* *TO* *L*​ocal *0* from evlstk
- [[file:vm-interpreter.rkt::902][WRITE_L3]] :: $87  *WRITE* *L*​ocal *3* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L3))
  - assembler include :: BC_WRITE_L3
  *WRITE* *L*​ocal *3* into rt
- [[file:vm-interpreter.rkt::900][WRITE_L2]] :: $85  *WRITE* *L*​ocal *2* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L2))
  - assembler include :: BC_WRITE_L2
  *WRITE* *L*​ocal *2* into rt
- [[file:vm-interpreter.rkt::898][WRITE_L1]] :: $83  *WRITE* *L*​ocal *1* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L1))
  - assembler include :: BC_WRITE_L1
  *WRITE* *L*​ocal *1* into rt
- [[file:vm-interpreter.rkt::896][WRITE_L0]] :: $81  *WRITE* *L*​ocal *0* into rt
  - racket require :: (require (only-in "vm-interpreter.rkt" WRITE_L0))
  - assembler include :: BC_WRITE_L0
  *WRITE* *L*​ocal *0* into rt
- [[file:vm-interpreter.rkt::893][PUSH_L3]] :: $86  *PUSH* *L*​ocal *3* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L3))
  - assembler include :: BC_PUSH_L3
  *PUSH* *L*​ocal *3* on evlstk
- [[file:vm-interpreter.rkt::891][PUSH_L2]] :: $84  *PUSH* *L*​ocal *2* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L2))
  - assembler include :: BC_PUSH_L2
  *PUSH* *L*​ocal *2* on evlstk
- [[file:vm-interpreter.rkt::889][PUSH_L1]] :: $82  *PUSH* *L*​ocal *1* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L1))
  - assembler include :: BC_PUSH_L1
  *PUSH* *L*​ocal *1* on evlstk
- [[file:vm-interpreter.rkt::887][PUSH_L0]] :: $80  *PUSH* *L*​ocal *0* on evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L0))
  - assembler include :: BC_PUSH_L0
  *PUSH* *L*​ocal *0* on evlstk
- [[file:vm-interpreter.rkt::851][PUSH_L3_CDR]] :: $a7  *PUSH* *L*​ocal *3* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L3_CDR))
  - assembler include :: BC_PUSH_L3_CDR
  *PUSH* *L*​ocal *3* and *CDR*
- [[file:vm-interpreter.rkt::849][PUSH_L2_CDR]] :: $a5  *PUSH* *L*​ocal *2* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L2_CDR))
  - assembler include :: BC_PUSH_L2_CDR
  *PUSH* *L*​ocal *2* and *CDR*
- [[file:vm-interpreter.rkt::847][PUSH_L1_CDR]] :: $a3  *PUSH* *L*​ocal *1* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L1_CDR))
  - assembler include :: BC_PUSH_L1_CDR
  *PUSH* *L*​ocal *1* and *CDR*
- [[file:vm-interpreter.rkt::845][PUSH_L0_CDR]] :: $a1  *PUSH* *L*​ocal *0* and *CDR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L0_CDR))
  - assembler include :: BC_PUSH_L0_CDR
  *PUSH* *L*​ocal *0* and *CDR*
- [[file:vm-interpreter.rkt::842][PUSH_L3_CAR]] :: $a6  *PUSH* *L*​ocal *3* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L3_CAR))
  - assembler include :: BC_PUSH_L3_CAR
  *PUSH* *L*​ocal *3* and *CAR*
- [[file:vm-interpreter.rkt::840][PUSH_L2_CAR]] :: $a4  *PUSH* *L*​ocal *2* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L2_CAR))
  - assembler include :: BC_PUSH_L2_CAR
  *PUSH* *L*​ocal *2* and *CAR*
- [[file:vm-interpreter.rkt::838][PUSH_L1_CAR]] :: $a2  *PUSH* *L*​ocal *1* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L1_CAR))
  - assembler include :: BC_PUSH_L1_CAR
  *PUSH* *L*​ocal *1* and *CAR*
- [[file:vm-interpreter.rkt::836][PUSH_L0_CAR]] :: $a0  *PUSH* *L*​ocal *0* and *CAR*
  - racket require :: (require (only-in "vm-interpreter.rkt" PUSH_L0_CAR))
  - assembler include :: BC_PUSH_L0_CAR
  *PUSH* *L*​ocal *0* and *CAR*
** misc
- [[file:vm-interpreter.rkt::3189][NATIVE]] :: $4a  following bytes are native 6510 commands, JSR RETURN_TO_BC ends this sequence
  - racket require :: (require (only-in "vm-interpreter.rkt" NATIVE))
  - assembler include :: BC_NATIVE
  following bytes are native 6510 commands, JSR RETURN_TO_BC ends this sequence
  len: 1
- [[file:vm-interpreter.rkt::2585][EXT]] :: $04  extension byte code, the next byte is the actual command (decoded from the extended byte code jump table)
  - racket require :: (require (only-in "vm-interpreter.rkt" EXT))
  - assembler include :: BC_EXT
  extension byte code, the next byte is the actual command (decoded from the extended byte code jump table)
- [[file:vm-interpreter.rkt::795][BREAK]] :: $02  collision with 6510 BRK code
  - racket require :: (require (only-in "vm-interpreter.rkt" BREAK))
  - assembler include :: BC_BREAK
  collision with 6510 BRK code
** flow
- [[file:vm-interpreter.rkt::3445][DEC_RBI_NZ_P_BRA]] :: $54  *DEC*​rement *RBI* and *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" DEC_RBI_NZ_P_BRA))
  - assembler include :: BC_DEC_RBI_NZ_P_BRA
  *DEC*​rement *RBI* and *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  len: 2
- [[file:vm-interpreter.rkt::3421][NZ_P_BRA]] :: $1d  *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_BRA))
  - assembler include :: BC_NZ_P_BRA
  *N*​ot *Z*​ero *P*​redicate *BRA*​nch
  on branch, it does no pop
  on fall through, it removes the 0 from the stack
  len: 2
- [[file:vm-interpreter.rkt::3400][Z_P_BRA]] :: $1b  *Z*​ero *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_BRA))
  - assembler include :: BC_Z_P_BRA
  *Z*​ero *P*​redicate *BRA*​nch
  len: 2
- [[file:vm-interpreter.rkt::2170][T_P_BRA]] :: $0c  *T*​rue *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" T_P_BRA))
  - assembler include :: BC_T_P_BRA
  *T*​rue *P*​redicate *BRA*​nch
  len: 2
- [[file:vm-interpreter.rkt::2037][F_P_BRA]] :: $0d  *F*​alse *P*​redicate *BRA*​nch
  - racket require :: (require (only-in "vm-interpreter.rkt" F_P_BRA))
  - assembler include :: BC_F_P_BRA
  *F*​alse *P*​redicate *BRA*​nch
  len: 1
- [[file:vm-interpreter.rkt::1880][GOTO]] :: $32  goto relative by byte following in code
  - racket require :: (require (only-in "vm-interpreter.rkt" GOTO))
  - assembler include :: BC_GOTO
  goto relative by byte following in code
  len: 2
  op = relative offset
- [[file:vm-interpreter.rkt::509][CALL]] :: $34  stack [int-cell: function index, cell paramN, ... cell param1, cell param0] -> [cell paramN, ... cell param1, cell param0]
  - racket require :: (require (only-in "vm-interpreter.rkt" CALL))
  - assembler include :: BC_CALL
  stack [int-cell: function index, cell paramN, ... cell param1, cell param0] -> [cell paramN, ... cell param1, cell param0]
- [[file:vm-interpreter.rkt::393][TAIL_CALL]] :: $35  stack [new-paramN .. new-param0, ..., original-paramN ... original-param0] -> [new-paramN .. new-param0]
  - racket require :: (require (only-in "vm-interpreter.rkt" TAIL_CALL))
  - assembler include :: BC_TAIL_CALL
  stack [new-paramN .. new-param0, ..., original-paramN ... original-param0] -> [new-paramN .. new-param0]
** return
- [[file:vm-interpreter.rkt::3320][NZ_P_RET_POP_3]] :: $c6  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 3 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_3))
  - assembler include :: BC_NZ_P_RET_POP_3
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 3 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3317][NZ_P_RET_POP_2]] :: $c4  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 2 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_2))
  - assembler include :: BC_NZ_P_RET_POP_2
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 2 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3314][NZ_P_RET_POP_1]] :: $c2  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 1 value from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_1))
  - assembler include :: BC_NZ_P_RET_POP_1
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return, popping 1 value from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3311][NZ_P_RET_POP_0]] :: $c0  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return without popping anything
  - racket require :: (require (only-in "vm-interpreter.rkt" NZ_P_RET_POP_0))
  - assembler include :: BC_NZ_P_RET_POP_0
  *N*​ot *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt does hold byte != 0 or int != 0 return without popping anything
  len: 1
- [[file:vm-interpreter.rkt::3308][Z_P_RET_POP_3]] :: $c7  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 3 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_3))
  - assembler include :: BC_Z_P_RET_POP_3
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 3 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3305][Z_P_RET_POP_2]] :: $c5  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 2 values from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_2))
  - assembler include :: BC_Z_P_RET_POP_2
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 2 values from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3302][Z_P_RET_POP_1]] :: $c3  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 1 value from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_1))
  - assembler include :: BC_Z_P_RET_POP_1
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return, popping 1 value from evlstk
  len: 1
- [[file:vm-interpreter.rkt::3299][Z_P_RET_POP_0]] :: $c1  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return without popping anything
  - racket require :: (require (only-in "vm-interpreter.rkt" Z_P_RET_POP_0))
  - assembler include :: BC_Z_P_RET_POP_0
  *Z*​ero *P*​redicate then *RET*​urn and *POP*, if rt holds byte = 0 or int = 0 return without popping anything
  len: 1
- [[file:vm-interpreter.rkt::1861][T_P_RET]] :: $0b  *T*​rue *P*​redicate *RET*​urn
  - racket require :: (require (only-in "vm-interpreter.rkt" T_P_RET))
  - assembler include :: BC_T_P_RET
  *T*​rue *P*​redicate *RET*​urn
  len: 1
- [[file:vm-interpreter.rkt::1844][F_P_RET]] :: $0e  *F*​alse *P*​redicate *RET*​urn
  - racket require :: (require (only-in "vm-interpreter.rkt" F_P_RET))
  - assembler include :: BC_F_P_RET
  *F*​alse *P*​redicate *RET*​urn
- [[file:vm-interpreter.rkt::1827][F_P_RET_F]] :: $13  *F*​alse *P*​redicate *RET*​urn *F*​alse
  - racket require :: (require (only-in "vm-interpreter.rkt" F_P_RET_F))
  - assembler include :: BC_F_P_RET_F
  *F*​alse *P*​redicate *RET*​urn *F*​alse
- [[file:vm-interpreter.rkt::752][RET]] :: $33  stack [cell paramN, ... cell param1, cell param0] -> []
  - racket require :: (require (only-in "vm-interpreter.rkt" RET))
  - assembler include :: BC_RET
  stack [cell paramN, ... cell param1, cell param0] -> []
- [[file:vm-interpreter.rkt::261][NIL_P_RET_L0_POP_4]] :: $9e  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *4* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_4))
  - assembler include :: BC_NIL_P_RET_L0_POP_4
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *4* from evlstk
- [[file:vm-interpreter.rkt::259][NIL_P_RET_L0_POP_3]] :: $9c  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *3* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_3))
  - assembler include :: BC_NIL_P_RET_L0_POP_3
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *3* from evlstk
- [[file:vm-interpreter.rkt::257][NIL_P_RET_L0_POP_2]] :: $9a  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *2* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_2))
  - assembler include :: BC_NIL_P_RET_L0_POP_2
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *2* from evlstk
- [[file:vm-interpreter.rkt::255][NIL_P_RET_L0_POP_1]] :: $98  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *1* from evlstk
  - racket require :: (require (only-in "vm-interpreter.rkt" NIL_P_RET_L0_POP_1))
  - assembler include :: BC_NIL_P_RET_L0_POP_1
  *NIL* *P*​redicate *RET*​urn *L*​ocal *0* and *POP* *1* from evlstk
* - :noexport:
#+begin_src emacs-lisp
  ;; Local Variables:
  ;; org-pretty-entities-include-sub-superscripts: nil
  ;; End:
#+end_src
