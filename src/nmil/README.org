#+title: new minimal lisp for the c64

This document holds information about the *minimal lisp implementation*.

It is an byte code interpreting vm running on the c64.

_Primary design goals_
- very compact byte code  to allow as much code in memory as possible
- compact data            to allow as much data in memory as possible
- no moving gc            pointed to data stays where it is, no moving overhead
- decent execution speed

Extensions
- relocation of data / code to allow memory bank switching/extensions
  e.g. access through ptr->ptr->[rc=1]data
- swap in/out of code

* code organisation
bc-code
- bc-* :: functions coded with byte codes
  - bc-btree :: implementation of a persistent b-tree with values at leafs in pure bytecode
  - bc-fifo :: simple fifo implementation using basic records
  - bc-native :: example for mixing byte code and native 6510 assembler
  - bc-points :: example of a point structure
  - bc-prime-sieve :: example of the sieve of eratosthenes
vm-interpreter-bc (6510 implementation of ... related byte codes)
- arrays :: cell-arrays, native arrays
- atom-num :: int, byte
- branch :: control flow w/i functions
- call​_ret :: control flow to/from functions
- cell-pair :: lists and cell-pairs
- compare :: producing booleans (similar to predicates)
- ext :: command extensions (multibyte byte codes)
- misc :: miscellaneous functions like /gc/ /break/ etc.
- native :: interfacing native 6510 code
- pop_​local :: popping cells into locals
- predicates :: predicate functions producting booleans
- push_​const :: push number constants
- push_​local :: push cells from locals
- push_​n_​pop :: other push and pop functions
- test-utils :: utils for testing byte codes, reducing clutter in testing files
- vm-interpreter-bc :: meta module to make importing easier
root
- ast :: definition of the mil ast used by the compiler to generate code
- parse :: parser (basically racket syntax macros) for minimal lisp to generate ast
- rvm-function :: deprecated experiments with a register based virtual machine
- svm-compiler :: translates the ast into vm byte code (of a stack vm)
- svm-generator :: complete generator for byte code images that can be loaded/linked and then executed
- vm-* :: virtual machine support functions
  - vm-cell-array :: functions addressing cell-arrays
  - vm-cell-pairs :: functions about cell-pairs
  - vm-cell-stacks :: functions for generic cell-stacks, used for (call-stack) locals or evaluation stacks
  - vm-cells :: functions for generic cells
  - vm-m1-slots :: functions for slots of variable size
  - vm-native-array :: functions for native arrays (e.g. strings)
  - vm-pages :: functions for generic pages
  - vm-register-functions :: functions for copying, writing etc. of vm registers
  - vm-call-frame :: implementation of a call frame for vm calls
  - vm-interpreter :: 6510 implementation of a byte code interpreter (that should execute code generated by svm-generator, wip)
  - vm-memory-manager :: 6510 implementation of memory management (allocation, deallocation, reference counting ...)
  - vm-lists :: 6510 implementation of list primitives (car, cdr, cons)
  - vm-bc-* :: functions related to byte code of the virtual machine
    - vm-bc-ast :: byte code ast definitions
    - vm-bc-disassembler :: disassembler for byte code
    - vm-bc-resolver :: resolve unresolved reference in byte code ast

* ideas and next steps
[[file:~/repo/+1/6510/mil.readlist.org::*general ideas][general ideas]] for an overall view of the implementation project
current items to work on are found in [[file:~/repo/+1/6510/mil.readlist.org::*next][next]]

* major decisions
- stack vm :: experiments with register vm indicated potential execution speed benefits at the cost of code size. since code size is
  critical and stack vm tend to produce more compact code stack vm is chosen
- compact byte code :: to further reduce memory footprint of code, compact byte codes are used, combining operands and opcode in one byte
  for the most common use cases. this decision comes at the cost of lower execution speed, since decoding becomes more complex
- reference counting :: garbage collection is implemented using a reference counting strategy. execution of gc is interleaved with regular
  code and does no stop the world gc. circular data structures are not supported/allowed. no additional pointer indirection is needed since
  data is not copied but stays pinned at the same location. to reduce fragmentation, allocation buckets are used.
- allocation buckets :: memory objects are allocated in fixed sized buckets. supported bucket sizes are 16-bit cells, 32-bit cell-pairs (for
  lists), 6-byte float slots, array/structures/string of sizes 8, 16, (31, 63, 127) bytes. Each bucket is held in one page (256 byte)
  this prevents fragmentation but has the drawback of wasting bytes for elements not exactly the size of the bucket
- basic data types :: the following basic data types exist, fitting in one cell (16-bit)
  - byte/char/boolean
  - int
  - cell-pair-ptr :: special cell-ptr that identifies the targeted data as list (car-cell+cdr-cell)
  - ptr :: pointer to any complex data within a m1 page (first byte pointed to identifies complex structure w/ additional meta data)
  - no cell-ptr :: ptr to cells are emulated by using cell-pair-ptr and using just the car field
  - tagging is used to identify the type of a cell
  - pointers can be used directly (without masking etc.) <- no need to repeatedly do masking/unmasking of tag bits when operating on pointers (which happens very often)
- complex data types :: do not fit in a cell and thus must be pointed to
  - list (car-cell + cdr-cell) (4 bytes) :: cell-pair-ptr points always to these cell-pairs, this should speedup list processing
  - float (6 bytes) :: float as implemented by the c64 basic
  - array/structure :: structures are arrays of fields, each a single cell (can again be any cell, either simple or complex)
  - native-byte-array (n-bytes) :: used for strings and buffers etc. (extension for later), strings are native arrays of bytes
- byte code data :: this may have two different usages
  - removable :: code that may be dropped again and thus free data / pages
    this type could be handled by using the regular page buckets of the right size (with the drawback of waste)
  - resident :: code that will stay in memory (always) and cannot easily be deallocated?
    special page type that allows for variable size slots, minimizing waste, but with fragmentation

* open / debatable  decisions / questions
- exact organization of vm implemented in 6510, especially
  - what should reside in the zero page (value stack, locals, parameters ...)
  - how much copying to/fro the zero page should/must take place
  - how is memory exactly organized (free-list, allocation, deallocation, reference counting)
