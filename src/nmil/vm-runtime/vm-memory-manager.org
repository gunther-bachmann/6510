#+title: vm-memory-manager
* AI questions asked
** pointer tagging and memory bucket size questions
- Propose a pointer tagging on 16-bit pointers to identify two different types of pointers, one pointing to 32 bit values (car and cons
  cell) and one pointing to memory objects of distinct sizes up to 128 organized in a number of bucket sizes (e.g. up to 8 different
  ones). The buckets should be organized in pages of 256 bytes each, leaving some bytes for page type information and a reference count byte
  for each memory object. make sure to have as little waste as possible. since the 32 bit values are always 4 bytes, the last two bits in
  the pointer can be used as tag for these pointers, but the other type of pointer needs to be able to adress the different sizes of memory
  objects that should be possible without changing the ptr value itself. the tag should however give information about which type of pointer
  it is.
- adjust the pointer tagging theme using one bucket size per page. make sure the tagging does not need more than two bits of the
  pointer. make sure that one pointer type can point to memory objects of all bucket sizes while the other pointer type can still address 32
  bit values in memory. ensure that minimal bytes are wasted in padding and such.
- ensure that each memory object is reference counted and make sure that the bucket sizes are chosen such that on each 256 byte page, some
  bytes are used for reference counting the memory objects, the page type is kept and the number of actually allocated objects on that page
  are kept, too.
- Make the design even more compact. Reduce waste, make the reference count smaller. Expected reference counts stay mostly below 4.
- Consider using bucket sizes that are not multiples of 8 to reduce waste. Propose sizes that allow efficient pointer tagging while reducing
  the waste
- negative waste is not possible in this case, make sure waste is not negative! use even bucket sizes, which increase more slowly, not by
  powers of 2. make sure objects of these bucket sizes are addressible with tagged pointers without adjustung these pointers. additionally
  ensure to easily reach the reference count for each object by minimal adjustments to the tagged pointer.
* open tasks
** IMPLEMENT all pointers do now point to the following layout => access to cell, cell-pairs, cell-array etc. all change!
| offset | description      |
|--------+------------------|
|     +0 | reference count  |
|     +1 | slot type        |
|     +2 | start of payload |
|    ... | ...              |
- rc modifications
  rc = LDA (ZP_RZ),0
- slot type identification
  st = LDA (ZP_RT),1
  - slot type cell-pair
    0000 0000
  - slot type open
    001x xxxx 32 type reserved
  - slot type cell-array size 1..41
    01xx xxxx 0..63 <- lots of values not used (reserved?)
  - slot type native-array size 1..81
    1xxx xxxx 0..127 <- lots of values not used (reserved?)
- cell access
  lowbyte = LDA (ZP_RT),2
  highbyte = LDA (ZP_RT),3
- cell-pair access
  car lowbyte = LDA (ZP_RT),2
  car highbyte = LDA (ZP_RT),3
  cdr lowbyte = LDA (ZP_RT),4
  cdr highbyte = LDA (ZP_RT),5
- cell-array access
  @0 lowbyte = LDA (ZP_RT),2
  @0 highbyte = LDA (ZP_RT),3
  @1 lowbyte = LDA (ZP_RT),4
  @1 highbyte = LDA (ZP_RT),5
  @N lowbyte = LDA (ZP_RT), (N+1)>>1
  @N highbyte = LDA (ZP_RT), 1+ (N+1)>>1
- native-array access
  @0 byte = LDA (ZP_RT),2
  @1 byte = LDA (ZP_RT),3
  @N byte = LDA (ZP_RT), N+2
** plan to implement the changes
- remove all cell ptr related code,
  - put aliases for cell-pair ptr where necessary
- ~R0~ add zp register that has offset always 0 (for indexed page access)
- IDEA: use one pointer type only. write code to know places where optimizations are active because of this
  make a change of this decision to may be have two pointer types in the future possible without forgetting code
- TODO: change pointer tagging
  - pointer detection
  - pointer allocation through free list
    do not use separate page with first free slot per page
    -> allocation of page: add first free slot on page as head of free list
       put old head of free list into the last free slot on the page (that was previously initialized with 0)
       (what about local/global free list ptrs)
       each page can be analyzed separately by
    - looking at the number of allocated slots (page full?)
    - looking at the reference count of each slot (0 => must be part of the free list)
  - m1 page pointer
    - change allocation/initialization of page
** IMPLEMENT new pointer tagging
no more cell-ptr!
RT = 00 (low byte) is equivalent to RT is empty!
use new pointer tagging scheme :        examples (low, then high byte):
  0000 0000 = nil
  xxxx xxx0 = ptr to cplx cell          0000 001[0]    1100 1010   a ptr to the first slot of a m1 page at 1100 1010 ($CA)
  iiii ii11 = int-cell                  [1]000 10[11]  0001 1000   0218 (decimal 2*256+16+8 = 536) <- high byte comes first in this special int encoding
  0000 0001 = byte-cell (char)          [0000 0001]    0000 0001   01  <- payload is in high byte
  1xxx xx01 = reserved (or symbols, then up to 8192)
  01bb bb01 = bcds-cell (3 digits)      [01]10 01[01]  0110 0100   964 (digits 9, 6 and 4)
  001s ss01 = symbol (1024)             [001]1 00[01]  0010 0110   symbol #550 (512+32+4+2)
  0001 xx01 = reserved

  changes:
  - no more cell ptr, no more ptr to cell-pairs, just ptr->complex cells, references to cells are kept within a cell-pair (wasting one slot
    for this rare case), references to cell-pairs are kept in arrays allocating 6 bytes (1 RC, 1 CPLX-Type, 4 Payload), wasting 1 byte each
    but with big saving on runtime complexity and code
  - int now ends on 11 to allow for easy arithmetic functions
  - byte has other tag
  - bcds cell  (new, optional)
  - symbol (new, option)
#+begin_src asm
  ;; check for pointer
          LSR A
          BCS NO_POINTER
          ;; (BCC) POINTER

  ;; check for int-cell
          AND !$03
          CMP !$03 ; EOR !$03
          BEQ IS_INT_CELL

  ;; check for byte-cell
          CMP !$01 ;; CMP !TAG_BYTE_BYTE_CELL
          BEQ IS_BYTE_CELL

  ;; if int or byte: check 0
          LDA LB
          BNE IS_NOT_ZERO
          LDA HB
          AND #$fc
          BEQ IS_ZERO

  ;; if byte: check 0
          LDA LB
          BNE IS_NOT_ZERO
          ;; (BEQ) IS_ZERO
#+end_src
** IMPLEMENT think about fast array access for cell-pairs
- no need to copy things into RA or set index of RAI, since this will always be worked on on RT and the rest of the expression stack
- allocating new cell-pairs (array of size 2)
  allocate cplx slot (initializes RC=1, TYPE with param)
  (optional: write NIL into car- and into cdr-field)
- cell-pair operations
  CAR  = interpret RT as pointer to an array and fetch first cell (which is at offset 2)
  CDR  = interpret RT as pointer to an array and fetch second cell (which is at offset 4)
  CONS = create new array of size 6,
- GC   cell-pair arrays:
  - strategy: free fields starting from the end until freeing the first ptr,
    then put the remaining (partially-freed) array in a list (one for each size/type)
  - when allocating, run (partial) free on the partially freed array at head
    use now free array or an available slot on an allocated page
    before allocating new pages continue freeing existing partially-freed arrays
  => for cell-pair arrays:
     cdr cell is freed on first free
     car cell is freed on allocation
     => reuse is immediate after free, and free itself running in constant time, allocate is running in constant time, too
        reuse of large arrays may need more time when allocating partially-freed arrays
** IMPLEMENT idea: use arrays (2 elements) for lists, too?
=> only m1 pages
   ptr tag: xxxx xxx0
possible sizes (with little to no waste):
6  (/ 252 6)  => 42 slots (no waste) <- new and used for cell pairs [refcount, array-header, car-field-lb, car-field-hb, cdr-field-lb, cdr-field-hb]
8  (/ 252 8)  => 31 slots (4 waste)  [3  cells]
10            => 25 slots (2 waste)  [4  cells]
12 (/ 252 12) => 21 slots (no waste) [5  cells]
18 (/ 252 18) => 14 slots (no waste) [8  cells]
28 (/ 252 28) => 9  slots (no waste) [13 cells]
36 (/ 252 32) => 7  slots (no waste) [17 cells]
50            => 5  slots (1 waste)  [24 cells]
84 (/ 252 84) => 3  slots (no waste) [41 cells]
- which sizes (or how many should be used)
- only size 6 is mandatory, the others can be dynamically used/removed (table driven definition)

what would have to be done if I decide to use special 5byte slots for cell-pairs?
- option 1: pointer tagging stays at xxxx xxx0 with additional check on page type
- option 2: pointer tagging m1 xxxx xx10 and cell-pair xxxx xx00, reducing the types of pages possible
            check for pointer type is done on pointer itself
            page sizes possible: [8, 12, 16, 20, 28, 36, 48, 84], but sizes are dynamically used => easy change
** TODO idea: check number of refcount +/-, allocation/free processes when running a relevant algorithm
=> find out how often certain code passages are run
   find out how expensive this would be
** OBSOLETE idea: harmonize pointer handling
- could m1 pages be organized as the cell-pair pages (getting RC field by >>2): NO WONT WORK FOR LARGER SLOTS
- could cellpairs be organized as m1 slots?: no: the size of 5 will make the bits change such that pointer tagging is not possible
0 1 2 3 4 5 6 7 8 9 A B C D E F
- x c c c c c x c c c c c x c c
  cells-pairs are 5 bytes each + rc => 41 (42 but need some metadata), compared to 51(or50) with other method
- use translation table to get index (e.g. TAX, LDY translate,x, LDA (page),y)
- need for different translation tables for m1 page and cell-pair pages make this unusable
** BRAIN eval new idea
- all pointers end on bitmask xxxx xxx0
- how to handle pointer specific (refcount) operations
  premise: most operations work on one type of pointer only (e.g. CAR on cell-pair)
  1. e.g. make byte code operations pointer specific (e.g. DUP-CELL-PAIR, DUP-CPLX-CELL)
     makes sense, if there are not too many pointer generic operations
     and it is mostly statically known, what pointer type is present
     generic pointer operations could be used, too, with additional overhead
  2. make pointer type detection fast by providing fast page type lookup
- this allows new object alignment
  - cell-pair page: only use 1 byte on page for metadata, all else is kept somewhere else 0xnn nnnn
  - option: use no page space for metadata => page metadata is held elsewhere
    - fast lookup: page-number -> page-type
      e.g. use page-number as index: lda c000,x to load page type 1xxx xxxx for complex page, 0xxx xxxx for cell-pair page (bmi)
      store offset to first free slot (needs *​ 2 or asl)
      meta data for complex page is held on page, meta data for cell pair pages is not.
      all cell pair pages are held in separate list?
** OBSOLETE new idea for pointer tagging
- idea: cell-pairs are tagged either 01 or 00 and use the ref count at m1, too
- does not work, since placing slots of size 5 one after the other produces, this will result in 00, 01, 10, 11 changes in the last two bits
  => cannot be used!
  0000
  0101
  1010
  1111

- current page layout
  00 (0, 4, 8, 12, 16, 20 ...)
  01 (1, 5, 9, 13)
  .    RC04 RC08 RC0C C04 ... C08 ... C0C ...
  RC40 RC44 RC48 RC4C RC50 RC54 ...

                               RCFC
  C40... C44... C48... C4C...
  C50...

                       CFC...
** OBSOLETE new pointer tagging
no more cell-ptr!
RT = 00 (low byte) is equivalent to RT is empty!
use new pointer tagging scheme :        examples (low, then high byte):
  zzzz zz10 = ptr to m1 slot            0000 00[10]    1100 1101   cx00 (first allocated slot in m1 page), rc @ $02, head @ $03, payload thereafter
  0000 0000 = nil
  xxxx xx00 = ptr to cell-pair          0000 01[01]    1100 1101   cp01 (first allocated slot in a cell-pair page), rc @ $01
  iiii ii11 = int-cell                  [1]000 10[11]  0001 1000   0218 (decimal 2*256+16+8 = 536) <- high byte comes first in this special int encoding
  0000 0001 = byte-cell (char)          [0000 0001]    0000 0001   01  <- payload is in high byte
  1xxx xx01 = reserved (or symbols, then up to 8192)
  01bb bb01 = bcds-cell (3 digits)      [01]10 01[01]  0110 0100   964 (digits 9, 6 and 4)
  001s ss01 = symbol (1024)             [001]1 00[01]  0010 0110   symbol #550 (512+32+4+2)
  0001 xx01 = reserved

  changes:
  - no more cell ptr, just ptr->complex cells and ptr->cell-pair, references to cells are kept within a cell-pair (wasting one slot for this rare case)
  - int now ends on 11 to allow for easy arithmetic functions
  - byte has other tag
  - bcds cell  (new, optional)
  - symbol (new, option)
#+begin_src asm
  ;; check for pointer
          LSR A
          BCS NO_POINTER
          ;; (BCC) POINTER

  ;; check for m1-ptr
          AND !$03
          CMP !$02 ; EOR !$02
          BEQ IS_M1_PTR

  ;; check for cell-pair-ptr
          AND !$03
          BEQ IS_CELL_PAIR_PTR

          ;; alternatively
          LSR A
          ;; (BCS) IS_NO_PTR
          LSR A
          BCC IS_CELL_PAIR_PTR
          ;; (BCS) IS_M1_PTR

  ;; check for int-cell
          AND !$03
          CMP !$03 ; EOR !$03
          BEQ IS_INT_CELL

  ;; check for byte-cell
          CMP !$01 ;; CMP !TAG_BYTE_BYTE_CELL
          BEQ IS_BYTE_CELL

  ;; if int or byte: check 0
          LDA LB
          BNE IS_NOT_ZERO
          LDA HB
          AND #$fc
          BEQ IS_ZERO

  ;; if byte: check 0
          LDA LB
          BNE IS_NOT_ZERO
          ;; (BEQ) IS_ZERO
#+end_src
** IMPLEMENT DEFINITION OF call / ret
*memory layout of call frame page* (organized in stack, lb, hb on separate pages)
                 offset  content page lb  page hb
                 --------------------------------
                 00      #b0000 0001 page type call-frame

                             / \              / \
                              |                |
                         vm_pc offset     locals offset
                         function offset  function page
zp-local-ptr-hb -->      local 0 cell-lb  local 0 cell-hb   <-- zp-local-ptr-hb
                         ...
                 ff      local n

*memory layout of code*
---------------------
function-ptr-> xxxx llll        0..15 locals
               bytecode 0
               ...

*** call
vm_pc inc by call (+3)
memorize current locals_lb_ptr+0 (offset) for later save!
load #locals
check call frame page has sufficient space for call (# locals + 2)
  does not fit:
    [allocate 2 new call frame pages (and init)] see call-frame-stack
    [set respective previous pages to new call frame pages] see call-frame-stack
    set locals_lb_ptr+1 := new page 1
    set locals_hb_ptr+1 := new page 2
    set locals_lb_ptr+0, locals_hb_ptr+0 := ff - # locals (is locals allocation)
  does fit:
    allocate locals on frame page
save current function_ptr+1   -> function page
save current function_ptr+0   -> function offset
save current vm_pc+0          -> vm_pc offset
save (memorized) current locals_lb_ptr+0  -> locals offset
set locals_lb_ptr+0 = locals_hb_ptr+0 := new locals offset
set function_ptr+1 = vm_pc+1 := page of call target
setfunction_ptr+0 = vm_pc+0 := offset of call target
JMP INTERPRET_INC_VM_PC
*** ret
load #locals
free (gc) remaining ptrs in locals
check change to previous call page necessary?
  no change necessary:
    vm_pc_offset is on call-frame page @ current zp_local_lb_ptr+0 + current # of locals
    or alternatively: vm_pc_offset is on call-frame page @ previous locals offset - 2
  change necessary:
    get previous locals offset
    get previous page 1 and 2
    vm_pc_offset is on (previous) call-frame page @ previous locals offset - 2
    restore vm_pc+0 from vm_pc offset on (prev) call frame
restore function_ptr+0 from function offset on (prev) call frame
restore function_ptr+1 and vm_pc+1 from function page on (prev) call frame
adjust vm_pc+1 (+1 if function_ptr+0 > vm_pc+0, [restriction: code, including overhead, may never be longer than 256 byte!])
restore locals_lb_ptr+0 and locals_hb_ptr+0 from locals offset on (prev) call frame
JMP INTERPRETER
** IMPLEMENT DEFINITION OF vm state
- vm state
  defines before and after state of a byte code command completely
  registers held on the zero page
  - RT :: (cell) top of stack is held in this register
  - RA (RAI) :: (ptr->array, index) register A for array access
  - RB (RBI) ::
  - RC (RCI) ::
  - PC :: (ptr) program counter for the byte code
  - LOCALS_LB :: (ptr) into call-stack to low byte of the 0s local cell
  - LOCALS_HB :: (ptr) into call-stack to high byte of the 0s local cell
  - FUNC :: (ptr) to the currently execution function (right before first byte code)
  - EVLSTK_LB :: (ptr) to eval-stack low byte (only page, offset = 0)
  - EVLSTK_HB :: (ptr) to eval-stack high byte (only page, offset = 0)
  - EVLSTK_OFF :: offset into EVLSTK_LB and _HB to 2os
  - data on the eval stack (pointed to by evlstck_l/hb)
  - data on the call frame stack (pointed to by locals_l/hb)
- vm free lists and garbage collection data
  - FL_P8 :: (ptr) free list of profile 8
  - FL_P12 :: (ptr) free list of profile 12
  - FL_P16 :: (ptr) free list of profile 16
  - FL_P20 :: (ptr) free list of profile 20
  - FL_P28 :: (ptr) free list of profile 28
  - FL_P36 :: (ptr) free list of profile 36
  - FL_P48 :: (ptr) free list of profile 48
  - FL_P84 :: (ptr) free list of profile 84
  - FL_CELLPAIRS :: (ptr) list of free cell pairs
  - FL_PC_CELLPAIRS :: (ptr) partially collected cell pairs (cdr field may hold pointers not collected yet)
  - FL_PC_CELLARRAYS :: (ptr) partially collected cell pair arrays
- vm temporaries
  temporarily used by the implementation of byte code commands
  held on the zero page
  - RP :: (cell) aux register
  - RZ :: (cell) used for gc, refcounting etc.
  - PAGE_PTR :: (ptr) with offset always 0!
  - TEMP :: (cell)
  - TEMP2 :: (cell)
IDEA: keep RT and RP in sequence to allow ,y/,x addressing them, making some functions work on either RP or RT, passing the right y/x
** IMPLEMENT DEFINITION OF cell types and references
cell types fall into 3 categories
*** pointers
tag byte ends on bits 10 [complex-cell-ptr], or 00 [cell-pair-ptr]
points somewhere.
- it points to a complex cell (on a page), e.g. cell-array, native array
- it points to a cell-pair
- pointers to cells are emulated by pointers to cell-pairs, using the car field only
*** value cell
a value cell holds its (complete) value
- int, tag byte  = 1... ..11 (& $83 = $03)
- byte, tag byte = 0000 0011 (== $03)
- bcd, symbol, ...
*** header cell
is a cell that is used as a header for some payload. it may only be used on complex cell pages
the following headers exist:
0lll llll native array (length 1..82)
10ll llll cell-array   (length 1..41)
110x xxxx function     (0..7 constants, static/dynamic)
1110 ffff float
1111 xxxx unused
- header of a *native array of bytes* (useful for strings)
  tag byte = 0lll llll (and $7f = len)
  offset  content        <- memory layout
  ------------------
  00      reference count
  01      header-byte including length of byte array
  02      byte index 0
  ...
  n+2     byte index n
- header for an *array of cells* (useful for structures)
  tag byte = 10ll llll (and $7f = len)
  offset  content        <- memory layout
  ------------------
  00      refcount
  01      header-byte including length of cell-array
  02..03  cell index 0 *)
  04..05  cell index 1
  ...
  ..n*2+3 cell index n

  *) cells in an array of cells may be either pointers or value cells, never header-bytes!!
- header for *(dynamic) functions*
  tag byte = 110r sccc
  r = reserved
  s = static flag
  ccc = 0..7 constants
  offset  content        <- memory layout
  ------------------
  00      reference count
  01      header byte
  02..03  constant 0
  ..n*2+1 constant n
  n*2+2   function header byte    <-- func-ptr
  n*2+3   bc0
          ...

  function header byte = gccc llll
  g = flag indicating whether function is gc'ed (0=no gc)
  ccc = 0..7 constants
  llll = 0..15 locals
- header for a *float*
  tag byte = 1110 ffff
  offset  content        <- memory layout
  ------------------
  00      reference count of this field (including top 4 bits of 5th byte of float)
  01      header-byte (including 4 bits of 5th byte of float)
  02.06   5 bytes of the float
** IMPLEMENT alternative pages
- idea: store single floats (5 bytes) in 8 byte buckets (6 bytes payload, 1 wasted)
- idea: keep a page local free list
- idea: keep a list of pages with free slots per profile
- (postponed) idea: keep additional 12sized byte slots on other pages in separate free list
  (detection: do they all have the same offset? they do, but not on every page (yet))
  e.g. last slot on page is always a 12byte slot at the same offset
  resulting page profiles (with last 12byte slot on page at the same offset): => detection during free is easier, what if 12 byte slots are unused (lots of waste??)
    8 (* 30 + 12)  [3 slot per payload]
    12 (* 21 + 12) [5]
    16 (* 15 + 12) [7]
    20 (* 12 + 12) [9]
    30 (* 8 + 12)  [14]
    40 (* 6 + 12)  [19]
    60 (* 4 + 12)  [29]
    80 (*3 + 12)   [39]
    rule: before other p12 slots are allocated, the free list must be consultated (which is a 16ptr, page spanning list)
    rule: freeing a reference with offset $f2 (regardless of page) is a p12 slot that is held in this special free list!
  alternative:
    8   +12 (or - and waste 4)
    12  ?
    16  +12
    20  +12
    28  -
    36  -
    48  +12
    84  -
    keep p12 slots in separate free list. on free, check $f2, if matching, check page type, only on pages p8
    (not if additional waste of 4 is acceptable), p16, p20 and p48 are
- (postponed) idea put those 12slots at the end all on $f3 (not colliding with any other slots) => detection is easier
- (later) idea: storing matrices of floats in native arrays (4x4x5 = 80 bytes), (3x3x5) = 45
- (later) idea: store vectors (3*5) = 15, (4x5) = 20
- (postponed) idea: what if pages have different bucket sizes?
  - clutter within pages making cleanup/allocation more complex
  - possibility to reduce waste.
  - does help with pointer tags using the last 2 bits only, if used just for the last cell on the page
  - possible (base) sizes must be multiples of 4
       8 (* 31 8) => 248
    *8* (with one 12 byte slot) (+ (* 30 8) 12) => 252
    *12* (* 21 12) => 252
    *16* (with one 12 byte slot) (+ (* 15 16) 12) => 252
    *20* (with one 12 byte slot) (+ (* 12 20) 12) => 252
       24 (with one 12 byte slot) (​+ (* 10 24) 12) => 252
    *28* (* 9 28) => 252
       30 (+ 12 (* 8 30)) => 252
       32 (with one 28 byte slot) (​+ (* 7 32) 28) => 252
       34 (+ 12 (* 7 34)) => 250
    *36* (* 7 36) => 252
       40 (+ 12 (* 6 40)) = > 252
       44 (with one 32 byte slot) (​+ (* 5 44) 32) => 252
    *48* (with one 12 byte slot) (+ (* 5 48) 12) => 252
       60 (with one 12 byte slot) (​+ (* 4 60) 12) => 252
       80 (+ (* 3 80) 12)
    *84* (* 3 84) => 252
       124 (* 2 124) => 248
  - tagging theme: m1-page 10, cell-pair-page 00, int 11, 01 = reserved (others)
  - keep (global) free list for each bucket size, thus adding the additional slot to the right free list!
  - only 12 byte slots are used for padding
  - how many profiles will be used is up to optimization (depends on allocation behavior of app)
  - change: no more byte for each page, that points to the first free slot
            free slots are kept in a free list (head points to first free slot, head located in zp)
            each free slot points to the next free slot (or 0 if none)
*** general coding within pages
- 00 :: page type
- 01 :: # of slots in used (0 = page is empty) || # of free slots (0 = page is full)
- +00 :: refcount of slot [0=unused|free]
- +01 :: header byte (or if unused, pointer to next free cell on this page or 0 if this was the last free cell)
- +02..+xx :: payload (size depending on payload)
- ff :: ptr to next page of this profile
*** p8 layout (no more minus 1 to get to rc field) (ptr),0 = rc, (ptr),1 = header, (ptr),2 = first payload byte
offset  content
---------------------
00      (page type)
01      # of slots in use (top bit for extra slot?) => 0 = page is unused and can be freed
02      refcount slot 0                 <-- ptr (ends on ..10)
03      header slot 0
04..09  slot0 (6 bytes)
0a      refcount slot 1                 <-- ptr (ends on ..10)
0b      header slot 1
0c..11  slot1 (6 bytes)
...
ea      refcount slot 29
eb      header slot 29
ec..f1  slot 29 (6 bytes)
f2      refcount slot 30
f3      header slot 30
f4..f9  slot 30 (6 bytes)
fa..fe  reserved (5 bytes)
[f2      refcount extra slot           <-- ptr (ends on ..10)
 f3      header extra slot
 f4..fd  extra slot of size 12, payload 10
 fe      reserved]
ff      previous page of same profile (with potentially free slots)
*** p12 (21 slots, 10 bytes payload)
offset  content
--------------------
00      (page type)
01      # of slots in use/empty
02      ref count slot 0
03      header slot 0
04..0d  slot 0 (10 bytes)
0e      ref count slot 1
0f      header slot 1
10..19  slot 1 (10 bytes)
...
f2      ref count slot 20
f3      header slot 20
f4..fd  slot 20 (10 bytes)
fe      reserved
ff      ptr to next page
*** p16
offset  content
--------------------
00      (page type)
01      # of slots in use/empty
02      ref count slot 0
03      header slot 0
04..11  slot 0 (14 bytes)
12      ref count slot 1
13      header slot 1
14..21  slot 1 (14 bytes)
...
e4..f1  slot 14
f2..fe  reserved (13 bytes, alternative: put slot12 at f2)
ff      ptr to next page
*** p20
offset  content
--------------------
00      (page type)
01      # of slots in use/empty
02      ref count slot 0
03      header slot 0
04..15  slot 0 (18 bytes)
16      ref count slot 1
17      header slot 1
18..29  slot 1 (18 bytes)
...
ea      ref count slot 12
eb      header slot 12
ec..fd  slot 12 (18 bytes)
fe      reserved
ff      ptr to next page
*** p28
offset  content
--------------------
00      (page type)
01      # of slots in use/empty
02      ref count slot 0
03      header slot 0
04..1d  slot 0 (26 bytes)
1e
1f
20..39  slot 1
...
e2      refcount slot 8
e3      header slot 8
e4..fd  slot 8
fe      reserved
ff      ptr to next page
*** p36
offset  content
--------------------
00      (page type)
01      # of slots in use/empty
02      ref count slot 0
03      header slot 0
04..27  slot 0 (36 bytes)
28
29
2a..4d
...
d9      refcount slot 6
d0      header slot 6
da..fd  slot 6 (36 bytes)
fe      reserved
ff      ptr to next page
*** p48
offset  content
--------------------
00      (page type)
01      # of slots in use/empty
02      ref count slot 0
03      header slot 0
04..31  slot 0 (46
32
33
34..61
...
d2      ref count slot 4
e3      header slot 4
c4..f1  slot 4 (payload 46)
fe      reserved
ff      ptr to next page
*** p84
offset  content
--------------------
00      (page type)
01      # of slots in use/empty
02      ref count slot 0
03      header slot 0
04..55  slot 0 (82 bytes)
56
57
58..a9
aa
ab
ac..fd
fe      reserved
ff      ptr to next page
*** cell-pair page layout
offset  content
---------------------
00      #b0000 0000 (page type)
01      ref-count cell-pair at 04 (cell-pair 0)
02      ref-count cell-pair at 08 (cell-pair 1)
03      ref-count cell-pair at 0c (cell-pair 2)
04..07  cell-pair 0
08..0b  cell-pair 1
0c..0f  cell-pair 2
10      ref-count for cell-pair at 40 (cell-pair 3)
11      ref-count for cell-pair at 44 (cell-pair 4)
..3e    ref-count for cell-pair at f9 (cell-pair 49)
3f      reserved
41..44  cell-pair 3
45..48  cell-pair 4
...
f8..fb  cell-pair 49
fc      reserved
fd      first free cell-pair on the page?
fe      # of cell-pairs used
ff      previous page of this type
*** call-frame-stack page layout
- used for call frames
- one page for low byte, one for high byte
- meta data is held outside of this page (in a cell-pair page)
- cframe_meta_lb -> cell-pair [car = [prev-locals_lb_ptr] cons = ptr-to-next-in-list]
- cframe_meta_hb -> cell-pair [car = [prev-locals_hb_ptr] cons = ptr-to-next-in-list]
- advantage: under/overflow easier to detect
offset  content page lb   page hb
---------------------------------
00     page type

                    / \
                     |
       vm_pc offset      locals offset
       function offset   function page
       cell-lb0          cell-hb0    <-- zp_locals_l/hb_ptr, points here to have minimal code for locals access!
       ...
       cell-lbn-1        cell-hbn-1

ff     last possible payload

- example
  #+begin_src asm
    ;; allocate n-locals + 2 space for call-frame
    ;; a = # locals
                CLC
                ADC #$02
                STA temp
                ADC #$03
                SEC
                SBC local_lb_ptr
                BCC frame-overflow              ; use new page for this data, put current locals_l/hb_ptr into meta list
                LDA local_lb_ptr
                SEC
                SBC temp                        ; carry is still set after this operation
                STA local_lb_ptr
                ;; SBC #$02                     ; store pointer to location where to store vm_pc offset and locals offset
                STA local_hb_ptr
                RTS

    ;; allocate new page (make it as compact as possible, runtime is not important, since this will happen very seldom!)
    frame-overflow:
                ;; make sure temp is not overwritten here (or use other memory location)
                JSR ALLOC_CELL_PAIR_TO_RP
                LDY #$00
                LDX #$00
                JSR local_xb_to_rp
                JSR ALLOC_CELL_PAIR_TO_RP
                LDY #$00
                LDX #$02
                JSR local_xb_to_rp

                LDA #PAGE_TYPE_CALL_FRAME
                JSR ALLOC_PAGE_PAIR_TO_AX ; no init of page necessary (except page type)
                STA local_lb_ptr+1      ; store allocated page #1
                STX local_hb_ptr+1      ; store allocated page #2
                SEC
                LDA #$02                ;
                SBC temp                ; overlaps regular code (see before), could be jumped to, to save some bytes
                STA local_lb_ptr
                ;; SEC
                ;; SBC #$02              ; local where vm_pc and locals-offset is stored
                STA local_hb_ptr
                RTS

    local_xb_to_rp:                 ; works if local_lb_ptr and local_hb_ptr are x-bytes apart (same for meta)
                LDA local_lb_ptr+1,x
                STA (RP),y
                LDA local_lb_ptr,x
                INY
                STA (RP),y
                INY
                LDA local_lb_meta+1,x
                STA (RP),y
                LDA local_lb_meta,x
                INY
                STA (RP),y
                LDA RP
                STA local_lb_meta,x
                LDA RP+1
                STA local_lb_meta+1,x

  #+end_src
- idea: call frame allocation hysteresis
  to prevent a permanent allocation/free of pages if call/ret happens constantly at this border
  - ret frees slot on old page call-frame stack (until e.g. reduced to 3/4 of the page)
  - new calls are pushed onto the new page call-frame-stack
  => always 2 stacks (and their pages) are kept, the current and the previous
- hysterisis check
  #+begin_src asm
            BIT CALL_FRAME_HYSTERISIS
            BMI IS_IN_HYSTERISIS ; checks topmost bit (7)
    REGULAR_CODE:
            ;; hysterisis detection
            ;; if running into a call-stack underflow (set hysterisis and jump into IS_IN_HYSTERISIS)
    REGULAR_CODE_NO_HYST_DETECTION:
            ;  regular code follows here


    IS_IN_HYSTERISIS:
            LDA locals_lb_ptr
            BPL KEEP_HYSTERISIS
            LDA #$00
            STA CALL_FRAME_HYSTERISIS
            BEQ REGULAR_CODE
    KEEP_HYSTERISIS:
            ;; on ret, pop from call-frame-page of old locals ptr
            ;; on call, push onto call-frame-page of new locals ptr
            JMP REGULAR_CODE_NO_HYST_DETECTION
  #+end_src
*** cell-stack page layout (eval stack)
- used for the evaluation stack
- one page for lowbyte and highbyte each (is either full or has zp_evlstk_offset point to current 2os)
- meta data is held outside of this page (in a cell-pair page)
- evlstk_meta -> cell-pair [car = [offset page] cons = ptr-to-next-in-list]
- advantage dey/dex iny/inx will run over byte border, making it easily checkable, whether it runs over the borders
offset  content page lb   page hb
---------------------------------
00     page type  <--- zp_evlstk_l/hb ptr
01     topmost available payload on the stack
                    / \
                     |
        cell-lb           cell-hb    <-- zp_evlstk_offset (+ zp_evlstk_l/hb_ptr)
        ...
ff      cell-lb0          cell-hb0

- example
  #+begin_src asm
    ;; pop
    ldy evlstk_offset               ; 3 cycles
    lda (evlstk_lb_ptr),y           ; 5 cycles
    sta rt
    lda (evlstk_hb_ptr),y           ; 5 cycles
    sta rt+1
    inc evlstk_offset               ; 5 cycles
    beq stack_underflow             ; only if bounds checking (if 255 stack size is enough, no checking necessary)

    ;; push
    ldy evlstk_offset               ; 3 cycles
    dey                             ; 2
    beq stack_full                  ; only if bounds checking (if 255 stack size is enough, no checking necessary)
    lda rt
    sta (evlstk_lb_ptr),y           ; 6
    lda rt+1
    sta (evlstk_hb_ptr),y           ; 6
    sty evlstk_offset               ; 3 cycles
  #+end_src

** musings about pages
*** page types
alternatives
- 0000 0000 :: cell pairs page, #slots used can be held elsewhere
- 1000 0xxx :: m1 page (xxx = profile index 0..7)
  1000 0000 :: m1p6
  1000 0001 :: m1p8
  1000 0010 :: m1p12
  1000 0011 :: m1p18
  1000 0100 :: m1p24
  1000 0101 :: m1p42
  1000 0110 :: m1p84
  1000 0111 :: reserved
- 0000 0001 :: call frame stack (stack organized, full+free detection already implemented)
- 0000 0010 :: cell stack (come in pairs for low and high byte)
  0000 0011 ..
  0111 1111 :: reserved (32)

call-frame page
cell stack page

optional: (fid->loc page) page with 16 bit values (starting at $02), filled without gaps, next slot = offset to free, no ref counting
optional: (code page) page with byte code and function meta data <- filled without gaps, next slot = offset to free, no ref counting

- cell-pair detection (BEQ)
- m1page detection (BMI)
- others: (CMP !$xx, BEQ)
**** old ideas
11yy yyyy = (cell-pairs page) page with cell-pairs (slots of byte 4) yyyyy = number of cells used 0..63 (actually only 51 possible)
10xx xxxx = (m1 page - p6) page with slots, xxxxxx = number of used slots  0..42
010x xxxx = (m1 page - p8) page with slots, xxxxx = number of used slots  0..31
011x xxxx = (m1 page - p12) page with slots, xxxxx = number of used slots  0..21
0011 xxxx = (m1 page - p18) page with slots, xxxx = number of used slots  0..14
0010 xxxx = (m1 page - p28) page  with slots, xxxx = number of used slots  0..9
0001 0xxx = (m1 page - p42) page  with slots, xxx = number of used slots  0..6
0001 11xx = (m1 page - p84) page with solots, xx  = number of used slots  0..3

1111 0010 .. 1111 1111 reserved (15, not used by cell-pairs page)
1010 1011 .. 1011 1111 reserved (22, not used by m1p6)
0111 0110 .. 0111 1111 reserved (10, not used by m1p12)
0011 1111              reserved (1, not used by m1p18)
0010 1010 .. 0010 1111 reserved (6, not used by m1p28)
0001 1111              reserved (1, not used by m1p42)

0001 10xx = reserved


- detection for cell pages (1bbb bbbb)
  #+begin_src asm
    ;; after load
    BMI IS_CELL_PAGE

    ;;
    AND #$80
    CMP #$80
    BEQ IS_CELL_PAGE
  #+end_src
- detection for cell-pair page (01bb bbbb)
  #+begin_src asm
    AND #$c0
    CMP #$40
    BEQ IS_CELL_PAIR_PAGE
  #+end_src
- detection for m1 pages (0001 0bbb)
  #+begin_src asm
    AND #$f8
    CMP #$10
    BEQ IS_M1_PAGE_HEADER
  #+end_src
- detect special page
  #+begin_src asm
    AND #$f8
    CMP #$18
    BEQ IS_SPECIAL_PAGE
  #+end_src
*** general page layout (m1-pages + cell-pairs page)
$00 = page type
$fe = # of slots used
$ff = previous page
*** cell-pair page layout
offset  content
---------------------
00      #b0000 0000 (page type)
01      ref-count cell-pair at 05 (cell-pair 0)
02      ref-count cell-pair at 09 (cell-pair 1)
03..04  unused (2)
05..08  cell-pair 0
09..0c  cell-pair 1
0d..0f  unused (3)
10      ref-count for cell-pair at 40 (cell-pair 2)
11      ref-count for cell-pair at 44 (cell-pair 3)
..3e    ref-count for cell-pair at f9 (cell-pair 48)
3f..40  unused (2)
41..44  cell-pair 2
45..48  cell-pair 3
...
f9..fc  cell-pair 48
fd      unused
fe      # of cell-pairs used
ff      previous page of this type

*** m1p6 page layout (4 bytes payload) <- used for floats (5bytes) with a trick
provides space for structures with 1-2 fields
page type slot size 6  (refcount @ ptr-1) 42 slots
math: first entry $02, refcount @ -1, next slot += 6, slot-size = 4
offset content
--------------------
00      #b1000 0000 page type bucket with slot size 4
01      refcount slot0
02      header slot0
03..08  slot0
09      refcount slot1
0a      header slot1
0b..0e  slot1
0f      refcount slot2
10      header slot2
11..14  slot2
...
f7      refcount slot41
f8      header slot41
f9..fc  slot41
fd      reserved
fe      # slots used
ff      previous page
*** m1p8 page layout (6 byte payload)
provides space for structures with 1-3 fields
page type slot size 8 (refcount @ ptr-1) 31 slots
math: first entry $02, refcount @ -1, next slot += $08, slot-size = $06
offset content
--------------------
00      #b1000 0001 page type bucket with slot size 9 (either use this or the one above)
01      refcount slot0
02      header slot0  <- lowest bit must be 0 (to qualify as a m1-ptr!)
03..08  payload slot0 (6 bytes)
09      refcount slot1
0a      header slot1
0b..10  slot1
...
f1      refcount slot30
f2      header slot30
f3..f8  slot30
f9..fd  reserved (5)
fe      # slots used
ff      previous page
*** m1p12 page layout
provides space for structures with 4-5 fields
page type slot size 12  (refcount @ ptr-1) 21 slots
math: first entry $02, refcount @ -1, next slot += 12, slot-size = 10
offset content
--------------------
00      #b1000 0011 page type bucket with slot size 12 (either use this or the one above)
01      refcount slot0
02      header slot0
03..0c  slot0
0d      refcount slot1
0e      header slot1
0f..18  slot1
19      refcount slot2
1a      header slot2
1b..24  slot2
...
f1      refcount slot20
f2      header slot20
f3..fc  slot20
fd      reserved
fe      # slots used
ff      previous page
*** m1p18 page layout
provides space for structures with 8-13 fields
page type slot size 18 (refcount @ ptr-1) 14 slots total
math: first entry $02, refcount @ -1, next slot += 18, slot-size = 16)
offset content
--------------------
00      #b1000 0011 page type bucket + slot size 18
01      refcount slot0
02      header slot0
03..12  slot0
13      refcount slot1
14      header slot1
15..24  slot1
...
eb      refcount slot13
ec      header slot13
ed..fc  slot13
fd      reserved
fe      # of slots used
ff      previous page
*** m1p28 page layout
page type slot size 28 (refcount @ ptr-1) 9 slots total
math: first entry $02, refcount @ -1, next slot += 28, slot-size = 26
offset content
--------------------
00      #b1000 0100
01      refcount slot0
02      header slot0
03..1c  slot0
1d      refcount slot0
1e      header slot1
1f..38  slot1
...
e1      refcount slot8
e2      header slot8
e3..fc  slot8
fd      reserved
fe      # slots used
ff      previous page
*** m1p42 page layout
page type slot size 42 (refcount @ ptr-1) 6 slots total
math: first entry $02, refcount @ -1, next slot += 42, slot-size = 40
offset content
--------------------
00      #b1000 0101
01      refcount slot0
02      header slot0
03..2c  slot0
2d      refcount slot0
2e      header slot1
2f..58  slot1
...
d1      refcount slot8
d2      header slot8
d3..fc  slot5
fd      reserved
fe      # slots used
ff      previous page
*** m1p84 page layout
page type slot size 84 (refcount @ ptr-1) 3 slots total
math: first entry $02, refcount @ -1, next slot += 84, slot-size = 82
offset content
--------------------
00      #b100 0110
01      refcount slot0
02      header slot0
03..54  slot0
55      refcount slot1
56      header slot1
57..a8  slot1
a9      refcount slot2
aa      header slot2
ab..fc  slot2
fd      reserved
fe      # slots used
ff      previous page

*** call-frame (stack organized) page layout
*memory layout of call frame page* (organized in stack, lb, hb on separate pages)
                 offset  content page lb  page hb
                 --------------------------------
                 00      #b0000 0001 page type call-frame

                             / \              / \
                              |                |
                         vm_pc offset     locals offset
                         function offset  function page
zp-local-ptr-hb -->      local 0 cell-lb  local 0 cell-hb   <-- zp-local-ptr-hb
                 ...
                 fe      local n
                 ff      previous page    prev page

*memory layout of code*
---------------------
function-ptr-> xxxx llll        0..15 locals
               bytecode 0
               ...

NOTE: constant cells are kept on module level (or global)
*** cell-stack page layout (eval stack)
- used for the evaluation stack
- one page for lowbyte and highbyte each (is either full or has zp_evlstk_offset point to current 2os)
offset  content page lb   page hb
---------------------------------
00      page type #b0000 0010 cell-stack    <-- zp_evlstk_l/hb_ptr


                  / \
                   |
        cell-lb           cell-hb    <-- zp_evlstk_offset
        ...
ff      previous page (of the stack)

** musings about new pointer tagging
no more cell-ptr!
RT = 00 (low byte) is equivalent to RT is empty!
use new pointer tagging scheme :        examples (low, then high byte):
  zzzz zzz0 = ptr to m1 slot            0000 001[0]    1100 1101   cx00 (first allocated slot in m1 page), rc @ $01
  xxxx xx01 = ptr to cell-pair          0000 01[01]    1100 1101   cp01 (first allocated slot in a cell-pair page), rc @ $01
  1iii ii11 = int-cell                  [1]000 10[11]  0001 1000   0218 (decimal 2*256+16+8 = 536) <- high byte comes first in this special int encoding
  0000 0011 = byte-cell (char)          [0000 0011]    0000 0001   01  <- payload is in high byte
  01bb bb11 = bcds-cell (3 digits)      [01]10 01[11]  0110 0100   964 (digits 9, 6 and 4)
  001s ss11 = symbol (1024)             [001]1 00[11]  0010 0110   symbol #550 (512+32+4+2)
  0001 xx11 = reserved

  changes:
  - no more cell ptr, just ptr->m1 and ptr->cell-pair
  - highest bit of int now 1 (allows easy overflow checks and hopefully easier subtraction, too)
  - byte has other tag
  - bcds cell  (new, optional)
  - symbol (new, option)
#+begin_src asm
  ;; check for m1-ptr
          AND !$01
          BEQ IS_M1_PTR

          ;; alternatively
          LSR A
          BCC IS_M1_PTR

  ;; check for cell-pair-ptr
          AND !$03
          CMP !$01
          BEQ IS_CELL_PAIR_PTR

          ;; alternatively
          LSR A
          ;; BCC IS_M1_PTR
          LSR A
          BCC IS_CELL_PAIR_PTR
          ;; NO PTR AT ALL!

  ;; check for int-cell
          AND !$83
          CMP !$83
          BEQ IS_INT_CELL

          ;; alternatively
          ;; if definitely no ptr
          BMI IS_INT_CELL

  ;; check for byte-cell
          CMP !$03 ;; CMP !TAG_BYTE_BYTE_CELL
          BEQ IS_BYTE_CELL

  ;; if int or byte: check 0
          LDA LB
          BNE IS_NOT_ZERO
          LDA HB
          AND #$7c
          BEQ IS_ZERO
#+end_src
** IMPLEMENT implement RP as (secondary) register for (only) cell pairs?
- OBSOLETE: RP dec-refctn and inc-refcnt can safely assume that rp holds either 0, nil or a reference to a cell-pair?
  not really, dereferencing RP cell0-> RP could make RP hold e.g. int 0000 and no other cell pair ptr
** TODO implement RP usage as TOS-1 register on demand
+ do this for operations in need of 2+ operands (which then discard the operands and just leave the result on the stack)
+ implement INT*, INT+, INT-, INT/ with this mechanism
+ e.g. POP_TOSM1_TO_RP, WRITE_TOSM1_TO_RP?, or WRITE_LOCAL_N_TO_RP
+ then execute binary operation and discard RP (and ensure that reference counting for RP can be ignored)
=> if both operands are on the stack, then POP_TOSM1_TO_RP before executing the operation
   if one operand is on the stack, the other can be written directly to RP
   if the result keeps references to cells referenced through RP, it might be necessary to inc-refcnt them <- who does that
- identify all binary operations that may benefit from this mechanism
  operand operation operand -> result : most benefit if operands and result don't need refcnt'ing
  - mult, add, sub, div, mod, shift-right, shift-left, ... (byte/int)
** TODO unify function naming (mostly done)           -> clean code
** TODO ensure test coverage                          -> ensure functionality over changes
- define use cases
- is there a way to automate test-coverage stats (e.g. branch coverage, command coverage)?
  - generate list of addresses (for line coverage) + indicator executed
  - generate list of addresses w/ branches + indicator taken/not-taken
- define tests
  - all tests must have a text describing the test
  - all tests should be resilient to memory location changes of registers etc.
- use most recent test utils
** TODO check: do pointers on cells exist that are on the locals/eval-stack?
- currently the answer is *NO*, does that restrict the programming model?
** TODO tweak configuration parameters                -> increase speed/reduce memory consumption
use profiling data
* current (en)coding
** naming
- files
  - vm- ...  :: implementation for the virtual byte code maching
  - bc- ...  :: implementation using (only) byte code
- functions
  - BC_...     :: implement code for a single byte code command, must be refcnt'd correctly
  - VM_...     :: implement code for virtual byte code machine, does no refcnt-ing
  - ...REFCNTD :: implements refcounting (even if prefixed otherwise)
  description
    input:  A/X/Y (register) description
    usage:  A/X/Y (register) modifications
            ZP_... memory/register modifications
            VM_... memory/register modifications
    output: A/X/Y (register) description
            ZP_... memory/register modifications
            VM_... memory/register modifications
    funcs:  list of sub routines / functions used

- other
  - ZP_...     :: located on the zero page (6510)
  - ...__      :: local labels (usually replaced through usage of ~add-label-suffix~ function), not available from outside this function!
** concepts
- cell                      :: 16 bit value (finest granular memory managed block)
- atomic cell               :: a cell that has no followup value and is complete in itself (currently int-cell, byte-cell, cell-ptr, cell-pair-ptr)
- cell-ptr                  :: an atomic cell, lowest bit of low byte is set, points to a cell (of any type)
                               lowbyte: #bxxxx xxx0
                               highbyte = page
                               functions that allocated/free a cell in a register, are always considered cell-ptr (in the register)
- cell-pair                 :: a pair of two cells, cell0 and cell1 (in memory: 00 lowbyte-cell0, 01 highbyte-cell0, 02 lowbyte-cell1, 03 highbyte-cell1),
                               each cell can be of any atomic cell
- cell-pair-ptr             :: an atomic cell, second lowest bit is set, lowest bit is unset, points to a cell-pair
                               lowbyte: #bxxxx xx01
                               highbyte = page
                               functions that allocated/free a cell-pair in a register, are always considered cell-pair-ptr (in the register)
- int-cell                  :: an atomic cell having 13 bit as payload
                               lowbyte mask: #b0xxx xx11, xxxxx = high bits of int
                               highbyte = lowbyte of int
- byte-cell (char|bool)     :: an atomic cell having one byte as payload
                               lowbyte mask: #b1111 1111
                               highbyte = payload
- complex cell              :: a cell that functions as header for followup values (follows directly in memory)
                               complex cells cannot be pushed on the stack, they can only be pointed to by cell-ptr!
- (cell-structure-header    :: a complex cell that defines a structure)
- cell-array-header         :: a complex cell that defines an array, defining the number of cells in the second byte
                               a structure is an array of cells
                               lowbyte mask: #b1000 0011
                               highbyte: #of cells in this array
                               n*2 bytes with cells <- each cell needs to be gc'ed separately
- cell-native-array-header  :: a complex cell that defines an array of bytes
                               a string is an native array of bytes
                               lowbyte mask: #b1000 0111
                               highbyte: #of bytes in this array
                               n bytes with byte payloads <- no gc of this necessary (holds plain values, no pointers, no cells)
- (cell-float-header        :: a complex cell that defines a float)
- page                      :: 256 byte memory managed unit, holding slots
- slot                      :: a fixed size portion of memory on a page (sizes are 2=cell, 4=cell=pair, 8 ...), only one size per page is allowed
- ref count                 :: byte counting how many pointers to this value exist, there can be pointer to pointers
- cell-stack aka eval-stack :: stack of cells. ZP_​CELL_​STACK_​TOS holds the index (on current page), ZP_​CELL_​STACK_​LB_​PTR, ZP_​CELL_​STACK_​HB_​PTR holds the pointer to the low/high byte
                               [RT]         RT is the top of the stack (even though not on the stack memory wise)
                               [cell n lb] [cell n hb]
                                       ...
                               [cell 1 lb] [cell 1 hb]
                               [cell 0 lb] [cell 0 hb]
                               ZP_​CELL_​STACK_​TOS points to the current element below RT (cell n)
- m1 page px       :: page for slots with ref count at -1 position, with profile x (0..3) <- defines size and payload start offset
- call-frame page  :: page for call-frames (stack organized, no ref counting etc.)
- cell-pairs page  :: page for cell-pairs, (lowbyte) lsr x 2 to get ref count position
- cell page        :: page for cells, (lowbyte) lsr x 1 to get ref count position (last cell unusable)
- [s8 page          :: page for slots of size <=8, (lowbyte) lsr x 3 to get ref count position] optional
- fid->loc page    :: page that maps a function id to a location of first byte code
- code page        :: page holding byte code (and function meta data, module meta data?)
- constants page   :: page holding constants (not ref counted)
- page block       :: a number of consecutive pages allocated/freed as a block, allowing for larger memory objects (having less wasted bytes (e.g. for call-frames)?)
- cell-stack page  :: a pair of pages, actually, that hold low and high byte of a cell. it is stack organized.
** parameters
- are passed as regular stack values
- need to be copied to locals if multiple access is necessary and /dup/ does not suffice
** pages
#+begin_src dot :file memory-page-state.gen.png
  digraph finite_state_machine {
      node [shape=point]ENTRY; //,EXIT
      node [shape=ellipse];

      ENTRY->free;
      ENTRY->blocked;
      free -> allocated[label="ALLOC_PAGE__PAGE_UNINIT"]
      allocated -> initialized
      free -> initialized[label="ALLOC_PAGE_FOR..."];
      initialized -> used;
      used -> full[label="alloc slot"];
      free -> used[label="alloc slot"];
      used -> used[label="free slot"];
      full -> used[label="free slot"];
  }
#+end_src

#+RESULTS:
[[file:memory-page-state.gen.png]]
- free :: VM​_PAGE​_SLOT​_DATA holds at page idx $ff, indicating that this page is free
- blocked :: VM​_PAGE​_SLOT​_DATA holds at page idx $01, indicating that this page is unavailable
- allocated :: VM​_PAGE​_SLOT​_DATA holds at page idx $00, this status is temporary
- initialized :: VM​_PAGE​_SLOT​_DATA holds at page idx $02..$fe, this status is temporary
- used :: page is in use, VM​_PAGE​_SLOT​_DATA holds at page idx $02..$fe = next free slot, a page in use may still hold 0 slots
- full :: page is in use, there are no free slots, VM​_PAGE​_SLOT​_DATA holds at page idx $00
*** page usage
pages can be allocated and freed
the status of the 256 pages is held in VM​_PAGE​_SLOT​_DATA + pageidx (at cf00):
content of this memory location is interpreted as
00: allocated but not initialized
01: unavailable
x : used, holding first free slot of this page (for some kind of pages)
ff: free
*** evaluation stack
- holds parameters
- holds current values to be evaluated
- real tos is held in zero page ZP_​RT
- all but tos is held on cell-stack page
- push V is then
  - push RT onto cell-stack page (if RT not empty)
  - write V into RT
- pop is then
  - write tos from cell-stack page into RT (if not empty)
  - or clear RT (if cell-stack page is empty)
*** page types
1xxx xxxx = (cell page) page with cells (slots of byte 2), xxxxxx = number of used cells 0..127 (actually only 85 possible)
01yy yyyy = (cell-pairs page) page with cell-pairs (slots of byte 4) yyyyy = number of cells used 0..63 (actually only 51 possible)
[001z zzzz = (s8 page) page with slots of (max) size 8 byte, zzzz = number of slots used 0..31 (actually only possible)]
0001 0000 = (m1 page p0) page with buckets type 0 (byte at offset 02: holds the number of used slots)
0001 0001 = (m1 page p1) page with buckets type 1 (byte at offset 02: holds the number of used slots)
0001 0010 = (m1 page p2) page with buckets type 2 (byte at offset 02: holds the number of used slots)
0001 0011 = (m1 page p3) page with buckets type 3 (byte at offset 02: holds the number of used slots)
0001 0100 = (m1 page p4) page with buckets type 4 (byte at offset 02: holds the number of used slots)
0001 0101 = reserved
0001 0110 = reserved
0001 0111 = reserved
0001 1000 = (call-frame page) (stack organized, full+free detection already implemented)
0001 1001 = (fid->loc page) page with 16 bit values (starting at $02), filled without gaps, next slot = offset to free, no ref counting
0001 1010 = (code page) page with byte code and function meta data <- filled without gaps, next slot = offset to free, no ref counting
0001 1011 = cell stack page (come in pairs for low and high byte)
0001 1100 = reserved
0001 1101 = reserved
0001 1110 = reserved
0001 1111 = reserved

- detection for cell pages (1bbb bbbb)
  #+begin_src asm
    ;; after load
    BMI IS_CELL_PAGE

    ;;
    AND #$80
    CMP #$80
    BEQ IS_CELL_PAGE
  #+end_src
- detection for cell-pair page (01bb bbbb)
  #+begin_src asm
    AND #$c0
    CMP #$40
    BEQ IS_CELL_PAIR_PAGE
  #+end_src
- detection for m1 pages (0001 0bbb)
  #+begin_src asm
    AND #$f8
    CMP #$10
    BEQ IS_M1_PAGE_HEADER
  #+end_src
- detect special page
  #+begin_src asm
    AND #$f8
    CMP #$18
    BEQ IS_SPECIAL_PAGE
  #+end_src
*** general page layout
$00 = page type
$01 = (code page, m1 page px, call-frame page, cell stack page) previous page (of same type) 
      (cell-pairs and cell page) payload
$02 = (m1 page px, s8 page) number of used slots
      (call-frame page) top mark (if full)
      (cell-pairs and cell page) payload
$ff = (cell-pairs and cell page) previous page
      (others) payload
*** cell page layout 
offset  content
---------------------
00      #b1zzz zzzz page type + number of used slots
01      ref-count for cell at 02 (cell 0)
02..03  cell 0
04      ref-count for cell at 08 (cell 1)
..07    ref-count for cell at 08 (cell 4)
08..09  cell 1
...
0e..0f  cell 4
10      ref-count for cell at 20 (cell 5)
.. 1f   ref-count for cell at 20 (cell 20)
20..21  cell 5
...
3e..3f  cell 20
40..7e  ref-count for cell at 80..fc (cell 21..83)
7f      unused
80..fd  cell 21..83
fe      unused
ff      previous page of this type
*** cell allocation/free
#+begin_src dot :file cell-page-state.gen.png
  digraph finite_state_machine {
      node [shape=point]ENTRY; //,EXIT
      node [shape=ellipse];

      ENTRY->free;
      free -> used[label="ALLOC_CELL_PTR_TO_RT"]
      used -> enqueued[label="FREE_CELL_PTR_IN_RT"]
      enqueued -> used[label="ALLOC_CELL_PTR_TO_RT"]

      labelloc="t";
      label="cell state";
  }
#+end_src

#+RESULTS:
[[file:cell-page-state.gen.png]]
- free :: cell is not counted as used on page
          points to the next free cell on this page (low byte), 0 = no next free
          it is reachable through the first free cell on this page (VM​_PAGE​_SLOT​_DATA)
          refcount of this cell is 0 (no one keeps a reference to this cell)
- used :: cell is counted as used on the page
          it is NOT reachable through the first free cell on this page (VM​_PAGE​_SLOT​_DATA)
          it is NOT reachable through the list of free cells VM​_LIST​_OF​_FREE​_CELLS
          refcount of this cell is >0 (at least on reference to this cell exists)
- enqueued :: cell is enqueued in list of free cells
              it is NOT reachable through the first free cell on this page (VM​_PAGE​_SLOT​_DATA)
              it is reachable through the list of free cells VM​_LIST​_OF​_FREE​_CELLS
              refcount of this cell is 0 (no one keeps a reference to this cell)
              it contains a word pointer to the next element of the list of free celss

*** cell-pair page layout
offset  content
---------------------
00      #b01xx xxxx page type + number of used slots
01      ref-count cell-pair at 05 (cell-pair 0)
02      ref-count cell-pair at 09 (cell-pair 1)
03..04  unused (2)
05..08  cell-pair 0
09..0c  cell-pair 1
0d..0f  unused (3)
10      ref-count for cell-pair at 40 (cell-pair 2)
11      ref-count for cell-pair at 44 (cell-pair 3)
..3e    ref-count for cell-pair at f9 (cell-pair 48)
3f..40  unused (2)
41..44  cell-pair 2
45..48  cell-pair 3
...
f9..fc  cell-pair 48
fd..fe  unused (2)
ff      previous page of this type

*** cell-pair allocation/free
#+begin_src dot :file cell-pair-page-state.gen.png
  digraph finite_state_machine {
      node [shape=point]ENTRY; //,EXIT
      node [shape=ellipse];

      ENTRY->free;
      free -> used[label="ALLOC_CELL_PAIR_PTR_TO_RT"]
      used -> enqueued[label="FREE_CELL_PAIR_PTR_IN_RT"]
      enqueued -> used[label="ALLOC_CELL_PAIR_PTR_TO_RT"]

      labelloc="t";
      label="cell-pair state";
  }
#+end_src

#+RESULTS:
[[file:cell-pair-page-state.gen.png]]
- free :: cell-pair is not counted as used on page
          points to the next free cell-pair on this page (low byte), 0 = no next free
          it is reachable through the first free cell-pair on this page (VM​_PAGE​_SLOT​_DATA)
          refcount of this cell-pair is 0 (no one keeps a reference to this cell-pair)
- used :: cell-pair is counted as used on the page
          it is NOT reachable through the first free cell-pair on this page (VM​_PAGE​_SLOT​_DATA)
          it is NOT reachable through the list of free cell-pairs VM​_QUEUE​_ROOT​_OF​_CELL​_PAIRS​_TO​_FREE
          refcount of this cell-pair is >0 (at least on reference to this cell-pair exists)
- enqueued :: cell-pair is enqueued in list of free cell-pairs
              it is NOT reachable through the first free cell-pair on this page (VM​_PAGE​_SLOT​_DATA)
              it is reachable through the list of free cell-pairs VM​_QUEUE​_ROOT​_OF​_CELL​_PAIRS​_TO​_FREE
              refcount of this cell-pair is 0 (no one keeps a reference to this cell-pair)
              car cell contains a word pointer to the next element of the list of free cell-pairs
              cdr cell may still contain a value to be garbage collected, so the cell-pair cannot be reused right away

*** m1p0 page layout
provides space for structures with 1-3 fields
page type slot size 9 (refcount @ ptr-1) 25 slots
math: first entry $,,m refcount @ -1, next slot += $0a, slot-size = $09 (9)
offset content
--------------------
00      #b0001 0000 page type bucket with slot size 9 (either use this or the one above)
01      previous page
02      number of slots used
03      refcount slot0
04..0c  slot0  <- lowest bit must be 0 (to qualify as a cell-ptr!)
0d      refcount slot1
0e..16  slot1
...
f3      refcount slot23
f4..fc  slot23
fd..ff  unused
*** m1p1 page layout
provides space for structures with 4-7 fields
page type slot size 17  (refcount @ ptr-1) 14 slots
math: first entry $04, refcount @ -1, next slot += $12, slot-size = $11 (17)
offset content
--------------------
00      #b0001 0001 page type bucket with slot size 17 (either use this or the one above)
01      previous page
02      number of slots used
03      refcount slot0
04..14  slot0  <- lowest bit must be 0 (to qualify as a cell-ptr!)
15      refcount slot1
16..26  slot1
27      refcount slot2
28..38  slot2
...
ed      refcount slot13
ee..fe  slot13
ff      unused
*** m1p2 page layout
provides space for structures with 8-13 fields
page type slot size 29 (refcount @ ptr-1) 8 slots total
math: first entry $10, refcount @ -1, next slot += $1e, slot-size = $1d (29)
offset content
--------------------
00      #b0001 0010 page type bucket + slot size 29
01      previous page
02      number of used slots
03..0f  unused
0f      refcount slot0
10..2c  slot0
2d      refcount slot1
2e..4a  slot1
4b      refcount slot2
4c..68  slot2
...
e1      refcount slot7
e2..fe  slot7
ff      unused
*** m1p3 page layout
page type slot size 49 (refcount @ ptr-1) 5 slots total
math: first entry $06, refcount @ -1, next slot += $32, slot-size = $31
offset content
--------------------
00      #b0001 0011
01      previous page
02      # of slots used
03..04  unused
05      refcount slot0
06..36  slot0
37      refcount slot1
38..68  slot1
69      refcount slot2
6a..9a  slot2
9b      refcount slot3
9c..cc  slot3
cd      refcount slot4
ce..fe  slot4
ff      unused
*** m1p4 page layout
page type slot size 83 (refcount @ ptr-1) 3 slots total
math: first entry $04, refcount @ -1, next slot += $54, slot-size = $53
offset content
--------------------
00      #b001 0100
01      previous page
02      number of slots used
03      refcount slot0
04..56  slot0
57      refcount slot1
58..aa  slot1
ab      refcount slot2
ac..fe  slot2
ff      unused
*** s8 page layout ?? 
page type slot size 8 (refcount @ ptr >> 3) 28 cells
offset content
--------------------
00      #b001x xxxx  page type + number of used slots
01      previous page
02..03  unused
04..1f  refcount cell 0..27
20..27   -> 04 (cell 0)
...
f8..ff  -> 1f (cell 27)
*** call-frame (stack organized) page layout
memory layout of call frame page (organized in stack)
offset  content
00      #b0001 1000 page type call-frame
01      previous page (just high byte), 00 for first stack page
02      top mark (one past last allocated frame payload) <- usually set once full)
03      payload of first call frame
...ff
*** fid->loc page layout
*** code page layout
*** cell-stack page layout (locals, eval stack)
- used for locals and for the evaluation stack
offset  content
---------------
00      page type #b0001 1011
01      previous page (of the stack)
02..ff  payload (either lowbyte or highbyte of the cell)

*** cell-array allocation-free
#+begin_src dot :file cell-array-page-state.gen.png
  digraph finite_state_machine {
      node [shape=point]ENTRY; //,EXIT
      node [shape=ellipse];

      ENTRY->free;
      free -> used[label="ALLOC_CELL_ARRAY_TO_RA"]
      used -> enqueued[label="FREE_CELL_ARRAY_IN_RA"]
      enqueued -> used[label="ALLOC_CELL_ARRAY_TO_RA"]
      enqueued -> enqueued[label="gc"]

      labelloc="t";
      label="cell-array state";
  }
#+end_src

#+RESULTS:
[[file:cell-array-page-state.gen.png]]
- free :: slot (cell-array) is NOT counted as used on m1-page
          points to the next free slot on this page (low byte), 0 = no next free.
          it is reachable through the first free slot on this page (VM​_PAGE​_SLOT​_DATA)
          refcount of this slot (cell-array) is 0 (no one keeps a reference to this cell pair)
- used :: cell-array is counted as used on m1-page
          it is NOT reachable through the first free slot on this page (VM​_PAGE​_SLOT​_DATA)
          it is NOT reachable through the queue root of arrays to free (VM​_Px​_QUEUE​_ROOT​_OF​_ARRAYS​_TO​_FREE)
          refcount to this cell-array is >0 (at least on reference to this cell-pair exists)
- enqueued :: cell-array is counted as used on m1-page
              it is NOT reachable through the first free slot on this page (VM​_PAGE​_SLOT​_DATA)
              it is reachable through the queue root of arrays to free (VM​_Px​_QUEUE​_ROOT​_OF​_ARRAYS​_TO​_FREE)
              refcount of this cell-array is 0 (no one keeps a reference to this cell pair)
              the array may still contain cells that are cell pointer that need to be garbage collected
              each gc reduces the amount of cell pointer in the array by 1
              the array keeps the amount of unchecked cells
              the array keeps a pointer to the next enqueued cell-array in the slot right behind the unchecked cells

** cell types and references
cell types fall into 3 categories
*** cell pointer
tag byte ends on bits 0 [cell-ptr], or 01 [cell-pair-ptr]
points somewhere.
- it points to another cell (points to either a cell pointer, a value cell or a header cell)
- it points to a cell-pair
*** value cell
a value cell holds its (complete) value
- int, tag byte  = 0... ..11 (& $83 = $03)
- byte, tag byte = 1111 1111 ($FF)
*** header cell
is a cell that is used as a header of a number of cells. the following headers exist
- header for an *array of cells* (useful for structures)
  tag byte = 1000 0011 ($83)
  offset  content        <- memory layout
  ------------------
  00      header-cell
  01      length of array (n+1)
  02..03  cell index 0 *)
  04..05  cell index 1
  ...
  ..n*2+3 cell index n

  *) cells in an array of cells may be either cell-ptr or value cells, never header cells!!

- header fo a *native array of bytes* (useful for strings)
  tag byte = 1000 0111 ($87)
  offset  content        <- memory layout
  ------------------
  00      header-cell
  01      length of byte array (n+1)
  02      byte index 0
  ...
  n+2     byte index n
** pointer tagging
RT = 00 (low byte) is equivalent to RT is empty!
use new pointer tagging scheme (makes tagged-low-byte obsolete):        examples (low, then high byte):
  zzzz zzz0 = cell-ptr (no change on cell-ptr pages)                    0000 001[0]    1100 1101   cx01 (second allocated slot in cell-ptr page)
  xxxx xx01 = cell-pair-ptr (change on cell-pair-ptr pages!)            0000 01[01]    1100 1101   cp01 (second allocated slot in a cell-pair-ptr page)
  0iii ii11 = int-cell (bool) (no direct adding of highbyte possible)   [0]000 10[11]  0001 1000   0218 (decimal 2*256+16+8 = 536) <- high byte comes first in this special int encoding
  1111 1111 = byte-cell (char|bcd digits)                               [1111 1111]    0000 0001   01  <- payload is in high byte

  --- header bytes (define elsewhere)
  1000 0011 = cell-array-header                                         [1000 0011]    0000 0100   04 cells in array
  1000 0111 = cell-native-array-header                                  [1000 0111]    0000 1000   08 bytes in array

  1000 1011   (29 values reserved)
  ...
  1111 1011
#+begin_src asm
  ;; check for cell-ptr
          AND !$01
          BEQ IS_CELL_PTR
          ;; alternatively
          LSR A
          BCC IS_CELL_PTR

  ;; check for cell-pair-ptr
          AND !$03
          CMP !$01
          BEQ IS_CELL_PAIR_PTR
          ;; alternatively
          LSR A
          ;; BCC IS_CELL_PTR
          LSR A
          BCC IS_CELL_PAIR_PTR

  ;; check for int-cell
          AND !$83
          CMP !$03
          BEQ IS_INT_CELL

  ;; check for byte-cell
          CMP !$FF ;; CMP !TAG_BYTE_BYTE_CELL
          BEQ IS_BYTE_CELL

  ;; check for cell-array-header
          CMP !$83 ;; CMP !TAG_BYTE_CELL_ARRAY
          BEQ IS_CELL_ARRAY_HEADER

  ;; check for cell-native-array-header
          CMP !$87 ;; CMP !TAG_BYTE_NATIVE_ARRAY
          BEQ IS_CELL_NATIVE_ARRAY_HEADER
#+end_src
** call frames
- a call frame is defined by the following variables (on the zero page)
  ZP_​​VM_​PC                    *  ptr to the current byte code
  ZP_​VM_​FUNC_​PTR              *  ptr to the current running function
  ZP_​​CELL​_​STACK​_​LB​_​PTR           ptr to the low byte of the cell stack (cell-eval-stack is spread over two pages) [the lb of this ptr itself is always 0]
  ZP_​CELL_​STACK_​HB_​PTR           ptr to the high byte of the cell stack [the lb of this ptr itself is always 0]
  ZP_​LOCALS_​LB_​PTR            *  ptr to the low bytes of the locals of the currently running function [lowbyte of the ptr itself is equal to the highbytes one]
  ZP_​LOCALS_​HB_​PTR            *  ptr to the high bytes of the locals of the currently running function [lowbyte of the ptr itself is equal to the lowbytes one]
  ZP_​CELL_​STACK_​TOP              index to the top element on the cell stack
 
  ZP_​CALL_​FRAME                  pointer to start of current call frame stack
  ZP_​CALL_​FRAME_​TOP_​MARK         index to byte behind current call frame stack (byte) (is stored into page at $02, when page is full)
- a stack frame pushed on to the stack can either be a slow/fast frame
- fast stack call frame (4b): allowed for calls w/o overflows (neither stack, nor local overflow nor function running over page boundary)

    |                  vm pc                  | <-- call-frame-ptr
    | func-ptr low-byte | locals-ptr low byte |   ;; locals-ptr low byte must be != $00/$01

    push: possible if - vm_​pc and func-ptr share the same page
                      - cell-stack does not overflow (has 16 entries reserve)
                      - locals do not overflow (has reserves to hold functions' need)
    pop: if (call-frame-tr + 3) != $00 (or $01), its a fast frame
- slow stack call frame (10b): allowed for any call (including page overflows: stack, locals allocation or function running over page boundary)

    |                   vm pc                     | <-- call-frame-ptr
    |     (reserved)       | locals ptr shared lb |
    | locals-lb page       | locals-hb-page       |
    |  func-ptr  low       | $00 / $01            | func-ptr could be encoded into: lowbyte, highbyte =  vm_​pc page + $00/$01 (of byte 4 in this stack) <- would save two bytes of stack size

    NOTE: if func-ptr page would be copied into (reserved), additional encoding/decoding into last byte could be removed, saving code bytes and complexity
          reserved byte could be used for somthing else, though => remove later?
          last byte must be either $00 or $01 to identify frame type!

    NOTE:  | cell-stack-lb page   | cell-stack-hb-page   | (copying the cell stack should not be necessary, the resulting stack should be cleaned up by the called method, known the # of parameters to actually remove etc.)
           cell-stack-tos  (copying not necessary!)

    push: all relevant data
    pop: if (call-frame-ptr + 9) == $00(or $01)), its a a slow frame
         in a slow frame, high byte of func-ptr is high byte of vm_​pc - byte at 9 (either 00 or 01)
** function metadata (descriptors)
 function descriptor:
 ---- idea
         function name
         length of function name
         default cell d-1       default cells can only be value cells or NIL ptr
    ...
         default cell 0
 ---- implemented
    00 : mddd llll  (#of locals in lower 4 bits, # of default values, m flag, indicating presence of function metadata)
    01 : start of byte code  (defaults offset?)
    ...

** locals
locals are organized as stack (page pair)
   00: page type           00: page type
   01: previous lb page    01: previous hb page
   02: top mark (filled when leaving this page)
   03: lowbyte cell 0      03: high byte cell 0
   ...

each cell can be either a cell pointer or a call value (never cell header)
** cell stack (evaluation stack)
cell-stack is organized as stack (page pair)
   00: page type           00: page type
   01: previous lb page    01: previous hb page
   02: lowbyte cell 0      02: high byte cell 0
   ...

each cell can be either a cell pointer or a call value (never cell header)
* concepts with functions
- page :: os allocation unit
  - alloc, free, bitmap of available pages
- cell :: smallest data unit
  - alloc, refcount, free, free-list, cells-page, cell-page-list
- cell-pair :: pair of cells, usable for lists etc.
  - alloc, refcount, free, free-list, cell-pairs-page, cell-pairs-page-list
- cell-array :: array of cells, need special incremental gc on free
  - alloc, refcount, inc-free, inc-free-list, m1px-page, m1px-page-list
- native-array :: array of native bytes (e.g. for strings)
  - alloc, refcount, free, free-list, m1px-page, m1px-page-list
- call-frame :: frame with data to restore upon return
- cell-stack :: a stack of cells (split over two pages)
  - eval-stack :: stack used for evaluation
    - pop->rt :: pop from eval stack into rt (discard previous rt)
    - push<-rt :: push rt onto eval stack (effectively a dub)
    - write->rt :: write tos of eval stack into rt
    - write<-rt :: write rt into tos of eval stack
  - locals-stack :: stack used for function locals storage
    - alloc :: allocate n cells
    - free :: free n cells
    - write-n->rt :: write n-th local to rt
    - write-rt->n :: write rt to n-th local
    - refcount-n-dec/inc :: refcount slot pointed to by n-th local
- Rx :: register
  - refcount-dec/inc :: refcount slot pointed to by register
  - clear :: mark as empty
* memory allocation/deallocation
** free-lists
*** cell-array free list (for reusage)
- one per m1 profile => free list holds arrays blocking a slot of a certain m1 profile page
root -> [tag-byte : len n]
        [cell0]
        [cell1]
        ...
        [cell n-1]
         \_...
- the last cell points to the next cell-array
- enqueueing this array to the free list, the last cell must be recount--
- all but the last cell must be refcount-- before further reuse
- once cell n-1 is recount--, n = n-1, making n-2 the next last cell
- once all cells were refcount--, the whole array can be freed
*** cell free list (for reusage)
root -> [cell]
         \_...
*** cell-pair free list (for reusage)
root -> [car][cdr]
         \_ [car][cdr]
             \_...
- car cell is used to connect the cell-pairs
- cdr cell needs to be refcount-- before reuse
** allocation
*** cell
- if free-list nil
     allocate new cell <- IDEA: try freeing slots in cell-array free-lists (there might be cells that can be reused)
     reuse head of free list
- reuse head of free list
  - remember head
  - set head of free list to cdr of free list
  - return old head
*** cell-pair
- if free-list nil
     allocate new cell-pair <- IDEA: try freeing slots in cell-array free-lists (there might be cell-pairs that can be reused)
     reuse head of free list
- reuse head of free list
  - remember head
  - refcount-- on cdr cell of head (single subroutine jump, no recursion)
  - new head = old heads car cell
  - return remembered head
*** cell-array
- if free-list nil
     allocate new cell-array
     free the array at the head of the list <- this might change due to the tail call
- free the array at the head of the list
  - reduce num (if num dropped to 0, the array can be reused)
  - remember now last cell
  - copy previous last cell into now last cell
  - refcount-- remembered now last cell  <- tail call (just jump, no recursion)
*** native-array
** deallocation
any refcount-- on a value cell will just return (and do nothing), ending a chain of refcount-- calls
only if refcount drops to zero a free is done, else refcount returns
*** refcount-- cell-ptr (drops to 0)
- enqueue cell into free list
  - put old root of free list into this
  - set root of free list to this cell
*** refcount-- cell-pair-ptr (drops to 0)
- remember car cell (since it is overwritten in next step and used for refcount-- later on)
- enqueue cell-pair into free list
  - put old root of free list into car of this
  - set root of free list to this cell-pair
- refcount-- car cell <- tail-call (just jump, no recursion)
*** refcount-- cell-array (drops to 0)
- remember last cell of the array (since it is overwritten in next step and used for refcount-- later on)
- enqueue cell-array into free list
  - put old root into last cell of array
  - set root of free list to this cell-array
- refcount-- last cell of the array
*** refcount-- native-array (drops to 0)
- reclaim space (native array may not hold further references)
** behavior
- overarching idea: make deallocation cheap, delay work to the time, allocation is done
- reuse of cell is of constant time, since the head of the free list can be used (directly) or a new cell is allocated, which is both O(1)
- reuse of cell-pair can be O(n) in worst case, if the cdr cell of the head (which needs to be refcount--) points to a tree of n cell-pairs,
  where each car points to another cell-pair that needs to be refcount-- before enqueued into the free-list.  it is more likely to be must
  faster since this worst case is of rather hypothetical nature.
  IDEA: this time can be reduced by incrementally refcount-- cdr cells of the free list (e.g. during allocation of cells or cell-pairs).
- reuse of cell-arrays could be very expensive if the array contains pointers to cell-arrays up to the max memory allocated thus
  IDEA: this time can be reduced by incrementally refcount-- cells of the array (e.g. during allocation of cells or cell-pairs).
** musings
*** bst with value implemented with structure/array or cell-pairs
**** btree with array, fits into profile 5 (uses 9 bytes)
[table-header, len=3]
[left cell-ptr]
[right cell-ptr]
[value cell-ptr|cell]
**** btree with cell-pairs (uses 8 bytes for the cell pairs)
      o      cell-pair
     / \
   val  o    cell-pair
       / \
      L   R
**** red-black tree needs additional flag (for color)
- in arrays this could be put into higher bits of the length byte (since not all bits are used)
  -or- use the 9th byte of the structure as an auxiliary byte that is always available
- in cell-pair implementation L and R lower two bits can be used <- complicates a lot, don't!
  (since they must be '01' to identify them as cell-pair-ptr)
**** red/black btree with cell-pairs
***** red/black detection needs more code, search l/r search needs more code, no more memory is needed
(val may not be a cell-pair-ptr)
red-node
      o
     / \
   val  o
       / \
      L   R

black-node
      o
     / \
    o   val
   / \
  L   R
***** red/black as additional cell-pair, code stays uniform, + 1 cell-pair for each node (total 12 bytes)
    o
   / \
 R/B  o
     / \
   val  o
       / \
      L   R
* log
** GC usage of RA RT
- RT may be used for regular dec/inc of refcount
- RA may be used for regular dec/inc of refcount
- RT may NOT be overwritten/written to during more complex GC
- RA may be overwritten/written to during more complex GC
=> GC: may leave RA in an undefined state
   GC may not change RT (except for temporary stuff)
=> more complex GC operations should copy RT->RA first and then operate on RA only
   collecting complex structures (e.g. pair cells or arrays) may need RA and additional memory space/register
   => do not use RT, use RZ <- new register for special gc stuff?  
** IDEA use locals as array registers (alternative to dedicated array registers)
- instead of
  #+begin_src scheme
    (bc PUSH_Lx)           ;; extra push of array reference on stack
    (bc GET_AF_y)      ;; removes array reference from stack, pushing the field value of the array
  #+end_src
- keep array in local (no special ref couting compared to regular locals)
  #+begin_src scheme
    (bc PUSH_ARRAY_LOCAL_0_FIELD_y)  ;; use local0 as array register to push field y onto stack
  #+end_src
- addition bytecode commands
  - +pop from eval stack to array register+
  - +clear array-register <- automatically done on return/call just as locals?+
  - +push from array register to eval stack <- really necessary?+
  - push field y from array in local x
  - pop/write stack to field y of array in local x
- combinations (have 2 arrays to select from, read local0, read/write local1, write local2)
  #+begin_src scheme
    ;; single (compact) byte code
    PUSH_ARRAY_LOCAL_0-1_FIELD_0-3     ;; 8 byte codes
    POP_TO_ARRAY_LOCAL_1-2_FIELD_0-3   ;; 8 byte codes
    WRITE_TO_ARRAY_LOCAL_1-2_FIELD_0-3 ;; 8 byte codes

    ;; byte code with 1 byte operand
    PUSH_ARRAY_LOCAL_FIELD     LOCAL_FIELD_ID_BYTE  ;; lllfffff = locals 0-7, fields 0-31
    POP_TO_ARRAY_LOCAL_FIELD   LOCAL_FIELD_ID_BYTE
    WRITE_TO_ARRAY_LOCAL_FIELD LOCAL_FIELD_ID_BYTE
  #+end_src
** OBSOLETE IDEA more compact bytecode for array access (using array registers)
- instead of
  #+begin_src scheme
    (bc PUSH_Lx)           ;; extra push of array reference on stack
    (bc GET_AF_y)      ;; removes array reference from stack, pushing the field value of the array
  #+end_src
- keep array e.g. in R0 (arrays in registers are refcounted once, and discarded explicitly)
  #+begin_src scheme
    (bc PUSH_ARRAY_R0_FIELD_y)  ;; use array register r0 to push field y onto stack
  #+end_src
- addition bytecode commands
  - pop from eval stack to array register
  - clear array-register <- automatically done on return/call just as locals?
  - push from array register to eval stack <- really necessary?
  - push field y from array in register x
  - pop/write stack to field y of array in register x
** IDEA RT, RA and array registers
- RT is part of the stack
  => manipulation = stack manipulation
     this can be done if actually doing evaluation (e.g. int+ ...)
     can be done if finally thrown away (popped) (e.g. during gc on pop)
- RA is a register to be used if RT cannot be modified?
  how about using it for gc only (no longer use rt fo gc operations)?
- keep registers for array operations (instead of constantly pushing it on the stack, for field access)
** DONE call-frames
 ZP_​​VM_​PC                    *  ptr to the current byte code
 ZP_​VM_​FUNC_​PTR              *  ptr to the current running function
 ZP_​​CELL​_​STACK​_​LB​_​PTR           ptr to the low byte of the cell stack (cell-eval-stack is spread over two pages) [the lb of this ptr itself is always 0]
 ZP_​CELL_​STACK_​HB_​PTR           ptr to the high byte of the cell stack [the lb of this ptr itself is always 0]
 ZP_​LOCALS_​LB_​PTR            *  ptr to the low bytes of the locals of the currently running function [lowbyte of the ptr itself is equal to the highbytes one]
 ZP_​LOCALS_​HB_​PTR            *  ptr to the high bytes of the locals of the currently running function [lowbyte of the ptr itself is equal to the lowbytes one]
 ZP_​CELL_​STACK_​TOP              index to the top element on the cell stack

 ZP_​CALL_​FRAME                  pointer to start of current call frame 
 ZP_​CALL_​FRAME_​TOP_​MARK         index to byte behind current call frame (byte) (is stored into page at $02, when page is full)

 fast stack call frame (4b): allowed for calls w/o overflows (neither stack, nor local overflow nor function running over page boundary)

    |                  vm pc                  | <-- call-frame-ptr
    | func-ptr low-byte | locals-ptr low byte |   ;; locals-ptr low byte must be != $00/$01
                                                
    push: possible if - vm_​pc and func-ptr share the same page
                      - cell-stack does not overflow (has 16 entries reserve)
                      - locals do not overflow (has reserves to hold functions' need)
    pop: if (call-frame-tr + 3) != $00 (or $01), its a a fast frame

 slow stack call frame (10b): allowed for any call (including page overflows: stack, locals allocation or function running over page boundary)

    |                   vm pc                     | <-- call-frame-ptr
    |     (reserved)       | locals ptr shared lb |  
    | locals-lb page       | locals-hb-page       |
    |  func-ptr  low       | $00 / $01            | func-ptr could be encoded into: lowbyte, highbyte =  vm_​pc page + $00/$01 (of byte 4 in this stack) <- would save two bytes of stack size

    NOTE: if func-ptr page would be copied into (reserved), additional encoding/decoding into last byte could be removed, saving code bytes and complexity
          reserved byte could be used for somthing else, though => remove later?
          last byte must be either $00 or $01 to identify frame type!

    NOTE:  | cell-stack-lb page   | cell-stack-hb-page   | (copying the cell stack should not be necessary, the resulting stack should be cleaned up by the called method, known the # of parameters to actually remove etc.)
           cell-stack-tos  (copying not necessayr!)
                                                
    push: all relevant data
    pop: if (call-frame-ptr + 9) == $00(or $01)), its a a slow frame
         in a slow frame, high byte of func-ptr is high byte of vm_​pc - byte at 9 (either 00 or 01)

 function descriptor holds only # of locals needed (parameter number is meta data, that is not needed for interpretation)
 function descriptor:
    00 : #of locals
    01 : start of byte code  (defaults offset?)
    ...
    meta-data byte-code-len
              str-len
              function name string

 obsolete byte codes:
   any ...to_​param
       ...from_​param

 new byte codes:
   write_​to_​local#

 locals are stored on a stack (single page)
    00: page type
    01: previous page
    02: low byte cell 0
    03: high byte cell 0
    ...
 cell-stack is organized as stack (page pair)
    00: page type           00: page type
    01: previous lb page    01: previous hb page
    02: lowbyte cell 0      02: high byte cell 0
    ...

** DONE keep only parameters and the cell-eval-stack on the stack spread over two pages to make push and pop fast
       => zp_​cell_​stack_​lb_​ptr, zp_​cell_​stack_​hb_​ptr must be held (2 bytes each)
          the parameters may as well be on the cell-stack when entering the function and form the start of the stack for function execution
       all else (vm_​pc, func_​ptr, locals_​xb_​ptr, cell_​stack_​xb_​ptr) go into a separate stack to share page and make storing fast.

       locals are held in own dedicated stack (no fast pushing/popping necessary, but stacking during function call)

       fast stack call frame (size: 4b)
         pc (2b), func-ptr (1b, shares hb with pc), locals-ptr (1b <- no page change), cell-stack-base-ptr is kept

         cell-stack-base-ptr may change on function entry ->

       slow stack call frame (7+1)
         pc (2b), func-ptr (1+1b low byte + encoded page byte), locals-ptr (3b), 1 reserved (currently)

       call frame could be unified to 6 byte usage (pc 2, func 1(+1 encoded into locals-lb), locals 2+1)
         => copy 2 bytes more than fast frame (takes 20 cycles more), detection takes 14 cycles, still feasable to have slow and fast frames

       fast/slow detection push
         - func-page = pc-page
         - locals fit on same page in locals stack (lowbyte+2*n*locals < 256)
         - cell-stack-tos < 240 (enough space to stay on page)

       fast/slow detection pop
         (e.g. local stack holds byte for fast/slow call frame detection)
         (use the 10th byte in slow stack to mark it thus (eg 0|255) depending on what is impossible to be valid for slow stack values)

** DONE fast call stack
       measures:
         - less bytes to copy
         - reuse as much as possible
       current status:
         the following values are copied (constructed)
         ZP_​VM_​PC                  $de ;; program counter (ptr to currently executing byte code)
         ZP_​VM_​FUNC_​PTR            $e0 ;; pointer to the currently running function
         ZP_​PARAMS_​PTR             $e2 ;; pointer to first parameter in call-frame
         ZP_​LOCALS_​PTR             $e4 ;; pointer to first local in call-frame
         ZP_​CELL_​STACK_​BASE_​PTR    $e6 ;; e6..e7 (pointer to the base of the eval stack of the currently running function (+ZP_​CELL_​STACK_​TOS => pointer to tos of the call-frame, in register mode, actual TOS is ZP_​RT!)

         ZP_​CALL_​FRAME             $f1



         Stack (growing downwards)       Current ZP pointer settings
         
         |  param - 0            |  <-- params ptr
         |  . . .                |
         |  param - n            |
         |-----------------------|  
       * |         pc            |  <-- call frame 
         |-----------------------|
       * |       func ptr        |  (pc and func-ptr share high byte, if functions do not run over multiple pages)
         |-----------------------|
       * |      params ptr       |  (params high byte should be the same as this page, if call frame is allocated on same page)
         |-----------------------|
       * |      locals ptr       |  (locals high byte should be the same as this page, if call frame is allocated on same page)
         |-----------------------|
       * |  cell stack base ptr  |  (definitely same high byte as params ptr!)
         |-----------------------|
         |  local - 0            | <-- locals ptr = call frame + $0a (call frame is calculated from locals-ptr on return)
         |  . . .                |
         |  local - n            |
         |-----------------------|
         |                       | <-- cell stack base ptr

         *) fields are copied

       separate page stack allocation case
         |  param - 0            |  <-- params ptr       |-----------------------|                                                                                              
         |  . . .                |                     * |         pc            |  <-- call frame                                                                                
         |  param - n            |                       |-----------------------|                                                                                              
         |-----------------------|                     * |       func ptr        |  (pc and func-ptr share high byte, if functions do not run over multiple pages)              
       (no more space left on page)                      |-----------------------|                                                                                              
                                                       * |      params ptr       |  (params high byte should be the same as this page, if call frame is allocated on same page) 
                                                         |-----------------------|                                                                                              
                                                       * |      locals ptr       |  (locals high byte should be the same as this page, if call frame is allocated on same page) 
                                                         |-----------------------|                                                                                              
                                                       * |  cell stack base ptr  |  (definitely same high byte as locals ptr!)                                                  
                                                         |-----------------------|                                                                                              
                                                         |  local - 0            | <-- locals ptr = call frame + $0a (call frame is calculated from locals-ptr on return)         
                                                         |  . . .                |                                                                                              
                                                         |  local - n            |                                                                                              
                                                         |-----------------------|                                                                                              
                                                         |                       | <-- cell stack base ptr = locals ptr + 2*(n+1)


    => current call frame            \
       current locals ptr            |  always share the same page (high byte)
       current call stack base ptr   /

** DONE define fast frames (allocated on same stack page, and pc and func ptr share the same page)

       popping call frames
       how can a fast frame be identified? (e.g. check locals ptr - call frame = $06) <- save copying 4 bytes?
           SEC                ;;               (2)      ;; copying 4 bytes  [15*4 = 60 cycles]
           LDA ZP_​​LOCALS_​PTR  ;; low byte      (3)      ;; LDA (zp-ptr),y         (6)
           SBC ZP_​CALL_​FRAME  ;;               (3)      ;; STA zp-memory,y        (4) <- only avail for non zp memory
           CMP !#06           ;;               (2)      ;; DEY                    (2)
           BEQ SLOW_​FRAME     ;;               (2-3)    ;; BNE LOOP               (2-3)
                                               ---SUM 12                         ---SUM 60 (15*4)
        write highbyte for params ptr, locals ptr, csb ptr + func ptr
          LDA (ZP_​...),y               ;;   (6)
          STA ZP_​LOCALS_​PTR+1          ;;   (3)
          STA ZP_​PARAMS_​PTR+1          ;;   (3)
          STA ZP_​CELL_​STACK_​BASE_​PTR+1 ;;   (3)
          LDA (ZP_​...),y               ;;   (6)
          STA ZP_​VM_​FUNC_​PTR+1            ;;   (3)
                                           ---SUM 24

       => save 24 (60 - 12 - 24) cycles per fast frame pop
          add 13 cycles per slow frame pop
          add 9 bytes detect routine
          add x bytes for fast pop code


       pushing fast frames
       how to detect that fast frame can be used? 
           1st check that func ptr and pc share the same high byte (this has to be done additionally)
               LDA ZP_​VM_​PC+1     ;;               (3)
               CMP ZP_​VM_​FUNC_​PTR+1  ;;               (3)
               BNE SLOW_​FRAME     ;;               (2-3)
                                        
           2nd stack allocation stays on same page (this is done anyhow)
      => save 52 (60-8) cycles per fast push  (copying takes as long as in pop case)
         add 9 cycles per slow push
         add 6 bytes detection routine
         add x bytes for fast push code
         save 4 bytes on call-stack per call
         

         |  param - 0              |  <-- params ptr
         |  . . .                  |
         |  param - n              |
         |-------------------------|  
       * |          pc             |  <-- call frame 
         |------------+------------|
       * | params ptr | locals ptr | 
         |------------+------------|
       * |  csb ptr   | func ptr   |
         |------------+------------|
         |  local - 0              |  <-- locals ptr = call frame + $06 (call frame is calculated from locals-ptr on return)
         |  . . .                  |
         |  local - n              |
         |-------------------------|
         |                         |  <-- cell stack base ptr
** IDEA *fast locals* on zero page (just as regular locals, but not allocated on the stack but on zero page)
       possible for functions that do not call subroutines, or do so but the local is no longer used
       use short bytecodes for params 0..3, locals 0..3, fast-locals 0..3

** IDEA low-byte high byte on different pages
use the following idea in more situations:
       store high byte in one page
       and store low byte in another page (same index)
       32 bit values may as well be spread of 4 pages, storing all at one index!
       e.g: cell-value-stack (since cells are always 16 bit)
            store lowbyte in page I
            store highbyte in page J
       advantage: use same index (for pop/push inc/dec only once)
                  doubles the number of objects before new allocation is needed
                  e.g. push a value onto the stack:
                       ZP_​CS_​LB_​PAGE (cell-stack page of low bytes) (ZP_​CS_​LB_​PAGE-1 contains 0) such that ZP_​CS_​LB_​PAGE-1 can be used as ptr
                       ZP_​CS_​HB_​PAGE (cell-stack page of high bytes) (ZP_​CS_​HB_​PAGE-1 contains 0) such that ZP_​CS_​LB_​PAGE-1 can be used as ptr
                       ZP_​CS_​IDX is the current tos

                       ;; PUSH A/X onto stack
                       LDY ZP_​CS_​IDX
                       INY                       ;; just one increment
                       STA (ZP_​CS_​LB_​PAGE-1),y
                       STX (ZP_​CS_​HB_​PAGE-1),y
                       STY ZP_​CS_​IDX             ;; store new tos idx
                       ;; that's it

       are there any advantages to store cells in this way?
       where does the reference counting byte go in that case (maybe just into another page?)
       ==> cell-ptr's could be stored in 2+1 pages, lowbytes, highbytes and refcounts
           <-- not really, it would mean that each cell-ptr access needs to make use of two (different) pages
               which either are calculated (since allocated next to one another) or kept
       ==> cell-pair-ptr's could be stored in 4+1 pages, lowbyte car, highbyte car, lowbyte cdr, highbyte cdr, refcounts
           <-- not really, it would mean that each cell-ptr access needs to make use of four (different) pages
               which either are calculated (since allocated next to one another) or kept

** IDEA programs/processes have their own allocation pages => terminating a process means, all pages allocated by the process can be freed
       alternative: shared, process allocates using shared pages, terminating the process will free all entries (not the pages), possibly leading to pages, not freed, because some slots remain allocated.
       - each process has (a copy of) the following
         VM_​FREE_​CELL_​PAIR_​PAGE                 (1b)
         VM_​FREE_​CODE_​PAGE                      (1b)
         VM_​FREE_​CALL_​STACK_​PAGE                (1b)
         VM_​FREE_​CELL_​PAGE                      (1b)
         VM_​QUEUE_​ROOT_​OF_​CELL_​PAIRS_​TO_​FREE    (2b)
         VM_​FREE_​M1_​PAGE_​P0         (P0..P3)    (4b) 
         VM_​LIST_​OF_​FREE_​CELLS                  (2b)
       - each process running needs (a copy of) the following interpreter values
         (lots of these values are restored when returning from a function, maybe this can be used to not copy too much during process switch (after function or on function call)
         ZP_​CELL_​STACK_​TOS                      (1b)
         ZP_​VM_​PC                               (2b)
         ZP_​PARAMS_​PTR                          (2b)
         ZP_​LOCALS_​PTR                          (2b)
         ZP_​CELL_​STACK_​BASE_​PTR                 (2b)
         ZP_​CALL_​FRAME                          (2b)
         ZP_​RT                                  (2b)

** IDEA don't do any ref counting on register (RT, RA)
       inc ref count of cell, pointed to by RT if pushed on cell-stack (only if RT holds a pointer, of course) 
       dec ref count of cell, pointed to by TOS, if popped from cell-stack (into RT), only if TOS (then RT) holds a pointer
       additionally, if a pointer is written into a heap allocated object (e.g. cell-ptr, cell-pair-ptr, cell-m1-ptr), then the pointed to cells ref count is incremented
                     if a cell is written into a heap allocated object, overwriting a pointer, the pointed to cells ref count is decremented
                     if a heap allocated object is collected (ref count drops to 0), all referenced cells ref count is decremented
       is this enough?

** DONE pointer tagging
   RT = 00 (low byte) is equivalent to RT is empty!
   use new pointer tagging scheme (makes tagged-low-byte obsolete):            examples (low, then high byte):
     (new) zzzz zzz0 = cell-ptr (no change on cell-ptr pages)                  0000 001[0]    1100 1101   cd02 (first allocated slot in cell-ptr page)
     (new) xxxx xx01 = cell-pair-ptr (change on cell-pair-ptr pages!)          0000 01[01]    1100 1101   cd05 (first allocated slot in a cell-pair-ptr page)
     (new) 0iii ii11 = int-cell (no direct adding of highbyte possible)        [0]000 10[11]  0001 1000   0218 (decimal 2*256+16+8 = 536) <- high byte comes first in this special int encoding
     (new) 1111 1111 = byte-cell (char|bool|bcd digits)                        [1111 1111]    0000 0001   01  <- payload is in high byte
     (new) 1000 0011 = cell-array-header                                       [1000 0011]    0000 0100   04 cells in array
     (new) 1000 0111 = cell-native-array-header                                [1000 0111]    0000 1000   08 bytes in array 

     (new) cell-pair-ptr page layout
                       00     #b01xx xxxx page type + number of used slots
                       01     ref-count cell-pair at 05 (cell-pair 0)
                       02     ref-count cell-pair at 09 (cell-pair 1)
                       03..04  unused (2)
                       05..08  cell-pair 0
                       09..0c  cell-pair 1
                       0d..0f  unused (3)
                       10     ref-count for cell-pair at 40 (cell-pair 2)
                       11     ref-count for cell-pair at 44 (cell-pair 3)
                       ..3e    ref-count for cell-pair at f9 (cell-pair 48)
                       3f..40  unused (2)
                       41..44  cell-pair 2
                       45..48  cell-pair 3
                       ...
                       f9..fc  cell-pair 48
                       fd..fe  unused (2)
                       ff     previous page of this type

   implementation steps:
   - change int detection and calculation
   - change cell-array-header + cell-native-array-header detection (if applicable an existent)

** DONE if cell-ptr and cell-pair-ptr would use the bytes as is (with having to separately hold a tagged low byte),
       additionally masking out the tagged byte + copying during stack push and pop would not be necessary
       problem: lda (zp_​rt),y must then point to a cell or a cell-pair
                if cell-ptr lowbyte has at bit0 a 0 this would work
                however, cell-pair-ptr (to be able to differentiate from cell-ptr) would have to set bit0 to 1 and this lda (zp_​rt),y would point to a different location
                => cell-pair pages need to be organized differently (or cell pages)
                   current memory layout
                   page type: cell-pairs page (its actually randomly growing, fixed slot size (4b), ref counted page)
                   memory layout of a cell-pairs page (refcount @ ptr >> 2) 51 cells
                   offset content
                   00     #b01xx xxxx page type + number of used slots
                   01     ref-count for cell-pair at 04 (cell-pair 0)
                   02     ref-count for cell-pair at 08 (cell-pair 1)
                   03     ref-count for cell-pair at 0C (cell-pair 2)
                   04..07  cell-pair 0
                   08..0b  cell-pair 1
                   0c..0f  cell-pair 2
                   10     ref-count for cell-pair at 40 (cell-pair 3)
                   11     ref-count for cell-pair at 44 (cell-pair 4)
                   ..3e   ref-count for cell-pair at fc (cell-pair 49)
                   3f    unused
                   40     cell-pair 3
                   44     cell-pair 4
                   ..fb  cell-pair 49
                   fc..fe unused
                   ff    previous page of this type

                   old c004 = cell pair ptr,
                   new zzzz zzz0 = cell-ptr, xxxx xx01 = cell-pair-ptr (looses one cell-pair), 0iii ii11 = int (no direct adding of highbyte possible)
                       00
                       01     ref count cell pair at 05 (cellpair0)
                       02     ref-count for cell-pair at 08 (cell-pair 1)
                       03..04  unused
                       05..08  cell-pair 0
                       09..0c  cell-pair 1
                       0d..0f  unused
                       10     ref-count for cell-pair at 40 (cell-pair 2)
                       11     ref-count for cell-pair at 44 (cell-pair 3)
                       ..3e   ref-count for cell-pair at fc (cell-pair 48)
                       3f..40 unused
                       41     cell-pair 2
                       45     cell-pair 3
                       ..fc   cell-pair 48
                       fd..fe unused
                       ff    previous page of this type

                => alternative cell pages
                   current memory layout
                   page type cell page (slot size 2b) (refcount @ ptr >> 1) 84 cells (85th slot is used for previous page pointer)
                   offset content
                   00     #b1zzz zzzz page type + number of used slots
                   01     ref-count for cell at 02 (cell 0)
                   02..03 cell 0
                   04     ref-count for cell at 08 (cell 1)
                   ...
                   07     ref-count for cell at 08 (cell 4)
                   08..09 cell 1
                   ...
                   0e..0f cell 4
                   10    ref-count for cell at 20 (cell 5)
                   ...
                   1f    ref-count for cell at 20 (cell 20)
                   20..21 cell 5
                   ...
                   3e..3f cell 20
                   40..7e ref-count for cell at 80..fc (cell 21..83)
                   7f    unused
                   80..fd cell 21..83
                   fe    unused
                   ff    previous page of this type

                   old c002 = cell ptr,
                   new: zzzz zzz1 = cell-ptr (looses 3 cells), xxxx xx00 = cell-pair ptr (uses most compact layout), 0iii ii10 = int (no direct adding of highbyte possible!
                   new page layout
                       00        page type
                       01        ref count cell0
                       02        unused?
                       c003..c004 cell0
                       05         ref count cell1
                       ..
                       07         ref count cell3
                       0b..0c     cell 1 1011
                       0d..0e     cell 2 1101
                       10         ref count 3
                       11         ref count 4
                       ...
                       1f         unused?
                       21..22      cell3 0010 0001
                       ...
                       3d..3e      cell17 0011 1101
                       3f         unused?
                       40..7e      ref count for cell 81..fe (cell 18..80)
                       7f..80      unused?
                       81..82      cell 18 1000 0001
                       83..fc      cells 19..79
                       fd..fe      cell 80 1111 1101 .. 1111 1110
                       ff         previous page of this type

** DONE tos is always a register held in zp (e.g. now zp_​ptr, future zp_​rt)
       have additional "registers", capable of holding cells zp_​ra, zp_​rb ...
       push zp_​rt on stack only if necessary => operations working on one value only do no push/pop actions
         e.g. (car a-list), a-list is in zp_​rt, car replaces zp_​rt with the head of a-list, no stack op necessary!
              (push-int-0), pushes zp_​rt, putting int-0 into zp_​rt
              empty stack does now mean: no value on the stack and no value in zp_​rt
              pop: fill zp_​rt with new tos, popping it off the call-frame stack
              pop last item:  discard zp_​rt (and mark stack as empty)
              push on empty stack: write pushed into zp_​rt
              push non empty stack: push zp_​rt onto the stack in the call-frame and write pushed value into zp_​rt
              (cons a-val a-list): move a-val (from zp_​rt) to zp_​ra, pop (filling zp_​rt with a-list) execute cons, result in zp_​rt
       BENEFIT: - less actual pushes of values into the call-frame stack (e.g. car none at all)
                - call-frame stack size is always 1 item smaller!
                - maybe some harmonization of zp register usage?
       DRAWBACK: additional full/empty stack detection complexity (is it really complex? <- check before optimization)
                     <- ideas to prevent that (NONE IMPLEMENTED YET)
                        - statically compile first bytecode pushing into the stack
                          - with prefix byte code [adds 1 byte to each function]
                          - into specific byte code directly writing into zp_​rt [wastes available byte codes])
                          this could collide with tail call recursion
                          upon function call change behavior such that first push will not copy zp_​rt into stack (pop must be changed too)
                          and all subsequent calls do (e.g. change jump target, rechanging it to regular behavior)
                          pop might work accordingly (last actual stack manipulation will change pop/push target)
                        - require always 1 additional dummy local (before first actual stack entry)
                          this will allow to not have any special local but will loose the benefit of reduced stack size!

       common operations (should be derived from byte-code functions):
         start with car, cdr, cons, push: local/param/const, int+/-, call, tail-call?
         e.g. zp_​rt interpret as cell-pair-ptr, write, cellX of cell-pair into zp_​rt again (or some other register?) <- used for car/cdr
              zp_​rt interpret as cell-ptr, write cell pointed to into zp_​rt again (or some other register)?
              copy zp_​rt to other register (and vice versa)
              copy call-frame stack value @ idx into cellX of cell-pair, pointed to by zp_​rt
              write zp_​rt -> local / param of this function
              copy local/param -> cellX of cell-apri in zp_​rt
              copy call-frame stack value @ idx into array pointed to by zp_​rt

       possible implementation steps:
         implement in parallel to existing solution

** DONE no memory bitmap, use free slot bytes to encode whether page is free or not
 this would reduce complexity in finding free pages, free blocks of pages etc.
 (since free slots may never hold the value 00, 01, fe, ff, these values can be used to encode the state of the page
  e.g. 00 = allocated but full page (0 allows BEQ to be used easily to check whether page is full during slot allocation!)
       01 = system page (unavailable for memory management)
       ... = allocated with free slots
       fe = ???
       ff = free page,
** IDEA modules
 code pages - granularity: modules
 each module is loaded as a whole, modules should be unloadable, relocatable
 modules are restricted to max 256 (loaded)?
 loading a module does
   load all required modules (recursive until topmost module is found) <- no circles allowed
   resolve required modules functions/variables to ids <- must have been loaded
   assign ids to all functions/variables in this module
   patch own loaded bytecode to use (required modules or own) functions/variable ids (<- module needs patch table)
 unloading a module does
 relocating a module does
** IDEA dynamic/static function calls
 static calling a function does (e.g. w/i a module)
   allocate call-frame (#params + #locals is known)
   save current exec state->call frame
   jump to bytecode of function called (location is known)

 dynamic calling a function does
   resolve id to bytecode location (16-bit->16-bit translation)
   get #params
   get #locals (max)
   allocate call-frame
   save current exec state->call frame
   jump to bytecode of function called

 return from function does
   pop call frame (restoring saved exec state)

** DONE trace byte code execution
** IDEA collect metrics of calls
** DONE naming
 naming: atomic cell
         cell                      :: 16 bit value (finest granular memory managed block)
         atomic cell               :: a cell that has no followup value and is complete in itself (currently int-cell, byte-cell, cell-ptr, cell-pair-ptr)
         cell-ptr                  :: an atomic cell, lowest bit of low byte is set, points to a cell (of any type)
                                     lowbyte: #bxxxx xxx0
                                     highbyte = page
         cell-pair                 :: a pair of two cells, cell0 and cell1 (in memory: 00 lowbyte-cell0, 01 highbyte-cell0, 02 lowbyte-cell1, 03 highbyte-cell1),
                                     each cell can be of any atomic cell
         cell-pair-ptr             :: an atomic cell, second lowest bit is set, lowest bit is unset, points to a cell-pair
                                     lowbyte: #bxxxx xx01 
                                     highbyte = page
         int-cell                  :: an atomic cell having 13 bit as payload
                                     lowbyte mask: #b0xxx xx11, xxxxx = high bits of int
                                     highbyte = lowbyte of int
         byte-cell (char|bool)     :: an atomic cell having one byte as payload
                                     lowbyte mask: #b1111 1111
                                     highbyte = payload
         complex cell              :: a cell that functions as header for followup values (follows directly in memory)
                                     complex cells cannot be pushed on the stack, they can only be pointed to by cell-ptr!
         (cell-structure-header    :: a complex cell that defines a structure)
         cell-array-header         :: a complex cell that defines an array, defining the number of cells in the second byte
                                     a structure is an array of cells
                                     lowbyte mask: #b1000 0011
                                     highbyte: #of cells in this array
                                     n*2 bytes with cells <- each cell needs to be gc'ed separately
         cell-native-array-header  :: a complex cell that defines an array of bytes
                                     a string is an native array of bytes
                                     lowbyte mask: #b1000 0111
                                     highbyte: #of bytes in this array
                                     n bytes with byte payloads <- no gc of this necessary (holds plain values, no pointers, no cells)
         (cell-float-header        :: a complex cell that defines a float)
         page                      :: 256 byte memory managed unit, holding slots
         slot                      :: a fixed size portion of memory on a page (sizes are 2=cell, 4=cell=pair, 8 ...), only one size per page is allowed
         ref count                 :: byte counting how many pointers to this value exist, there can be pointer to pointers
         cell-stack aka eval-stack :: stack of cells. ZP_​CELL_​STACK_​TOS holds the index, ZP_​CELL_​STACK_​BASE_​PTR holds the pointer to the base
                                                                      [RT]         RT is the top of the stack (even though not on the stack memory wise)
                                                                  n*2 [cell n]     
                                                                      ...
                                                                  02  [cell 1]
                                      ZP_​CELL_​STACK_​BASE_​PTR -->  00  [cell 0]
                                      Each cell on the stack is organzed as 00 highbyte, 01 lowbyte, 02 ... next entry <- highbyte comes first
                                      ZP_​CELL_​STACK_​TOS points to the lowbyte of the current element below RT (cell n), = n*2+1

 naming: m1 page px       :: page for slots with ref count at -1 position, with profile x (0..3) <- defines size and payload start offset
         call-frame page  :: page for call-frames (stack organized, no ref counting etc.)
         cell-pairs page  :: page for cell-pairs, (lowbyte) lsr x 2 to get ref count position
         cell page        :: page for cells, (lowbyte) lsr x 1 to get ref count position (last cell unusable)
         [s8 page          :: page for slots of size <=8, (lowbyte) lsr x 3 to get ref count position] optional
         fid->loc page    :: page that maps a function id to a location of first byte code
         code page        :: page holding byte code (and function meta data, module meta data?)
         constants page   :: page holding constants (not ref counted)
         page block       :: a number of consecutive pages allocated/freed as a block, allowing for larger memory objects (having less wasted bytes (e.g. for call-frames)?)

** DONE keep allocated #slots to detect empty pages (# drops to zero)
** DONE page 00 = page mod byte
            1xxx xxxx = (cell page) page with cells (slots of byte 2), xxxxxx = number of used cells 0..127 (actually only 85 possible)
            01yy yyyy = (cell-pairs page) page with cell-pairs (slots of byte 4) yyyyy = number of cells used 0..63 (actually only 51 possible)
            [001z zzzz = (s8 page) page with slots of (max) size 8 byte, zzzz = number of slots used 0..31 (actually only possible)]
            0001 0000 = (m1 page p0) page with buckets type 0 (byte at offset 02: holds the number of used slots)
            0001 0001 = (m1 page p1) page with buckets type 1 (byte at offset 02: holds the number of used slots)
            0001 0010 = (m1 page p2) page with buckets type 2 (byte at offset 02: holds the number of used slots)
            0001 0011 = (m1 page p3) page with buckets type 3 (byte at offset 02: holds the number of used slots)
            0001 1000 = (call-frame page) (stack organized, full+free detection already implemented)
            0001 1001 = (fid->loc page) page with 16 bit values (starting at $02), filled without gaps, next slot = offset to free, no ref counting
            0001 1010 = (code page) page with byte code and function meta data <- filled without gaps, next slot = offset to free, no ref counting
            0001 1011 = cell stack page (come in pairs for low and high byte)
       page 01 = (code page, m1 page px, call-frame page, cell stack page) previous page of same type (<- currently only for pages with buckets and call-frame pages)
       page 02 = (m1 page px, s8 page) number of used slots, call-frame page: top mark (if full)
       page ff = (cell-pairs and cell page) previous page (in case of cell page = last cell stays unused!!)

 existing: array of first free slot on the respective page (per page) (uses only the lower 7 bits) : uses 256 bytes cf00..cfff (idea to keep this data on the page itself?)
           each page points to the previous page (initially in allocation order)                   : uses 1 byte on page
           each page type points to the head of the (free) page list of this type                  : 1 byte per type (currently 8) [current free]
 new:      head of list of pages that are completely free                                          : 1 byte per type

** IDEA allocate:
   during alloc (full): current page is full, find next non full (remove all fulls from this list from here on), set found non-full to current free
                        if no free is found, check list of completely free pages of this type,
                        if none is found, allocate new page (don't link with any full page!)
                        if none is left for allocation, check free list of other types
                        +- first free page pointer (points to full page, because it just got full)
                        [Ax]->[Bx]->[Cx]->[D-]->[E ]->[Fx]->[G-]
                   =>   remove full pages (their pointers must be cleared!) until first non full is found (or new pages is allocated)
                        +- first free page pointer
                        [D-]->[E ]->[Fx]->[G-]

   during free (full->non-full):  if already part of the free list, do nothing, if not, add it as head of the free list
   during free (non-full->empty): naive: free,
          idea: keep number of free pages per type, only free pages > than minimum
          idea: move this behind at the end of the list (if it is the head),
          idea: keep list of completely free pages to speed up allocation of this type (since page needs no initialization)

 worst case scenario:
   each bucket allocates until n pages are filled, then on each page all but 1 slots are freed => lots of pages with just one slot used
   (hopefully uncommon) Since no relocation of entries is possible, this "page"-level fragmentation is possible, even if unlikely

 to keep a list of pages with free slots, each time a slot is not full (free slot offset != $00), it should not have full pages before it
 => (alloc) a page getting full should be put behind the pages which have free slots
 => (free) a page not full anymore should be moved before the full ones
 algorithm:
   during alloc: page getting full (can be anywhere in the list) swaps down the list until the next is either $00 (no previous) or full itself
   during free:  page getting non-full (can be anywhere in the list) is put at the head of the free-page list
                 (or: optimization:) if the first is a non full page: right behind that one
                  -> this allows for a page that was "freshly" allocated to fill up before a page that has only one free slot is preferred
   during free:  a page that is left empty, is removed from the list and returned to the free pages
                 except if it is the last list of this type in the free list, then it is kept  (optimization: introduce a lower bound?, e.g. always keep 4+ free cell-pair pages to speed up allocation)

 page attributes:
  - stack growing :: data will be allocated/deallocated as stack
  - randomly growing :: data will allocate/deallocate randomly
  - variable slot size :: slots have any size within the same page
  - fixed slot size :: slots have one size (or smaller) within this page
  - ref counted :: slots are ref counted and deallocated if ref count drops to 0 (used only in randomly growing pages)

 valid combinations:
   stack growing, variable slot size :: used e.g. for call frame (stack)
   randomly growing, fixed slot size, ref counted  :: used e.g. for cell-pairs, cells, structures?
   randomly growing (but no deallocation), variable slot size, no ref couting :: permanent byte code routines

 measures to ensure ease of allocation/deallocation etc.
   stack growing
     keep backward pointer to previous slot / page (for pop)
     keep first free slot on page (for push)
   randomly growing
     keep first free slot on page (for alloc)
     keep an easy way to get to the next free slot/add a freed slot to the existing free slots
   ref counted
     keep ref count per slot (on page), with an easy way to get the offset from the slot offset
   fixed slot size
     free/used slots can be kept in a bitmap (but also in a free list)
   variable slot size
     free/used slots are kept in a list

 current page types and measures
   cell-pair-page
     - keep first free slot
     - keep free slots in a linked list
     - ref count is achieved by lsr x 2 (fixed size 4 bytes => 1 byte ref count)
   call-frame-page
     - keep first free slot (since this is global, this is held in zp_​call_​frame_​top_​mark
     - if full, keep top mark of this page 
     - keep id of previous page
   perma-bytecode-page
     - keep first free slot
     - keep id of previous page
     - if next allocation does not fit, check previous pages
   ref-counted-fixed-slot-page (cell-pair-page should be a special case for this)

 invariant: any slot must start on an even memory location (since bit0 is used as tag for a pointer)
 invariant: any cell-pair slot must start on a memory location divisable by 4 (since bit0 and bit1 is used as tag for the pointer)

 ---------------------------------------- call-frame page
 page type: call-frame page (its actually stack growing, variable slot size page)
 => allocation/deallocation is always done on tos
    no need for a free list (stack structure is coded into the stack pages)
    need for max size left
 memory layout of call frame page (organized in stack)
  00 : #b0001 1000 page type call-frame
  01 : previous page (just high byte), 00 for first stack page
  02 : top mark (one past last allocated frame payload
  03 : first frame payload byte 0
  ... : first frame payload byte size-1
  free-1 : size of (prev) frame
  free : next payload
 ...ff :

 VM_​FIRST_​FREE_​SLOT_​ON_​PAGE + pageidx: holds free-idx (initially 02) <- points to the first free byte (-1 = size of previous)

 OLD OUTDATED: SEE TOP OF FILE-------------------------------------- cell-pairs page
 page type: cell-pairs page (its actually randomly growing, fixed slot size (4b), ref counted page)
 memory layout of a cell-pairs page (refcount @ ptr >> 2) 51 cells
 offset content
 00     #b01xx xxxx page type + number of used slots
 01     ref-count for cell-pair at 04 (cell-pair 0)
 02     ref-count for cell-pair at 08 (cell-pair 1)
 03     ref-count for cell-pair at 0C (cell-pair 2)
 04..07  cell-pair 0
 08..0b  cell-pair 1
 0c..0f  cell-pair 2
 10     ref-count for cell-pair at 40 (cell-pair 3)
 11     ref-count for cell-pair at 44 (cell-pair 4)
 ..3e   ref-count for cell-pair at fc (cell-pair 50)
 3f    unused (1)
 40     cell-pair 3
 44     cell-pair 4
 ..fb   cell-pair 50
 fc..fe unused (3)
 ff    previous page of this type

 VM_​FIRST_​FREE_​SLOT_​ON_​PAGE + pageidx: holds the index within the page of the first free cell-pair on that page (0 = no free cell-pair on this page)
 the free cell-pair holds in byte 0 of the cell-pair the offset of the next free cell-pair (0 = no other free cell-pair)


 ---------------------------------------- cell page
 page type cell page (slot size 2b) (refcount @ ptr >> 1) 84 cells (85th slot is used for previous page pointer)
 offset content
 00     #b1zzz zzzz page type + number of used slots
 01     ref-count for cell at 02 (cell 0)
 02..03 cell 0
 04     ref-count for cell at 08 (cell 1)
 ...
 07     ref-count for cell at 0e (cell 4)
 08..09 cell 1
 ...
 0e..0f cell 4
 10    ref-count for cell at 20 (cell 5)
 ...
 1f    ref-count for cell at 3e (cell 20)
 20..21 cell 5
 ...
 3e..3f cell 20
 40..7e ref-count for cell at 80..fc (cell 21..83)
 7f    unused (1)
 80..fd cell 21..83
 fe    unused (1)
 ff    previous page of this type

 ---------------------------------------- s8 page
 page type slot size 8 (refcount @ ptr >> 3) 28 cells
 offset content
 00     #b001x xxxx  page type + number of used slots
 01     previous page
 02..03 unused
 04..1f refcount cell 0..27
 20..27  -> 04 (cell 0)
 ...
 f8..ff -> 1f (cell 27)

 ---------------------------------------- m1 page p0
 page type slot size 16!  (refcount @ ptr-1) 14 slots
 math: first entry $04, refcount @ -1, next slot += $12, slot-size = $11 (17)
 offset content
 00     #b0001 0000 page type bucket with slot size 17 (either use this or the one above)
 01     previous page
 02     number of slots used
 03     refcount slot0
 04..14 slot0
 15    refcount slot1
 16..26 slot1
 27    refcount slot2
 28..38 slot2
 ...
 ed    refcount slot13
 ee..fe slot13
 ff    unused


 ---------------------------------------- m1 page p1
 page type slot size 29! (refcount @ ptr-1) 8 slots total
 math: first entry $02, refcount @ -1, next slot += $1e, slot-size = $1d (29)
 offset content
 00     #b0001 0001 page type bucket + slot size 29
 01     previous page
 02     number of used slots
 03..0f unused
 0f     refcount slot0
 10..2c slot0
 2d     refcount slot1
 2e..4a slot1
 4b     refcount slot2
 4c..68 slot2
 ...
 e1    refcount slot7
 e2..fe slot7
 ff    unused

 ---------------------------------------- m1 page p2
 page type slot size 49! (refcount @ ptr-1) 5 slots total
 math: first entry $02, refcount @ -1, next slot += $32, slot-size = $31
 offset content
 00     #b0001 0010
 01     previous page
 02     # of slots used
 03..04 unused
 05     refcount slot0
 06..36 slot0
 37     refcount slot1
 38..68 slot1
 69     refcount slot2
 6a..9a slot2
 9b     refcount slot3
 9c..cc slot3
 cd     refcount slot4
 ce..fe slot4
 ff    unused

 ----------------------------------------m1 page p3
 page type slot size 83! (refcount @ ptr-1) 3 slots total
 math: first entry $02, refcount @ -1, next slot += $54, slot-size = $53
 offset content
 00     #b001 0011
 01     previous page
 02     number of slots used
 03     refcount slot0
 04..56 slot0
 57     refcount slot1
 58..aa slot1
 ab     refcount slot2
 ac..fe slot2
 ff     unused

** DONE zero page cell stack may not be beneficial (can be put in regular memory)
       LDA zeropage,x  consumes 4 clocks,  LDA (zeropage),y consumes 6 clocks => no significant speedup that would justify the amount of copying
       LDA zeropage and LDA absolute differs in speed => storing registers not accessed through index makes sense
       indirect addressing can only be done on zp => zp_​ptr and zp_​ptr2 make sense, too

       call frame is created by call, but there is not need to copy (portions of) the eval stack
       the call frame allocates space for locals and that's it (it's still a stack, so push/pop is supported)
       alternative to tos: function entry tos + index
         upon function entry, the fe tos is written (once) and a separate index is held in zero page
         such that fe0-tos + index = actual tos => push pop work in index only (restriction value stack w/i one page to 128 cells)
       alternative continuous stack space: allocate pages, but how? function call will fix the parameters => that part does not change
       within one function, one page is enough, but an almost full page could be a problem:
         one solution: page grows until function call, then, if page is free enough continues with the given page, if page is not enough allocated new one
         minimum free space = 16 cells? = 32 byte => 256 - 32 = 224 (roughly) are available, can be used in combination with call-frame
      zp_​vm_​params -> [params]            <- actually previous eval stack
        callframe:    -----               <- new allocation starts here
                      [old zp_​vm_​pc]      <- pointer to code to return to (zp_​vm_​pc)
                      [old zp_​vm_​locals]  <- used to restore zp_​vm_​locals
                      [old zp_​vm_​params]  <- used to restore zp_​vm_​params
      zp_​vm_​locals -> [locals]            <- fixed number of slots kept for function execution
         zp_​vm_​tos -> [eval-stack]        <- size must fit into page (16 cells) <- could later be derived from actual function implementation
                                            (part of the eval stack is then again [params] for the next function called)
 call to function:
      new zp_​vm_​params = zp_​vm_​tos - 2 * n-params (of the function called)
      allocated call frame [call-back] = zp_​vm_​pc
      new zp_​vm_​locals = allocated call frame + 6
      new zp_​vm_​tos    = allocated call frame + 2 * (n-locals + 3)  (of the function called)
      zp_​vm_​pc         = function called

 return from function:
      zp_​vm_​params     = (new) zp_​vm_​locals - 2 * (n-params + 3) (of function returned to)
      zp_​vm_​locals     = ? <- must be saved too
      zp_​vm_​tos        = (old) zp_​vm_​params - 2
      zp_​vm_​pc         = call-frame [call-back] = ((old) zp_​vm_​locals-6)

 NEW STACK STRUCTURE:
      ZP_​CELL_​STACK_​BASE_​PTR -> points to the start of the stack of the current (executing) function
      ZP_​CELL_​STACK_​TOS      -> offset for ZP_​CELL_​STACK_​BASE_​PTR, pointing to the tagged (low) byte, ff = empty, 01 = 1 el on stack, 03 = 2 el on stack ...
                                LDA (ZP_​CELL_​STACK_​BASE_​PTR),ZP_​CELL_​STACK_​TOS   = tagged low byte
                                LDA (ZP_​CELL_​STACK_​BASE_​PTR),ZP_​CELL_​STACK_​TOS-1 = high byte
                                => pushing is done in reverse order (push high byte first, then push tagged low byte)
                             reading tos:
                                LDY ZP_​CELL_​STACK_​TOS;
                                LDA (ZP_​CELL_​STACK_​BASE_​PTR),y  ;; gets tagged low byte
                                DEY
                                LDA (ZP_​CELL_​STACK_​BASE_​PTR),y  ;; gets untagged high byte

** IDEA use larger block page allocation (e.g. not used one page but 4 pages as a block => less waste
** DONE implement util function to provide labels with local suffix
- State "DONE"       from "TODO"       [2025-04-18 Fri 14:12]
- example: replace all labels and jumps to labels that end with ~__~ with ~__some_funcion~
 #+begin_src scheme
   (define some_function
     (add-label-suffix
      "__" "__some_function"
      (list
       (label "some_function")
              (ADC !$20)
              (BCC "local_label__")
              (RTS)
       (label "local_label__")
              (SBC !$20)
              (RTS))))
 #+end_src
 ... is then transformed to ...
 #+begin_src scheme
   (define some_function
     (list
      (label "some_function")
             (ADC !$20)
             (BCC "local_label__some_function")
             (RTS)
      (label "local_label__some_function")
             (SBC !$20)
             (RTS)))
 #+end_src
** DONE rename and do some modularization of functions using naming convention
- State "DONE"       from "IMPLEMENT"  [2025-04-20 Sun 12:00]
- use naming conventions in [[file:~/repo/+1/6510/TODO.org]]
- make functions composable to provide conceptual functions
- memory manager translation table
  | done | name                                        | new                              | type | note                                                               |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  | x    | alloc/free pages                            |                                  |      | R=rename, D=decomposition, C=complex refactoring                   |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  | x    | VM_FREE_PAGE                                | FREE_PAGE_A                      | R    |                                                                    |
  | x    | VM_ALLOC_PAGE__PAGE_UNINIT                  | ALLOC_PAGE_TO_X                  | R+   | make sure that allocated page is in A                              |
  | x    | VM_ALLOC_PAGE_FOR_CELLS                     | INIT_CELL_PAGE_X_TO_AX           | D    |                                                                    |
  | x    | VM_ALLOC_PAGE_FOR_CELL_PAIRS                | INIT_CELLPAIR_PAGE_AX            | D    | INIT_CELLPAIR_PAGE_X_TO_AX                                         |
  | x    | INIT_CELLPAIR_PAGE_A                        |                                  | C    | result is returned in X -> refactor to return in A                 |
  | x    | VM_ALLOC_CELL_STACK_PAGES                   | INIT_CELLSTACK_PAGE_X            | D    |                                                                    |
  | x    | VM_ALLOC_PAGE_FOR_M1_SLOTS                  | INIT_M1Px_PAGE_X_PROFILE_Y_TO_AX | D    |                                                                    |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  |      | alloc/free cells, pairs, slots              |                                  |      |                                                                    |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  | x    |                                             | GET_FRESH_CELL_TO_AX             |      | ensure ax points to allocatable cell (in free list of page)        |
  | x    |                                             | GET_FRESH_CELLPAIR_TO_AX         |      |                                                                    |
  | ?    |                                             | GET_FRESH_CELLARR_TO_AX          |      |                                                                    |
  | x    | VM_ALLOC_CELL_ON_PAGE                       | ALLOC_CELL_AX_TO_RT              | D    |                                                                    |
  | x    | VM_ALLOC_CELL_PTR_TO_RT                     | ALLOC_CELL_TO_RT                 |      |                                                                    |
  | x    |                                             | ALLOC_CELL_PFL_X_TO_RT           |      | from local free list of the page                                   |
  | x    |                                             | ALLOC_CELL_GFL_TO_RT             |      | from global free list of the page                                  |
  | x    | VM_ALLOC_CELL_PAIR_ON_PAGE_A_INTO_RT        | ALLOC_CELLPAIR_AX_TO_RT          | D    |                                                                    |
  | x    | VM_ALLOC_CELL_PAIR_PTR_TO_RT                | ALLOC_CELLPAIR_TO_RT             | D    | ensure that RT holds ptr to new cell-pair                          |
  | x    |                                             | ALLOC_CELLPAIR_PFL_X_TO_RT       |      | get cell-pair from page (X) free list,                             |
  | x    |                                             | ALLOC_CELLPAIR_GFL_TO_RT         |      | get cell-pair from global free list                                |
  | x    | VM_FREE_CELL_PAIR_PTR_IN_RT                 | FREE_CELLPAIR_RT                 | D    |                                                                    |
  | ?    |                                             | ADD_CELLPAIR_RT_TO_GFL           |      | add freed cell-pair to global free list (is integral part of free) |
  | x    |                                             | ADD_CELLPAIR_RT_TO_PFL_X         |      | add freed cell-pair it to the page (X) free list                   |
  | x    | VM_FREE_CELL_PAIR_PTR_IN_RA                 | FREE_CELLPAIR_RA                 |      |                                                                    |
  | x    | VM_FREE_CELL_PTR_IN_RT                      | FREE_CELL_RT                     |      |                                                                    |
  | ?    |                                             | ADD_CELL_RT_TO_GFL               |      | add freed cell to global free list                                 |
  | ?    |                                             | ADD_CELL_RT_TO_PFL_X             |      | add freed cell it to the page (A) free list                        |
  | x    | VM_FREE_CELL_PTR_IN_RA                      | FREE_CELL_RA                     |      |                                                                    |
  | x    | VM_GC_QUEUE_OF_FREE_CELL_PAIRS              | GC_CELLPAIR_FREE_LIST            |      |                                                                    |
  | x    | ;; VM_ALLOC_NATIVE_ARRAY_TO_ZP_PTR2         |                                  |      |                                                                    |
  | x    | VM_ALLOC_CELL_ARRAY_TO_RA                   | ALLOC_CELLARR_TO_RA              |      |                                                                    |
  | x    | ;; VM_ALLOC_M1_SLOT_TO_ZP_PTR2              | ?                                |      |                                                                    |
  | x    | ;; VM_FREE_M1_SLOT_IN_ZP_PTR2               | ?                                |      |                                                                    |
  |      | ;; VM_ALLOC_MODULE_CODE_SLOT_TO_ZP_PTR      | ?                                |      |                                                                    |
  |      | ;; VM_FREE_MODULE                           | ?                                |      |                                                                    |
  |      | ;; VM_RELOCATE_MODULE_X_TO_                 | ?                                |      |                                                                    |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  | x    | refcount                                    |                                  |      |                                                                    |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  | x    | VM_REFCOUNT_DECR_RT                         | DEC_REFCNT_RT                    |      |                                                                    |
  | x    | VM_REFCOUNT_INCR_RT                         | INC_REFCNT_RT                    |      |                                                                    |
  | x    | VM_REFCOUNT_DECR_RT__CELL_PAIR_PTR          | DEC_REFCNT_CELLPAIR_RT           |      |                                                                    |
  | x    | VM_REFCOUNT_DECR_RT__CELL_PTR               | DEC_REFCNT_CELL_RT               |      |                                                                    |
  | x    | VM_REFCOUNT_INCR_RT__CELL_PAIR_PTR          | INC_REFCNT_CELLPAIR_RT           |      |                                                                    |
  | x    | VM_REFCOUNT_INCR_RT__CELL_PTR               | INC_REFCNT_CELL_RT               |      |                                                                    |
  | x    | VM_REFCOUNT_DECR_RA                         | ?                                |      |                                                                    |
  | x    | VM_REFCOUNT_DECR_RA__CELL_PAIR_PTR          | ?                                |      |                                                                    |
  | x    | VM_REFCOUNT_DECR_RA__CELL_PTR               | ?                                |      |                                                                    |
  | x    | VM_REFCOUNT_INCR_RA__M1_SLOT                | INC_REFCNT_M1_SLOT_RA            |      |                                                                    |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  |      | misc                                        |                                  |      |                                                                    |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  |      | ;; VM_REMOVE_FULL_PAGES_FOR_PTR2_SLOTS      |                                  |      |                                                                    |
  |      | ;; VM_ENQUEUE_PAGE_AS_HEAD_FOR_PTR2_SLOTS   |                                  |      |                                                                    |
  |      | ;; VM_GC_ARRAY_SLOT_PTR                     |                                  |      |                                                                    |
  |      | VM_FREE_PTR_IN_RT                           |                                  |      |                                                                    |
  |      | VM_ADD_CELL_PAIR_IN_RT_TO_ON_PAGE_FREE_LIST |                                  |      |                                                                    |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  | x    | CELL_STACK / RT / RA                        |                                  |      |                                                                    |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  | x    | VM_CELL_STACK_POP_R                         | POP_CELL_EVLSTK_TO_RT            |      |                                                                    |
  | x    | VM_CELL_STACK_PUSH_R                        | PUSH_RT_TO_EVLSTK                |      |                                                                    |
  | x    | VM_CELL_STACK_PUSH_el                       | PUSH_el_TO_EVLSTK                |      |                                                                    |
  | x    | ;; vm_cell_stack_push_rt_if_nonempty        | PUSH_RT_TO_EVLSTK_IF_NONEMPTY    |      |                                                                    |
  | x    | ;; VM_WRITE_INTm1_TO_RA                     | WRITE_INTm1_TO_RA                |      |                                                                    |
  | x    | ;; VM_WRITE_INTm1_TO_RT                     | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INTm1_TO_Rx                     | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT1_TO_RA                      | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT1_TO_RT                      | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT1_TO_Rx                      | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT0_TO_RA                      | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT0_TO_RT                      | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT0_TO_Rx                      | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT_A_TO_RA                     | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT_A_TO_RT                     | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT_A_TO_Rx                     | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT_AY_TO_RA                    | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_INT_AY_TO_RT                    | .                                |      |                                                                    |
  | x    | VM_WRITE_INT_AY_TO_Rx                       | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_NIL_TO_RA                       | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_NIL_TO_RT                       | .                                |      |                                                                    |
  | x    | VM_WRITE_NIL_TO_Rx                          | .                                |      |                                                                    |
  | x    | VM_WRITE_RT_CELL1_TO_RT                     | WRITE_RT_CELL1_TO_RT             |      |                                                                    |
  | x    | VM_WRITE_RT_CELL0_TO_RT                     | .                                |      |                                                                    |
  | x    | VM_WRITE_RT_CELLy_TO_RT                     | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_RA_CELL1_TO_RT                  | .                                |      |                                                                    |
  | x    | ;; VM_WRITE_RA_CELL0_TO_RT                  | .                                |      |                                                                    |
  | x    | VM_WRITE_RA_CELLy_TO_RA                     | .                                |      |                                                                    |
  | x    | VM_WRITE_RA_TO_CELLy_RT                     | .                                |      |                                                                    |
  | x    | VM_WRITE_RT_CELL1_TO_RA                     | .                                |      |                                                                    |
  | x    | VM_WRITE_RT_CELL0_TO_RA                     | .                                |      |                                                                    |
  | x    | VM_WRITE_RT_CELLy_TO_RA                     | .                                |      |                                                                    |
  | x    | VM_WRITE_RT_TO_CELLy_RA                     | .                                |      |                                                                    |
  | x    | VM_CP_RT_TO_RA                              | COPY_RT_TO_RA                    |      |                                                                    |
  | x    | VM_CP_RA_TO_RT                              | COPY_RA_TO_RT                    |      |                                                                    |
  | x    | VM_POP_FSTOS_TO_CELLy_RT                    | POP_CELL_EVLSTK_TO_CELLy_RT      |      |                                                                    |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  |      | VM_QUEUE_ROOT_OF_CELL_PAIRS_TO_FREE         | GLOBAL_CELLPAIR_FREE_LIST        |      |                                                                    |
  |      | VM_FREE_CELL_PAIR_PAGE                      | GLOBAL_CELL_PAGE_FOR_ALLOC       |      |                                                                    |
  |      | VM_LIST_OF_FREE_CELLS                       | GLOBAL_CELL_FREE_LIST            |      |                                                                    |
  |      | VM_MEMORY_MANAGEMENT_CONSTANTS              | CONST_MEMORY_MANAGER             |      |                                                                    |
  |      | VM_INITIALIZE_MEMORY_MANAGER                | INIT_MEMORY_MANAGER              |      |                                                                    |
  |------+---------------------------------------------+----------------------------------+------+--------------------------------------------------------------------|
  | x    | VM_CELL_STACK_PUSH_ARRAY_ATa_RA             | PUSH_ARR_ATa_RA_TO_EVLSTK        |      |                                                                    |
  | x    | VM_CELL_STACK_WRITE_TO_RT_ARRAY_ATa_RA      | WRITE_ARR_ATa_RA_TO_RT           |      |                                                                    |
  | x    | VM_CELL_STACK_WRITE_RT_TO_ARRAY_ATa_RA      | WRITE_RT_TO_ARR_ATa_RA           |      |                                                                    |
** DONE labels in debugger
- State "DONE"       from "IMPLEMENT"  [2025-05-01 Thu 11:56]
- [X] add all labels to the debugger
- [X] list labels (with addresses) matching regex
- [X] get address for (one) label
- [X] use labels in place of addresses in all debug commands
  - [X] set break point at label
** DONE cell deallocation
instead of implementing free for RT and RA, implement one function, copying RT/RA to (e.g. RZ) and work on RZ
(todo: copy algorithms from notebook into here!)
- plan to do deallocation of different cell types (free is done if refcnt drops to 0)
  - free rt
    find pointer type of rt and call
    either free cell, free cell-pair, free cell-array of free native-array
  - free cell (ptr)
    [RT] -> [cell X]  ->?
    if cell X is a pointer, mark cell X for further free
    add cell X to free list of cells
    if cell X is a pointer, marked for further free: rt = cell x, (tail) call free rt
  - free cell-pair
    [RT] -> [cell A][cell B]
    if cell A is a pointer, mark cell A for further free
    add cell-pair to freeable list of cell-pairs
    if call A is a pointer, marked for further free: rt = cell A, (tail) call free rt
  - free cell-array
    [RT] -> [cell 0]...[cell n-1]
    find first cell pointer going from cell n-1 downwards and mark it for further free
    mark cell-array to be free up to the marked cell
    add cell-array to list of freeable cell-arrays
    if marked cell was a pointer: rt = cell m, (tail) call free rt
  - free native-array
    [RT] -> native array
    simply add this slot to the free list and return
- plan to further free (incrementally) freeable elements
  - freeable cell-pair list (? necessary ? can be done during allocation) [e.g. during alloc of cell-pairs]
    [cell A][cell B] = head of freeable list, cell A points to next in list
    pop from freeable list and push to free list
    if cell B is a pointer, RZ=cell B, call free RZ
  - freeable cell-array list [e.g. during alloc of cells of type of this array]
    cell-array = head of freeable cell-array list
    find first cell pointer going from cell n-1 downwards and mark it for further free
    mark cell-array to be free up to the marked cell
    if marked cell was a pointer: rc = cell m, (tail) call free rc
- new functions
|                                                  | i=implemented   |                                                                                                                                                                              |
|                                                  | t=tested        |                                                                                                                                                                              |
|                                                  | -=impl. incomp. |                                                                                                                                                                              |
| fname                                            | status          | description                                                                                                                                                                  |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NEW_DEC_REFCNT_CELL_RZ                           | i               | specific dec refcnt cell, possible free if refcnt drops to 0                                                                                                                 |
| NEW_DEC_REFCNT_CELL_RT                           | i               | prefix new_dec_refcnt_cellpair_rc with cp rt->rc                                                                                                                             |
| NEW_DEC_REFCNT_CELL_RA                           | i               | prefix new_dec_refcnt_cellpair_rc with cp ra->rc                                                                                                                             |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NEW_DEC_REFCNT_CELLPAIR_RT                       | i               | prefix new_dec_refcnt_cellpair_rc with cp rt->rc                                                                                                                             |
| NEW_DEC_REFCNT_CELLPAIR_RA                       | i               | prefix new_dec_refcnt_cellpair_rc with cp ra->rc                                                                                                                             |
| NEW_DEC_REFCNT_CELLPAIR_RZ                       | i               | specific dec refcount of cellpair, possible free if refcnt drops to 0                                                                                                        |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NEW_DEC_REFCNT_M1_SLOT_RZ                        | i               | specific dec refcnt of m1 slot, possible free if refcnt drops to 0                                                                                                           |
| NEW_DEC_REFCNT_CELLARR_RZ                        | i               | specific dec refcnt of cellar, possible free if refcnt drops to 0                                                                                                            |
| NEW_DEC_REFCNT_NATIVEARR_RZ                      | i               | specific dec refcnt of nativearr, possible free if refcnt drops to 0                                                                                                         |
| NEW_DEC_REFCNT_RZ                                | t               | generic dec refcnt rc, calls more specific routines once the ptr type was detected                                                                                           |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| FREE_M1_SLOT_RZm1                                | i               | generic free m1 slot (currently pointing to the ref count field)                                                                                                             |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NEW_FREE_M1_SLOT_RZ                              | i               | generic free for m1 slots, calls more specific routines once slot type was detected (currently either cellarr or nativearr)                                                  |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NEW_FREE_CELLPAIR_RT                             | t               | prefix new_free_cellpair_rc with copy rt->rc                                                                                                                                 |
| NEW_FREE_CELLPAIR_RA                             | t               | prefix new_free_cellpair_rc with copy ra->rc                                                                                                                                 |
| NEW_FREE_CELLPAIR_RZ                             | t               | specific free for cellpair ptr                                                                                                                                               |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NEW_FREE_CELLARR_RZ                              | -               | specific free cellarr, free non ptr cells in array (starting at end), decref ptrs until first ptr is encountered that must be freed                                          |
| NEW_FREE_NATIVEARR_RZ                            | /               | simply use NEW_ADD_M1_SLOT_RZ_TO_PFL (no further actions necessary for deallocation)                                                                                         |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NEW_FREE_CELL_RT                                 | t               | prefix new_free_cell_rc with copy rt->rc                                                                                                                                     |
| NEW_FREE_CELL_RA                                 | t               | prefix new_free_cell_rc with copy ra->rc                                                                                                                                     |
| NEW_FREE_CELL_RZ                                 | t               | generic, call specific routines once cell type is detected                                                                                                                   |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NEW_INC_REFCNT_RA                                | planned         | prefix new_inc_refcnt_rc with copy ra->rc                                                                                                                                    |
| NEW_INC_REFCNT_RT                                | planned         | prefix new_inc_refcnt_rc with copy rt->rc                                                                                                                                    |
| NEW_INC_REFCNT_RZ                                | planned         | generic, call specific routines once cell type is detected                                                                                                                   |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NEW_INC_REFCNT_CELL_RZ                           | planned         | specific increment refcount of cell ptr                                                                                                                                      |
| NEW_INC_REFCNT_CELLPAIR_RZ                       | planned         | specific increment refcount of cellpair ptr                                                                                                                                  |
| NEW_INC_REFCNT_CELLARR_RZ                        | planned         | specific increment refcount of cell array ptr                                                                                                                                |
| NEW_INC_REFCNT_NATIVEARR_RZ                      | planned         | specific increment refcount of native array ptr                                                                                                                              |
| NEW_INC_REFCNT_M1_SLOT_RZ                        | planned         | generic increment refcount of m1 slot (no need for calling more specific routines)                                                                                           |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| NEW_ADD_M1_SLOT_RZ_TO_PFL                        | i               | put the m1 slot pointed to by rc into the page free list (and do some housekeeping, concerning the list of pages with free slots)                                            |
| NEW_DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_RZ        | i               | put page used in rc+1 to a, then NEW_DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_A                                                                                                    |
| NEW_DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_A         | i               | put page profile by page A, then NEW_DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_PROFILE_X                                                                                            |
| NEW_DROP_FULL_PAGES_AT_HEAD_OF_M1_PAGE_PROFILE_X | i               | remove full pages from the list of pages with free slots stored in VM_FREE_M1_PAGE_Px                                                                                        |
| NEW_PUT_PAGE_AS_HEAD_OF_M1_PAGE_RZ               | i               | put the page in rc (which must have free slots) as new head of VM_FREE_M1_PAGE_Px                                                                                            |
|--------------------------------------------------+-----------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| GC_INCR_CELLPAIR_GFL                             | planned         | incremental gc cellpairs in global free list                                                                                                                                 |
| GC_INCR_CELLARR_GFL                              | i               | incremental gc cell arrays in global free list (does prefix copy gfl of cell-arrays into rc, then continue with NEW_GC_INCR_ARRAY_SLOT_RZ, immediate return if gfl is empty) |
| NEW_GC_INCR_ARRAY_SLOT_RZ                        | i               | incremental dec refcnt cells in this cell array (max 1 in this call) and adjust the number of elements to the # not checked yet, add slot tp pfl if 0 left                   |
| NEW_GC_CELLS                                     | i               | repeat freeing cells (returning them to the page) until no free cells are kept in gfl                                                                                        |
| NEW_GC_ALL                                       | i               | free cell-arrays, cell-pairs and cells until all free lists are empty!                                                                                                       |
| NEW_GC_CELL_ARRAYS                               | i               | free cell-arrays until the global (partially gc'd) free list is empty                                                                                                        |
** DONE replace NEW_ with regular naming              -> clean code
- State "DONE"       from "TODO"       [2025-05-08 Thu 09:08]
** DONE rename free-lists (use more expressive names) ->
- State "DONE"       from "TODO"       [2025-05-08 Thu 11:31]
** DONE provide labels for byte code debugger         -> increase debugger usability (allow label usage in byte-code debugger and during dive!)
- State "DONE"       from "TODO"       [2025-05-08 Thu 16:41]
** DONE provide labels for interactive 6510 debugger  -> increase debugger usability (allow label usage in byte-code debugger and during dive!)
- State "DONE"       from "TODO"       [2025-05-08 Thu 18:01]
** DONE make sure disassembler works for labels with lower case
** DONE reactivate tests involving RA functions now deactivated
- State "DONE"       from "IMPLEMENT"  [2025-05-16 Fri 17:20]
** DONE clarify RA RT usage during GC
- State "DONE"       from "TODO"       [2025-05-21 Wed 18:50]
*** concept
RT = cell-pair-pointer | cell-pointer | value-cell
     \_ cell-pair        \_ cell-pair-pointer | cell-pointer | value-cell | header-cell
RA = cell-pair-pointer | cell-pointer | value-cell ?header-cell?
     \_ cell-pair        \_ cell-pair-pointer | cell-pointer | value-cell | header-cell
*** cleanup code
idea REFCOUNT​_INCR is needed only on RT
     REFCOUNT​_DECR is needed on RT and RA
     GC OPERATIONS should run on RA, never on RT
[[file:vm-memory-manager.rkt::4641]]
[[file:vm-memory-manager.rkt::4434]]
- [ ] separate REFCOUNT​_DECR from actual garbage collection
  inspect the following methods and extract GC (running on RA) into separate methods
  #+begin_src scheme
    VM_REFCOUNT_DECR_RT                                ;; generic decrement of refcount (dispatches depending on type)
    VM_REFCOUNT_INCR_RT                                ;; generic increment of refcount (dispatches depending on type)

    VM_REFCOUNT_DECR_RT__CELL_PAIR_PTR                 ;; decrement refcount, calling vm_free_cell_pair_in_zp_ptr if dropping to 0
    VM_REFCOUNT_DECR_RT__M1_SLOT_PTR                   ;; decrement refcount, calling vm_free_m1_slot_in_zp_ptr if dropping to 0
    VM_REFCOUNT_DECR_RT__CELL_PTR                      ;; decrement refcount, calling vm_free_cell_in_zp_ptr if dropping to 0

    VM_REFCOUNT_INCR_RT__CELL_PAIR_PTR                 ;; increment refcount of cell-pair
    VM_REFCOUNT_INCR_RA__M1_SLOT                         ;; increment refcount of m1-slot
    VM_REFCOUNT_INCR_RT__CELL_PTR                      ;; increment refcount of the cell, rt is pointing to

    VM_REFCOUNT_DECR_RA                                ;; generic decrement of refcount (dispatches depending on type)
    VM_REFCOUNT_DECR_RA__CELL_PAIR_PTR                 ;; decrement refcount, calling vm_free_cell_pair_in_zp_ptr if dropping to 0
    VM_REFCOUNT_DECR_RA__M1_SLOT                       ;; decrement refcount, calling vm_free_m1_slot_in_zp_ptr if dropping to 0
    VM_REFCOUNT_DECR_RA__CELL_PTR                      ;; decrement refcount, calling vm_free_cell_in_zp_ptr if dropping to 0

    VM_REMOVE_FULL_PAGES_FOR_PTR2_SLOTS                ;; remove full pages in the free list of pages of the same type as are currently in ZP_PTR2
    VM_ENQUEUE_PAGE_AS_HEAD_FOR_PTR2_SLOTS             ;; put this page as head of the page free list for slots of type as in ZP_PTR2

    VM_GC_ARRAY_SLOT_RT                               ;; execute garbage collection on a cell array (decr-ref all array elements and collect if 0)

    VM_FREE_PTR_IN_RT                                 ;; free pointer (is cell-ptr, cell-pair-ptr, m1-slot-ptr, slot8-ptr)

    VM_ADD_CELL_PAIR_IN_RT_TO_ON_PAGE_FREE_LIST       ;; add the given cell-pair (in zp_rt) to the free list of cell-pairs on its page

  #+end_src
  - VM​_REFCOUNT​_DECR​_RT
  - VM​_REFCOUNT​_DECR​_RA
- [ ] make garbage collection run on RA (and RZ) only
** DONE harmonize function description                -> ease the usage of functions as building blocks
- State "DONE"       from "TODO"       [2025-05-21 Wed 18:51]
- do this in an incremental fashion
- describe what is useful
input:  A/X/Y (register) description
usage:  A/X/Y (register) modifications
        ZP_... memory/register modifications
        VM_... memory/register modifications
output: A/X/Y (register) description
        ZP_... memory/register modifications
        VM_... memory/register modifications
funcs:  list of sub routines / functions used
** DONE split vm-memory-manager in several submodules -> compile/test faster, racket integration better
- State "DONE"       from "TODO"       [2025-05-27 Tue 19:18]
incrementally implemented by extracting the given from vm-memory-manager, including it there to stay compilable
- variable map (included in all)
- register (util) functions
  e.g. cp_rt_to_rp
- page level functions
  e.g. allocate page, free page, initialize page, process global page list, process page type local free list
- cell functions
  load cell (register) with constants?
- cell-pair functions
- cell-array functions
- nat-array functions
- stack functions
** DONE find a way to know what routines are available
- State "DONE"       from "TODO"       [2025-06-14 Sat 23:09]
** DONE find a way of how to import the right symbol to have access to this routine!
- State "DONE"       from "TODO"       [2025-06-14 Sat 23:09]
- e.g. use PUSH_XA_TO_EVLSTKSTK to make use of PUSH_INT_m1_TO_EVLSTK
** DONE find a documentation that allows for easy composition of functions
- State "DONE"       from "TODO"       [2025-06-14 Sat 23:09]
- group semantically [stack functions, register functions, cell-array functions, native array functions etc.]
- provide information like input, usage, output
- provide semantic level (e.g. 6510, vm, bc, scheme)
- extract this information automatically
** DONE use new array functions for array access, and provide bc functions optimized for them
- State "DONE"       from "TODO"       [2025-06-15 Sun 19:55]
IDEA: make use of RA/b/c optional (e.g. command for using tos, command for using ra/b/c)
** DONE implement RA, RB, RC as array access registers and indexes for each
- IDEA: RA dec-refcnt and inc-refcnt can safely assume that ra holds either 0, nil or a reference to an array!
- RA is default and should be accessible with short commands
- RB, RC can be accessed with longer byte code commands
- provide functions to:
  - [X] WRITE/POP TOS -> RA, RB. RC
  - [X] WRITE/POP TOS -> RAi, RBi, RCi <- byte index registers
  - [X] INC RAi, ADD RAi, SUB RAi, DEC RAi (and RB/RC)
  - [X] WRITE/PUSH RA, RB, RC -> TOS
  - [X] WRITE/PUSH RAi, RBi, RCi -> TOS
  - [X] WRITE/PUSH (RA + RAi) -> TOS       ;; retrieve field at RAi in array (pointed to by) RA into TOS
  - [X] WRITE/POP TOS -> (RA + RAi)        ;; (over)write field at RAi in array (pointer to by) RA with TOS
  - ? WRITE (RA + RAi) -> RB/RC/RBi/RBi  ;; and vice versa?
  - [X] ALLOC INTO RA/RB/RC (initialize indices RAi,RBi,RCi)
- (someday) implement matrix multiplication of 4x4 matrices (with ints) <- just as an expample (scale/move...)
** DONE create index of functions and purpose         -> increase reuse and discoverability
- State "DONE"       from "TODO"       [2025-06-15 Sun 21:38]
- alphabetically
- semantically
- ues-case driven
** DONE define register usage convention for commands -> prevent accidental overlapping use
- State "DONE"       from "TODO"       [2025-06-15 Sun 21:39]
- [X] e.g. gc only on ZP_RZ
- [X] one argument function on ZP_RT
- [X] array access on ZP_RA, ZP_RB, ZP_RC
- [X] second argument function on ZP_RP
** DONE split vm-interpreter in groups of interpreted bc commands
** DISCARDED What would happen if the eval stack was located in ZP
- limited to fixed number of depth ..or.. swap in and out from pages
- tos is kept in x, access to ptrs would be
  #+begin_src asm
        ;; ---------------------------------------- access of JUST THE FIRST BYTE pointer to
        LDX TOS
        LDA (STACK,x) ;; loads indirect first byte of pointed to cell (being the tag cell, it might be enough for several decisions!)

        ;; get second byte thereafter
        TXA
        CLC
        ADC STACK
        STA access
        LDY !$01
    access:
        LDA ($FF),y

        ;; ---------------------------------------- one option (advantage, no RT necessary, no copy during push/pop!)
        LDA TOS
        CLC
        ADC STACK
        STA access1+1
        STA access2+1
        LDY #$00
    access1:
        LDA ($FF),y ;; indirect first byte of cell pointed to
        INY
    access2:
        LDA ($FF),y ;; indirect second byte of cell pointed to

        ;; ---------------------------------------- keep tos in rt
        ;; pop to rt
        LDA TOS
        LDA STACK,x
        STA RT
        INX
        LDA STACK,x
        STA RT+1
        INX
        STA TOS ;; don't store for just copying

        ;; access through rt (as usual)
        LDY #$00
        LDA (RT),y      ;; indirect first byte of cell pointer to
        INY
        LDA (RT),y      ;; indirect second byte of cell pointer to

        ;; push rt
        LDX TOS
        DEX
        LDA RT+1
        STA STACK,x
        DEX
        LDA RT
        STA STACK,x
        STX TOS

  #+end_src
- access to cell values
  #+begin_src asm
    LDX TOS
    LDA STACK,x ;; get lowbyte of cell on the stack
    INX
    LDA STACK,x ;; get highbyte of cell on the stack
  #+end_src
- LDA zp,x (4 cycles) is not much faster than LDA (zp),y (5 cycles)
- two INX/DEX (4 cycles) need to be done for stack changes (not mich faster than INC zp/DEC zp, 5 cycles)
- eval stack very limited <- need to investigate whether this limitation is a problem
** DISCARDED IDEA optimization: evlstk -> zp (just 24 cells = 48 bytes)
- precious zp space
- cycles faster: 0 on pop, 2 on push, seems not worth it!
#+begin_src asm
  ;; push
          ldx evlstk_offset       ; 3 cycles
          dex                     ; 2
          dex                     ; 2
          lda rt                  ;
          sta 0,x                 ; 4
          lda rt+1                ;
          sta 1,x                 ; 4
          stx evlstk_offset       ; 3
  ;;pop
          ldx evlstk_offset       ; 3 cycles
          lda 0,x                 ; 4 cycles
          sta rt
          lda 1,x                 ; 4 cycles
          sta rt+1
          inx                     ; 2 cycles
          inx                     ; 2 cycles
          stx evlstk_offset       ; 3 cycles
#+end_src
* - :noexport:
#+begin_src emacs-lisp
  ;; Local Variables:
  ;; org-pretty-entities-include-sub-superscripts: nil
  ;; End:
  #+end_src
