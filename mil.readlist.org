#+title: Mini Lisp Read List
* literature
tags
- VM :: virtual machine
- SC :: small computer
- MEM :: memory management
- T :: theoretical, concepts
- SYS :: complete lisp system
** DONE Ribbit: A Small Scheme VM, Compiler, and REPL in 4K :VM:SC:
[[file:Downloads/c64_classics/minilisp/00_small_scheme_compiler.pdf][paper]] 11p, 2021, [[https://github.com/udem-dlteam/ribbit/tree/main][repository]]
- includes REPL (Picobit does not)
- byte code 
- small virtual machine RVM (Ribbit VM, e.g. [[https://github.com/udem-dlteam/ribbit/blob/main/src/host/c/rvm.c][c-implementation]] with 793 lines, [[https://github.com/udem-dlteam/ribbit/blob/main/src/host/scm/rvm.scm][scheme implementation]] with 439 lines)
- closures, tail calls, first-class continuations, automatic memory management
- no support for variadic parameters
- closures /not safe for space/
*** notes
**** memory
- four itemis are stored in heap memory
  - scheme objects
  - scheme global variables
  - the RVM stack (pointed to tos by stack register)
  - instruction stream executed by RVM (pointed to current instruction rib by pc register)
=> stack depth, code len etc. essentially limited only by heap space
=> unused code can be reclaimed !
- all memory items allocated are of fixed size records called /ribs/
- rib contains three object references
- stack-rib and instruction-rib use first field to chain ribs together
- gc roots of RVM are the two registers: stack and pc (+ #t #f)
=> any object not reachable from stack nor (following) instruction stream can be reclaimed
=> machine word lowest bit = 0: rib-ptr, 1: integer-value
- gc: stop and copy cheney style gc is used
**** scheme object representation
with a rib, consisting of three fields
- pair :: -> [car][cdr][0]
- procedure :: -> [code][env][1]
- symbol/global var :: -> [value][name][2]
  there is no extra symbol table (just the runtime library has a symbol table)
  RVM byte code directly references (global) symbols
- string :: ->[chars][len][3]
- vector :: ->[elems][len][4]
- special values (#t, #f, ()) :: [.][.][5]
**** RVM (footprint 2.6-5.5kB, depending on optimization level)
- uses 2 registers
  - stack (TOS pointer)
  - program counter (instruction pointer)
- instructions
  - tail call slot/global :: ->[0][slot/global][0]
  - non-tail call slot/global :: ->[0][slot/global][->next]
  - set slot/global<-pop() :: -> [1][slot/global][->next]
  - get push(slot/global) :: -> [2][slot/global][->next]
  - const push(object) :: -> [3][slot/global][->next]
  - if pop() != #f goto then :: [4][->then][->next]
- primitive procedures, 19 in total
  each primitive procedure is represented through one rib that is executed through a call to that rib
  a jump to a primitive is equivalent to a tail call continuation
  - rib :: create a rib from values off the stack :: [0][-][1]
  - id :: return tos (pushed again on the stack) :: [1][-][1]
  - arg1 :: pop 2, return second popped :: [2][-][1]
  - arg2 :: pop 2, return first pooped: [3][-][1]
  - close :: return a new rib(field0, stack, 1)
  - rib? :: pop returning true if popped is a rib
  ... (field0, field1, field2, field0-set!, field1-set!, field2-set!, eqv?, <, +, -, *​, quotient, getchar, puthar
- closure
  is a primitive procedure with the code field pointing to a special rib for the form: [#args][-][->code]
  the env field allows access to free variables (not globals, which are directly referenced through symbols)
- call protocol (to non primitive)
  - construct a list with
    - tail = continuation rib = [stack(after popping args)][->procedure][->next(call)]
    - reverse order of popped stack arguments to the procedure
  - stack -> this list
  - pc = -> procedure  
**** runtime library
- ~string->symbol~ function to get a symbol from the global RT symbols
- min runtime library includes:
  *, +, -, <, =, cadddr, caddr, cadr, call/cc, car, cddr, cdr, cons,
  define, display, eof-object?, equal?, eqv?, eval, if, lambda,
  length, list->string, list->vector, list-ref, make-string,
  make-vector, newline, not, null?, pair?, peek-char, procedure?,
  quote, quotient, read, read-char, repl, set!, set-car!, set-cdr!,
  string->list, string->symbol, string-length, string-ref,
  string-set!, string?, symbol->string, symbol?, vector->list,
- max runtime library addes the following:
  <=, >, >=, abs, and, append, assoc, assq, assv, begin, boolean?,
  ca...r, cd...r, ceiling, cond, denominator, eq?, even?, expt, floor,
  for-each, gcd, integer?, lcm, let, map, max, member, memq, memv, min,
  modulo, negative?, number->string, numerator, odd?, or, positive?,
  remainder, reverse, round, string->number, string-append,
  string-copy, string-fill!, string<=?, string<?, string=?,
  string>=?, string>?, substring, truncate, vector-fill!, zero?
**** AOT Compiler
compiles program to string encoded byte code
encoded byte code is the decoded into ribs upon start of the program
AOT create encoded 2068 bytes for min, 4241 for max RT lib (≈ 2kB, 4kB)
** DONE Picobit: A Compact Scheme System for Microcontrollers :VM:SC:
[[file:Downloads/c64_classics/minilisp/00_picobit.pdf][paper]] 18p, >2009, [[file:Downloads/c64_classics/minilisp/00_picolisp_simplemachines.pdf][paper]] 5p, 2015
- compact byte code
- small virtual machine
- works with <7kB memory
- implemented in c
- support for
  - macros
  - automatic memory management
  - lists
  - closures and higher-order procedures
  - first class continuations
  - unbounded precision integers
  - byte vectors
  - lightweight threads
- no support for
  - floating point numbers
  - rational numbers
  - complex numbers
  - string <-> symbol conversion
  - S-expression input
  - file I/O
  - eval
*** notes
- picobit VM = c-code translated to native microcontroller code
- picobit scheme compiler = scheme translated to bytecode for picobit VM
**** optimizations
all done on a global (not module) level (whole program optimization)
- mutability analysis to minimize allocations
- branch tensioning (combine multiple branching jumps)
- treeshaker (remove any dead code)
**** instruction set
| 000xxxxx                   | Push constant x                               |
| 001xxxxx                   | Push stack element #x                         |
| 0100xxxx                   | Push global #x                                |
| 0101xxxx                   | Set global #x to TOS                          |
| 0110xxxx                   | Call closure at TOS with x arguments          |
| 0111xxxx                   | Jump to closure at TOS with x arguments       |
| 1000xxxx                   | Jump to entry point at address pc + x         |
| 1001xxxx                   | Go to address pc + x if TOS is false          |
| 1010xxxx xxxxxxxx          | Push constant x                               |
| 10110000 xxxxxxxx xxxxxxxx | Call procedure at address x                   |
| 10110001 xxxxxxxx xxxxxxxx | Jump to entry point at address x              |
| 10110010 xxxxxxxx xxxxxxxx | Go to address x                               |
| 10110011 xxxxxxxx xxxxxxxx | Go to address x if TOS is false               |
| 10110100 xxxxxxxx xxxxxxxx | Build a closure with entry point x            |
| 10110101 xxxxxxxx          | Call procedure at address pc + x − 128        |
| 10110110 xxxxxxxx          | Jump to entry point at address pc + x − 128   |
| 10110111 xxxxxxxx          | Go to address pc + x − 128                    |
| 10111000 xxxxxxxx          | Go to address pc + x − 128 if TOS is false    |
| 10111001 xxxxxxxx          | Build a closure with entry point pc + x − 128 |
| 10111110 xxxxxxxx          | Push global #x                                |
| 10111111 xxxxxxxx          | Set global #x to TOS                          |
| 11xxxxxx                   | Primitives (+, return, get-cont, ...)         |
**** picobit VM
stack based virtual machine
- includes gc, data structures and unbound precision integers
***** environment
- environments = stacks = lists = heap allocated cons-cells
- var lookup needs to know depth in stack (statically determined)
***** gc
- mark and sweep gc
- Deutsche-Schorr-Waite for marking (no additional memory needed for marking)
***** address space layout
design decision: usually more ROM than RAM (in microcontroller)
=> move to ROM as much as you can
memory is partitioned, pointers are encoded and point either to
- ROM values (constants)
- Heap values
- Byte vectors
****** object encoding
all objects are 32 bit wide (either in ROM or RAM)
(short) indices always point to objects
******* regular
integers implemented as list (little endian) allowing for unbound integers
continuations directly allocated on heap, no call stack copying, implemented as chain to parent
byte vectors are allocated in designated space, meta info is stored in regular heap
- integer ::      00 G next-cell (13b)    integer (16b)
- closure ::      01 G entry-point (16b)       ptr to environment (13b)
- pair ::         1 GC car (13b)          000  cdr (13b)
- symbol ::       10 G 0 0000 0000 0000   001  0 0000 0000 0000
- string ::       10 G to char list (13b) 010  0 0000 0000 0000
- u8vector ::     10 G length (13b)       011  to contents (13b)
- continuation :: 1 GC to parent (13b)    100 to closure (13b)
******* light
no unbound integers available (just 24bit)
- integer ::       G 000 0000        value (24)
- closure ::       G 01 entry hi (5) to environment (8) 0000 0000     entry low (8)
- pair ::          GC 00 0010        car (8)            cdr (8)       0000 0000
- symbol ::        G 000 0011        0000 0000          0000 0000     0000 0000
- string ::        G 000 0101        to char list (8)   0000 0000     0000 0000
- continuations :: GC 1 entry-hi (5) to environment (8) to parent (b) entry lo (8)
***** c-compiler and calling convention
optimization: no recursion allowed
=> allocate all variables in global registers (memory locations) without overlap (global analysis)
=> no allocation on the call stack necessary! params can be passed through registers
specialized switch-case implementation (generating very compact code)
** DONE Automatic Memory Management in newLISP :MEM:
[[file:Downloads/c64_classics/minilisp/01_Automatic Memory Management in newLISP.pdf][paper]], 7p, 2013
- one reference only memory management (no gc)
- idea: copy lisp cells + managing free lists is cheap
  => evaluation does copying/freeing a lot
  => no explicit gc necessary
- lists, arrays, strings (lob) need to be passed by reference
  => newlisp uses host memory manager to handle those
  => they are passed by reference for all builtin functions
  => they are managed through name space ids (probably coupling them to a namespace lifetime)
- seems to contradict persistent data structures
*** notes
**** copy all cells (with values) when entering evaluation level
**** free all cells (with vlaues) when leaving evaluation level
**** list, arrays and strings are passed by reference
using default functor namespace ids
**** optimization
- built in functions work directly on the reference returned object
  => only parameters passed into and return from user defined functions need to be managed
- checking the result stack reduced the actually copied objects by 83%
**** memory and data types
- optimized for cell memory allocation / free (using lists => pointer adjustments)
- every object is kept in a cell
***** instructions
- pushResultStack(reference to cell)
- popResultStack : implies deleting the cell (and all the cell references)
***** datastructure
- resultStack[]
- resultStackIndex
***** pseudo code
#+begin_src c
  function evaluateExpression(expr)
  {
      resultStackIndexSave = resultStackIndex
      if typeOf(expr) is BOOLEAN or NUMBER or STRING
          return(expr)

      if typeOf(expr) is SYMBOL
          return(symbolContents(expr))
                     
      if typeOf(expr) is QUOTE
          return(quoteContents(expr))
                     
      if typeOf(expr) is LIST
          {
              func = evaluateExpression(firstOf(expr))
              args = rest(expr)
              if typeOf(func) is BUILTIN_FUNCTION
                  result = evaluateFunc(func, args)
              else if typeOf(func) = LAMBDA_FUNCTION
                  result = evaluateLambda(func, args)
          }

      while (resultStackIndex > resultStackIndexSave)
          deleteList(popResultStack())

      pushResultStack(result)
      return(result)
  }
#+end_src
****** evaluateFunc
applies a built in function (optimizing passing list, arrays and string as references)
****** evaluateLambda
applies a user defined function 
** DONE Memory Ownership in Carp :MEM:
[[https://github.com/carp-lang/Carp/blob/master/docs/Memory.md][www]], [[file:Downloads/c64_classics/minilisp/rust-memory.pdf][pages]], 15p, 2022
- linear types = types + lifetime
  allows tracking memory location with value association
- linear value can be used once in a single lexical scope
- binding (ownership) can be transferred (used) only once
- gc is called when a value is no longer used in the lexical scope
- moving :: ownership is transfered, may only be done once in any given lexical scope
  - binding (e.g. in a let)
  - passing to function call
  - returning something from a function call
- borrowing :: get reference to value without transferring ownership (through *&* or *ref*)
  - example (function call reverse would normally have transferred ownership=>concatenate could not use it anymore)
    #+begin_src lisp
      (let [a-string @"hello, linear world!"
            reversed (reverse &a-string)] ;; reference to string
        (concatenate a-string reversed)) ;; ok; first move of string
    #+end_src
- copying :: copy value behind reference  (through *@*)
** DONE Memory management in Bones :MEM:
[[https://github.com/wolfgangj/bone-lisp/][www]], lisp with regions, persistent data
- expression ~(in-expr expr1 expr2 ... exrpn)~ evaluates in a region, deleting everything except the result (which is copied into the parent
  region)
- fast allocate within region
- fast deallocation of whole region
- fast copy of result between regions
  => allocation/deallocation per lexical scope / function
** DONE A Tractable Scheme Implementation: Scheme 48 :SYS:
[[file:Downloads/c64_classics/minilisp/01_A tractable Scheme implementation.pdf][paper]], 21p, 1994
- Pre-Scheme used for virtual machine implementation
  - compile time typing
  - no automatic memory management
  - tail calls explicit only
- Byte code compiler compiles primitive scheme for VM
- Primitive Scheme is the minimal scheme implementation
  (is used to implement a full scheme, including compiler, linker etc)
- VM stack based
*** virtual machine
**** architecture
Data structures
	memory :: Pointers and pointer arithmetic
	descriptors :: Typed descriptors for Scheme objects
	fixnum-arithmetic :: Small integer arithmetic with overflow checks
	stored-objects :: Manipulating heap objects
	data-types :: Particular stored object types
	ports :: Scheme I/0 ports
Storage management
	heap :: Heap (including garbage collector)
	environments :: Lexical environments
	stacks :: Operand stack and continuations
Byte-code interpreter
	interpreter :: Instruction dispatch; error detection
	resume :: Initialize, read a heap image, and start interpreting
**** data representation
- scheme objects = descriptor holding pointer plus tag bits (lower 2 bits)
- tag
  - fixnum :: rest of the descriptor = small integer
  - immediate :: #f #t  (type is stored in additional 6 bits)
  - stored object :: pointer to first non header descriptor, before that is a header describing the object, stored objects are usually
    objects such as strings, pairs, vectors ...
  - header :: description of stored objects including type, size and immutability flag
- aggregate data structures
  all stored objects
  - templates :: each stores a vector of instructions and a vector of values (including constants, locations and other templates)
  - closures :: contains a template and an environment
  - continuations :: contains operand stack and some machine registers
  - locations :: contains value of top-level variable
  - run-time environments :: contains values of lexically bound variables, implemented as vectors, [0] = parent lexical env, lexical
    variable identified by two indices, first = depth, second = index
**** storage management
allow for allocation/reclamation of stored objects
gc is running a two-space copying garbage collector
heap image can be written/read from files
- continuations
  four basic functions
  - create continuations (copy argument stack and some internal machine state)
  - call continuation (restore arg stack and machine state)
  - preserve continuation
  - make preserved continuation active
  used for non-tail-recursive calls, proc returns, call-with-current-continuation, apply result of call-with-current-continuation
  simplest implementation: create all on the heap
  complex implementation: keep on stack => no need to copy the arg-stack
- environments
  make vector (chaining with parent env)
  can be allocated on stack or heap
- stack
  invoking continuations frees stack space allocated since contintuations creation
  overflowing stack can be copied into heap
  allows for recursion deeper than the stack
  (see Chris Hanson. Efficient stack allocation for tail recursive languages. In Proc. 1990 ACM Symposium on Lisp and Functional
  Programming, 1990.)
  (see Richard Kelsey. Tail-recursive stack disciplines for an interpreter. Technical Report NU-CCS-93-03, Northeastern University College
  of Computer Science, Boston, MA, 1992.) 
**** [[pdfview:~/Downloads/c64_classics/minilisp/01_A tractable Scheme implementation.pdf::8++0.00][interpreter]]
***** example
#+begin_src lisp
  (lambda (x) (+ 10 x))
#+end_src
#+begin_src lisp
  (check-nargs= 1)
  (make-env 1)
  (literal '10)
  (push)
  (local 0 1)
  (+)
  (return)
#+end_src
***** example commands
there are several additional commands dealing with numeric ops, allocation, accessing and modifying storage, varios i/o ops etc.
a set of generic instructions exist for stored objects like pairs, symbols, vectors and strings
- + :: polymorphic addition
- call :: call tos symbol with n arguments
- check-nargs= :: check the given # of args
- check-nargs>= :: check for minimum # of args
- global :: deref global 
- jump :: jump to label (only forward jumps are allowed)
- jump-if-false :: jump to label of tos is false (only forward jumps are allowed)
- literal :: load literal into value-register
- local :: deref local (depth + index)
- make-cont :: create a continuation
- make-env :: create n new variables in this lexical scope
- make-rest-list :: create a list of variadic parameters after n non optional parameters
- push :: push value-register
- return :: restores operand stack, sets PC, Template, Env and Cont registers
- get-<REG> :: get register into Value register
- set-<REG>! :: set register with value from Value register
**** registers
- Value :: the most recent instruction result                 
- PC :: byte-code program counter                          
- Template :: instruction vector and a vector of literal values  
- Cont :: continuation                                       
- Env :: environment                                        
- Nargs :: number of arguments                                
- Dynamic :: dynamic state                                      
- Enabled-Interrupts :: which interrupts are currently enabled             
- Interrupt-Handlers :: vector of procedures for processing interrupts     
- Exception-Handler :: procedure for processing exceptions                
** DONE A virtual machine for Guile :VM:
[[https://www.gnu.org/software/guile/manual/html_node/A-Virtual-Machine-for-Guile.html][guile vm]]
*** vm concepts
- each thread has own instatiation of vm
- instruction = op, source operand(s), target operand(s)
- procedure = local var(s), argument(s) <- accessed by index
  - local vars are stored on stack, discarded when returning
- vm = stack x ip x sp x fp x shared global memory x registers
  - ip :: instruction pointer
  - sp :: stack pointer
  - fp :: frame pointer
  - global memory :: modules, global bindings etc.
**** stack
- stack is composed of frames
- each frame = application of one proc (except for tail calls, of course)
- stack grows downwards (in this drawing), always 64bit wide
#+begin_src text
     | ...previous frame locals...  |
     +==============================+ <- fp + 3
     | Dynamic link                 |
     +------------------------------+
     | Virtual return address (vRA) |
     +------------------------------+
     | Machine return address (mRA) |
     +==============================+ <- fp
     | Local 0                      |
     +------------------------------+
     | Local 1                      |
     +------------------------------+
     | ...                          |
     +------------------------------+
     | Local N-1                    |
     \------------------------------/ <- sp
#+end_src
1. check parameters to be compatible
2. allocate additional locals for the function
- once a local is no longer used, the slot may be reused
- dynamic link :: old fp before this activation (links activation frames) <- relative addressing
- virtual return address :: old ip before activation (byte code)
- machine return address :: old native machine code ip before activation (only in case of jit)
**** variables
***** top level variable
- each module has a obarray of name -> variable
- created through ~(define name value)~
- dynamically created bye ~make-undefined-variable~ or ~make-variable init~
***** free variable vector
***** local variables
**** object file format (using ELF)
**** vm instruction (see https://www.gnu.org/software/guile/manual/html_node/Instruction-Set.html)
- s​/n/ :: sp relative index to local var
- f​/n/ :: fp relative index to local var
- c​/n/ :: constant unsigned n-bit integer
- l24 :: offset to ip in 32bits units, as a signed 24-bit val (relative jumps)
- zi16, i16, i32 :: immediate scheme value
- a32, b32 :: immediate scheme value pair of 32 bit words (to encode 64 bit values)
- n32 :: statically allocated non immediate x = ip + offset
- r32 :: indirected scheme value (like n32, just indirected, ***​x = ip + offset)
- l32, lo32 :: ip relative address
- v32:x80-l24 :: additional words in special instructions
- b1 :: boolean 1=true, 0=false
- x​/n/ :: ignored sequence of n-bits
***** call return instructions
****** *call* f24:proc x8:_ c24:nlocals
****** *call-label* f24:proc x8:_ c24:nlocals l32:label
****** *tail-call* x24:_
****** *tail-call-label* x24:_ l32:label
****** *return-values* x24:_
****** *receive* f12:dst f12:proc x8:_ c24:nlocals
****** *receive-values* f24:proc b1:allow-extra? x7:_ c24:nvalues
***** function prologue instructions
****** *assert-nargs-ee* c24:expected
****** *assert-nargs-ge* c24:expected
****** *assert-nargs-le* c24:expected
****** *arguments<=?* c24:expected
****** *positional-arguments<=?* c24:nreq x8:_ c24:expected
****** *bind-kwargs* c24:nreq c8:flags c24:nreq-and-opt x8:_ c24:ntotal n32:kw-offset
****** *bind-optionals* f24:nlocals
****** *bind-rest* f24:dst
****** *alloc-frame* c24:nlocals
****** *reset-frame* c24:nlocals
****** *assert-nargs-ee/locals* c12:expected c12:nlocals
***** shuffling instructions
****** *mov* s12:dst s12:src
****** *long-mov* s24:dst x8:_ s24:src
****** *long-fmov* f24:dst x8:_ f24:src
****** *push* s24:src
****** *pop* s24:src
****** *drop* s24:src
****** *shuffle-down* f12:from f12:to
****** *expand-apply-argument* x24:_
***** trampoline instructions
****** *subr-call* c24:idx
****** *foreign-call* c12:cif-idx c12:ptr-idx
****** *builtin-ref* s12:dst c12:idx
***** non-local control flow instructions
****** *capture-continuation* s24:dst
****** *continuation-call* c24:contregs
****** *abort* x24:_
****** *compose-continuation* c24:cont
****** *prompt* s24:tag b1:escape-only? x7:_ f24:proc-slot x8:_ l24:handler-offset
****** *throw* s12:key s12:args
****** *throw/value* s24:value n32:key-subr-and-message
****** *throw/value+data* s24:value n32:key-subr-and-message
***** instrumentation instructions
****** *instrument-entry* x24__ n32:data
****** *instrument-loop* x24__ n32:data
****** *handle-interrupts* x24:_
****** *return-from-interrupt* x24:_
***** intrinsic call instructions
****** *call-thread* x24:_ c32:idx
****** *call-thread-scm* s24:a c32:idx
****** *call-thread-scm-scm* s12:a s12:b c32:idx
****** *call-scm-sz-u32* s12:a s12:b c32:idx
****** call-scm<-thread s24:dst c32:idx
****** call-scm<-u64 s12:dst s12:a c32:idx
****** call-scm<-s64 s12:dst s12:a c32:idx
****** call-scm<-scm s12:dst s12:a c32:idx
****** call-u64<-scm s12:dst s12:a c32:idx
****** call-s64<-scm s12:dst s12:a c32:idx
****** call-f64<-scm s12:dst s12:a c32:idx
****** call-scm<-scm-scm s8:dst s8:a s8:b c32:idx
****** call-scm<-scm-uimm s8:dst s8:a c8:b c32:idx
****** call-scm<-thread-scm s12:dst s12:a c32:idx
****** call-scm<-scm-u64 s8:dst s8:a s8:b c32:idx
****** call-scm-scm s12:a s12:b c32:idx
****** call-scm-scm-scm s8:a s8:b s8:c c32:idx
****** call-scm-uimm-scm s8:a c8:b s8:c c32:idx
****** add dst a b
****** add/immediate dst a b/imm
****** sub dst a b
****** sub/immediate dst a b/imm
****** mul dst a b
****** div dst a b
****** quo dst a b
****** rem dst a b
****** mod dst a b
****** logand dst a b
****** logior dst a b
****** logxor dst a b
****** logsub dst a b
****** lsh dst a b
****** lsh/immediate a b/imm
****** rsh dst a b
****** rsh/immediate dst a b/imm
****** scm->f64 dst src
****** scm->u64 dst src
****** scm->u64/truncate dst src
****** scm->s64 dst src
****** u64->scm dst src
****** s64->scm scm<-s64
****** string-set! str idx ch
****** string->number dst src
****** string->symbol dst src
****** symbol->keyword dst src
****** class-of dst src
****** wind winder unwinder
****** unwind
****** push-fluid fluid value
****** pop-fluid
****** fluid-ref dst fluid
****** fluid-set! fluid value
****** push-dynamic-state state
****** pop-dynamic-state
****** resolve-module dst name public?
****** lookup dst mod sym
****** define! dst mod sym
****** current-module dst
****** $car dst src
****** $cdr dst src
****** $set-car! x val
****** $set-cdr! x val
****** $variable-ref dst src
****** $variable-set! x val
****** $vector-length dst x
****** $vector-ref dst x idx
****** $vector-ref/immediate dst x idx/imm
****** $vector-set! x idx v
****** $vector-set!/immediate x idx/imm v
****** $allocate-struct dst vtable nwords
****** $struct-vtable dst src
****** $struct-ref dst src idx
****** $struct-ref/immediate dst src idx/imm
****** $struct-set! x idx v
****** $struct-set!/immediate x idx/imm v
***** constant instructions
****** *make-immediate* s8:dst zi16:low-bits
****** *make-short-immediate* s8:dst i16:low-bits
****** *make-long-immediate* s24:dst i32:low-bits
****** *make-long-long-immediate* s24:dst a32:high-bits b32:low-bits
****** *make-non-immediate* s24:dst n32:offset
****** *load-label* s24:dst l32:offset
****** *load-f64* s24:dst au32:high-bits au32:low-bits
****** *load-u64* s24:dst au32:high-bits au32:low-bits
****** *load-s64* s24:dst au32:high-bits au32:low-bits
****** *static-ref* s24:dst r32:offset
****** *static-set*! s24:src lo32:offset
****** *static-patch*! x24:_ lo32:dst-offset l32:src-offset
***** memory access instructions
****** allocate-words s12:dst s12:count
****** allocate-words/immediate s12:dst c12:count
****** scm-ref s8:dst s8:obj s8:idx
****** scm-ref/immediate s8:dst s8:obj c8:idx
****** scm-set! s8:dst s8:idx s8:obj
****** scm-set!/immediate s8:dst c8:idx s8:obj
****** scm-ref/tag s8:dst s8:obj c8:tag
****** scm-set!/tag s8:obj c8:tag s8:val
****** word-ref s8:dst s8:obj s8:idx
****** word-ref/immediate s8:dst s8:obj c8:idx
****** word-set! s8:dst s8:idx s8:obj
****** word-set!/immediate s8:dst c8:idx s8:obj
****** pointer-ref/immediate s8:dst s8:obj c8:idx
****** pointer-set!/immediate s8:dst c8:idx s8:obj
****** tail-pointer-ref/immediate s8:dst s8:obj c8:idx
***** atomic memory access instructions
****** current-thread s24:dst
****** atomic-scm-ref/immediate s8:dst s8:obj c8:idx
****** atomic-scm-set!/immediate s8:obj c8:idx s8:val
****** atomic-scm-swap!/immediate s24:dst x8:_ s24:obj c8:idx s24:val
****** atomic-scm-compare-and-swap!/immediate s24:dst x8:_ s24:obj c8:idx s24:expected x8:_ s24:desired
***** tagging and untagging instructions
****** tag-char s12:dst s12:src
****** untag-char s12:dst s12:src
****** tag-fixnum s12:dst s12:src
****** untag-fixnum s12:dst s12:src
***** integer arithmetic instructions
****** uadd s8:dst s8:a s8:b
****** uadd/immediate s8:dst s8:a c8:b
****** usub s8:dst s8:a s8:b
****** usub/immediate s8:dst s8:a c8:b
****** umul s8:dst s8:a s8:b
****** umul/immediate s8:dst s8:a c8:b
****** ulogand s8:dst s8:a s8:b
****** ulogior s8:dst s8:a s8:b
****** ulogxor s8:dst s8:a s8:b
****** ulogsub s8:dst s8:a s8:b
****** ulsh s8:dst s8:a s8:b
****** ulsh/immediate s8:dst s8:a c8:b
****** ursh s8:dst s8:a s8:b
****** ursh/immediate s8:dst s8:a c8:b
****** srsh s8:dst s8:a s8:b
****** srsh/immediate s8:dst s8:a c8:b
***** floating point arithmetic instructions
****** fadd s8:dst s8:a s8:b
****** fsub s8:dst s8:a s8:b
****** fmul s8:dst s8:a s8:b
****** fdiv s8:dst s8:a s8:b
***** comparison instructions
****** u64=? s12:a s12:b
****** u64<? s12:a s12:b
****** s64<? s12:a s12:b
****** s64-imm=? s12:a z12:b
****** u64-imm<? s12:a c12:b
****** imm-u64<? s12:a s12:b
****** s64-imm<? s12:a z12:b
****** imm-s64<? s12:a z12:b
****** f64=? s12:a s12:b
****** f64<? s12:a s12:b
****** =? s12:a s12:b
****** heap-numbers-equal? s12:a s12:b
****** <? s12:a s12:b
****** immediate-tag=? s24:obj c16:mask c16:tag
****** heap-tag=? s24:obj c16:mask c16:tag
****** eq? s12:a s12:b
****** eq-immediate? s8:a zi16:b
****** fixnum? x
****** heap-object? x
****** char? x
****** eq-false? x
****** eq-nil? x
****** eq-null? x
****** eq-true? x
****** unspecified? x
****** undefined? x
****** eof-object? x
****** null? x
****** false? x
****** nil? x
****** pair? x
****** struct? x
****** symbol? x
****** variable? x
****** vector? x
****** immutable-vector? x
****** mutable-vector? x
****** weak-vector? x
****** string? x
****** heap-number? x
****** hash-table? x
****** pointer? x
****** fluid? x
****** stringbuf? x
****** dynamic-state? x
****** frame? x
****** keyword? x
****** atomic-box? x
****** syntax? x
****** program? x
****** vm-continuation? x
****** bytevector? x
****** weak-set? x
****** weak-table? x
****** array? x
****** bitvector? x
****** smob? x
****** port? x
****** bignum? x
****** flonum? x
****** compnum? x
****** fracnum? x
***** branch instructions
****** j l24:offset
****** jl l24:offset
****** je l24:offset
****** jnl l24:offset
****** jne l24:offset
****** jge l24:offset
****** jnge l24:offset
****** jtable s24:idx v32:length [x8:_ l24:offset]...
***** raw memory access instructions
****** u8-ref s8:dst s8:ptr s8:idx
****** s8-ref s8:dst s8:ptr s8:idx
****** u16-ref s8:dst s8:ptr s8:idx
****** s16-ref s8:dst s8:ptr s8:idx
****** u32-ref s8:dst s8:ptr s8:idx
****** s32-ref s8:dst s8:ptr s8:idx
****** u64-ref s8:dst s8:ptr s8:idx
****** s64-ref s8:dst s8:ptr s8:idx
****** f32-ref s8:dst s8:ptr s8:idx
****** f64-ref s8:dst s8:ptr s8:idx
****** u8-set! s8:ptr s8:idx s8:val
****** s8-set! s8:ptr s8:idx s8:val
****** u16-set! s8:ptr s8:idx s8:val
****** s16-set! s8:ptr s8:idx s8:val
****** u32-set! s8:ptr s8:idx s8:val
****** s32-set! s8:ptr s8:idx s8:val
****** u64-set! s8:ptr s8:idx s8:val
****** s64-set! s8:ptr s8:idx s8:val
****** f32-set! s8:ptr s8:idx s8:val
****** f64-set! s8:ptr s8:idx s8:val
***** variables
****** make-variable init -> var
****** make-undefined-variable -> var
****** variable-bound? var -> boolean
****** variable-ref var -> value
****** variable-set! var val -> void
****** variable-unset! var -> void
****** variable? obj -> boolean
**** jit
- increment function usage counter, threshold->native compile
- template jit = bytecode -> series of native instructions (no time consuming analysis)
** DONE compiling to the virtual machine (guile) :VM:
(see https://www.gnu.org/software/guile/manual/html_node/Compiling-to-the-Virtual-Machine.html)
*** Compiler Tower
- scheme -> macro expansion -> tree-il -> cps -> vm byte code
- this list can be extended by own languages
- each translation step is defined with scheme
  #+begin_src scheme
    (define-language scheme
      #:title	"Scheme"
      #:reader      (lambda (port env) ...)
      #:compilers   `((tree-il . ,compile-tree-il))
      #:decompilers `((tree-il . ,decompile-tree-il))
      #:evaluator	(lambda (x module) (primitive-eval x))
      #:printer	write
      #:make-default-environment (lambda () ...))
  #+end_src
*** The Scheme Compiler
- expand all macros
- expand all scheme expressions to their most primitive expressions
- a most primitive expression is a Tree-IL expressions (and cannot be further reduced)
- this expansion is completely implemented as macro expansion
  #+begin_src scheme
    (compile '(+ 1 2) #:from 'scheme #:to 'tree-il)
    ⇒
    #<tree-il (call (toplevel +) (const 1) (const 2))>
  #+end_src
*** Tree-IL
- all is represented as structures (there is a structure notation)
- each element has a reference to the source code it is associated with (not shown in scheme notation)
- there is a notation that is more scheme-like
**** commands (scheme notation)
***** ~(void)~
***** ~(const exp)~
- definition of a constant
***** ~(primitive name)~
- reference to a primitive (e.g. car)
***** ~(lexical name gensym)~
- reference to lexically bound variable
***** ~(set! (lexical name gensym) exp)~
***** ~(@ mod name)~
***** ~(@@ mod name)~
- reference to a name in a module
***** ~(set! (@ mod name) exp)~
***** ~(set! (@@ mod name) exp)~
***** ~(toplevel name)~
- reference var in current module
***** ~(set! (toplevel name) exp)~
***** ~(define name exp)~
- define top level var in current module
***** ~(if test then else)~
- 'else' is not optional
***** ~(call proc . args)~
- regular procedure call
***** ~(primcall name . args)~
- equivalent to ~(call (primitive name) . args)~
***** ~(seq head tail)~
- sequence, head is evaluated, ignoring results, then tail is evaluated, in tail position
***** ~(lambda meta body)~
- a clojure with meta - assoc list, body = single Tree-IL expression of type ~lambda-case~
***** ~(lambda-case ((req opt rest kw inits gensyms) body) [alternate])~
- ~req~ is a list of required arguments, ~opt~ of optional, and ~rest~ of restarguments
- ~kw~ is a list of keyword value pairs
- ~inits~ are Tree-IL expressions corresponding to all ~opt~ and ~kw~
- ~gensyms~ lists all gensyms of ~req~, ~opt~, ~rest~ and ~kw~
- ~body~ and ~alternative~:
  if all params are given, execute body in tail pos
  elif alternative, it should be a lambda case = next clause to try
  else error (wrong # of args) is raised
***** ~(let names gensyms vals exp)~
- lexical name binding
***** ~(letrec names gensyms vals exp)~
***** ~(letrec* names gensyms vals exp)~
- version of let allowing recursive binding
***** ~(prompt escape-only? tag body handler)~
***** ~(abort tag args tail)~
- abort to nearest prompt
***** ~(let-values names gensyms exp body)~
***** ~(fix names gensyms vals body)~
*** Continuation Passing Style
gives a name to every control point and every intermediate value
program is a soup of continuations, a map from label to continuation
special continuations: function entry, tail position
term continuation: term evaluations to 0..n values, recording continuation to which these values are passed
conditional branches e.g. pass/continue to one of a number of continuations
**** guile continuations (building blocks)
are labeled with small integers
- $kargs names vars term :: bind vars w/ org names and eval term
- $continue k src exp :: eval exp, pass values to continuation k (source code found in src)
- $promcall name param args :: call primitive operation name, passing args, pass result to continuation (param holds additional info)
- $const val :: continue with constant value val
- $prim name :: continue with proc, implementing primitive operation named name
- $call proc args :: call proc with args and pass values to cotninuation
- $values args :: pass values args (list) to continuation
- $prompt escape? tag handler ::
- $fun body ::
- $rec names vars funs :: continue with mutual recursive function
- $const-fun label ::
- $code label :: continue with value of label
- $callk label proc args :: like call (but in same compilation unit)
- $branch kf kt src op param args :: primcall op with args and const param continue to kt with zero values (true), else kt
- $switch kf kt* src arg :: continue to label in the list k* depending on index arg
- $throw ::
- $prompt k kh src scape? tag :: push prompt on stack
- $kreceive arity k :: receive values on the stack
- $arity req opt rest kw allow-other-keys? ::  list of req(uired), opt(ional) and rest args
- $kfun src meta self tail clause :: declare function entry
- $ktail :: tail continuation
- $kclause :: arity cont alternate
*** continuations are build using macros in guile
*** bytecode
- see virtual machine vm instruction set ([[*vm instruction (see https://www.gnu.org/software/guile/manual/html_node/Instruction-Set.html)][vm instructions]])
- the assembler, loader and linker have a imperative interface
- the byte code is generated by emit instructions
** DONE LIL: A LISP Implementation Language :VM:
[[pdfview:~/Downloads/c64_classics/minilisp/03_lil.a_lisp_implementation_language.1988.pdf::2++0.00][thesis]], 177p, 1988
- describes a virtual machine in detail
*** virtual machine
general idea: code = instructions implementable by macro assembler
**** JPDL (jump push down list)
keeps track of function invocation (call stack)
**** APDL (argument push down list)
pass arguments from one function to another (value stack)
modules (subroutines) do not have (explicit) parameters, all is passed through the value stack
**** statements
***** expressions
evaluate to single value
***** instructions
execute and contain expression, constants, variables etc.
***** declaration statements
- comment declaration :: define comments
- constant declaration :: define constant value (no id)
  integer, real, octal, hex, char, string
- variable declaration :: declare id as value holder
  allocated to hold largest data type (since decl. is typeless)
- space/array declaration :: one dimensional, continuous space declaration
  id x size x (word|byte),
- structure template declaration :: field layout definition
  (id x count x (bit|byte|word))*
***** definition statements
- const definition :: associate id with constant value
- tag definition :: define label (or tag) as jump target
- module definition :: module initialization code
  can be either threaded module (scheduled to be called) or subroutine (immediately called)
***** conditional statements
- compare statement :: compare two statements and return boolean
  eq, ne, le, lt, ge, gt
***** control statements
- codebegin :: transfer control to this function
- codeend :: marks end of code of a function
- loop :: mark beginning of infinite loop
- loopend :: end of inifite loop
- srjump :: jump to subroutine
- ret :: return from subroutine
- call :: call os routine with parameters
***** stack manipulation instructions
- push :: push onto certain space the result of an expression
- bpush :: push a statement to the bottom of th stack
- pop :: pop tos and return value
- jpush :: push function onto JPDL
- jpop :: pop from JPDL without transfer of control
- apush :: pushes result of an expresion to the APDL
- apop :: pop a value from APDL returning its value
- popj :: pop next function from JPDL and jump to it
***** arithmetic instructions
- set :: an identified variable to the result of an expression
- add :: two expressions
- inc :: increment a variable
- sub :: subtract two expressions
- dec :: decrement a variable
- mul :: multiply two expressions
- div :: integer divide two expressions
- mod :: integer remainder of two expressions
***** storage management instructions
- mkstr :: allocate in given space mem to hold the given structure
- checkspace :: check for space for structure in given space
- initspace :: initialize the given space
- vinit :: intern variable and set to nil
***** data manipulation instructions
- get :: get field from structure
- put :: put result of expression into structure
- aget :: get from array
- aput :: put result of expression into array
***** flow instructions
- jump :: jump to label (tag)
- jumpif :: jump to label if given condition is true
- jumpnif :: negated jumpif
- jumpz :: jump if result is zero
- jumpnz :: jump if result is not zero
***** miscellaneous instructions
- vset :: assign result to vcell of a given atom
- vget :: get vcell of atom
- scopy :: string copy
- scomp :: string compare
- scat :: string concatenation
***** operating system interfaces
- fopen :: file open
- fclose :: file close
- fread :: read number of characters from connection
- fwrite :: write number of characters to connection
**** space + space-registers (heap)
used to implement arrays, free space allocation, stacks, queues etc.
**** eval
is divided into three distinct segments
(allows for changing handlers for certain evals, e.g. debugging eval)
***** argument handler
will decide what to do with arguments (eval etc.)
***** body handler
bind variables, executing function
***** result handler
cleanup stack and restore environment
**** spaces
gc (mark sweep) only in cons-cell space
***** cons-cell space
used for paired cells
***** atom-header space
simple heap
***** string space
**** values
***** atom
any non-list object, identified by atom-header
atom-header = type x gc tag x value x plist x pname
with plist = pointer to previous atom, pname = printable name of this value
***** cons
each cons cell as 4 fields
cons cell = type x gc tag x car x cdr
***** snums
small numbers (no print name, use atom header)
***** subr
compiled function evaluation their arguments (eager)
***** fsubr
compiled function not evaluating their arguments
***** lambda
lisp function which evaluates their arguments (eager)
***** flambda
lisp function not evaluating their arguments (lazy)
**** functions
***** quote (quote)
***** set (set)
***** setq (set quoted)
***** gc (garbage collect)
***** room (num of cells available)
***** oblist (print all atoms in the oblist)
***** putp (put into property list)
***** getp (get from property list)
***** return  (return from break level with some value)
***** reset (reset break level to 0)
***** eval
***** progn (eval and return last expression result)
***** evlis (eval each expression and produce a list of results)
***** list (create list of expressions)
***** append (append two or more lists)
***** car
***** cdr
***** cons
***** null (t if expression is non-nil)
***** +
***** -
***** *
***** /
***** %
***** =
***** >
***** <
***** >=
***** <=
***** atom
***** eq (point to the same objects)
***** or
***** and
***** cond (multi condition)
***** replcd (replace cdr of list with other list)
***** replca (replace car with result of expression)
***** nonc (append, modifying the first list)
***** de (define lambda)
***** df (define flambda)
***** read (from terminal)
***** print (to terminal)
***** exit (terminate)
** DONE CMUCL - CMU Common Lisp implementation (w/ compact bytecode) :VM:
[[https://cmucl.org/docs/internals/design.html][design]] (e.g. object [[https://cmucl.org/docs/internals/design.html#Tagging][tagging]])
[[file:fp4/Docs/CMUCL-design.pdf][book]], 122p, 2003
*** registers
**** before call
- LEXENV :: lexical environment
- CNAME :: symbol for named call
- OCFP :: frame pointer restored upon return
- A0..An :: hold the first n+1 arguments
- NARGS :: holds the number of arguments
- LRA :: lisp return adress (where to return to)
- CODE :: function object actually called
- CSP :: calle sets it if necessary based on CFP
- CFP :: holds callee frame pointer
- NSP :: indicates need to allocate/deallocate before returning or tail calling
**** after call
- A0 :: holds the value
- CODE :: holds LRA to execute now
- CSP :: holds CFP
- CFP :: holds OCFP
**** for multiple return values
- NARGS :: number of values returned
- A0..An :: hold n+1 values
- CSP :: returner stores CFP + NARGS * <address units per word>
- OCFP :: returner stores CFP
*** tagging (lowest 3bit)
- 000 :: even fixnum
- 001 :: function pointer
- 010 :: even other immediate (header-words, characters, symbol-value, trap-value ...)
- 011 :: list pointer
- 100 :: odd fixnum
- 101 :: structure pointer
- 110 :: odd other immediate
- 111 :: other pointer to data-bblocks (other than conses, structures and functions)
- ratios and complex are no primary values => have a header-word
- bignums have a header word
- single and double floats
- symbols have a pad slot
*** structures
len (24 bit), structure-header (8-bit)
structure type name / symbol (32bit)
structure slot 0 (32bit)
       :
structure slot lenght -2 (32bit)
*** fixnums (effectively 2 tag bits)
30 bit 2's complement event integer 000
  or
30 bit 2's complement odd integer 100
- number can be used for offsets in 32 bit words without shifting!
- no masking for subtraction or addition
- division + multiplication requres special shifting
*** other immediates
data (24bits), type (8 bit with low tag) 10
*** data blocks and header-word format
dual word address of data block (29bits) 111
*** types
- number
  - bignum
    - ratio
    - single float
    - double float
    - double-double float
    - complex
    - complex single float
    - complex double float
    - complex double double float
- array
  - simple array
  - vector
    - simple string
    - simple bit vector
    - simple vevtor
    - simple array unsigned 2 bytes
    - simple array 4 bytes
    - simple array 8 bytes
    - simple array 16 bytes
    - simple array 32 bytes
    - simple array signed 2 bytes
    - simple array 4 bytes
    - simple array 8 bytes
    - simple array 16 bytes
    - simple array 32 bytes
    - simple array single float
    - simple array double float
    - simple array double-double float
    - simple array complex single float
    - simple array complex double float
    - simple array complex double double float
  - complex string
  - complex bit vector
  - complex array
- code-header-type
- function-header type
- closure header type
- funcallable instance header type
- .....
*** strings are c null terminated
*** symbols and nil
5 (24 bits) symbol type (8bits)
value descriptor (32 bits)
hashvalue (32bits)
property list (32bits)
print name (32bits)
package (32bits)
- nil is a symbol with a fixed address (first in global space)
*** bytecode
- 00 :: NOP (allows allignment)
- 01 :: pop => table :: pop from stack and add to table
- 02 :: push index(4) => stack :: put table item at index on stack
- 03 :: byte-push index(1) => stack :: put table item on stack
- 04 :: empty-list => stack :: empty list is pushed on the stack
- 05 :: truth => stack :: push truth on stack
- 06 :: symbol-save n(4) name(n) => stack & table :: n(4) = length of print name, name follows one char per byte, result (symbol) is pushed
  on stack and added to the table
- 07 :: small-symbol-save n(1) name(n) => stack & table :: same as symbol-save, for one byte length
- 08 :: symbol-in-package-save index(4) n(4) name(n) => stack & table
- 09 :: small-symbol-in-package-save index(4) n(1) name(n) => stack & table-  ::
- 0A :: ...
- 0E :: package => table :: item is popped from stack, must be a symbol. package is pushed on the table
- 0F :: list len(1) => stack :: make top len elements of the stack a list and push that list on the stack
- 10 :: list* len(1) => stack :: make except tos len elements of the stack a list, terminated by old tos and push it
- 11-18 :: list-1 ... list-8 :: shorthand for list len(1)= 1..8, making short list more compact
- 19..20 :: list*-1 ... list*-8
- 21 :: integer n(4) value(n) => stack :: put long integer on stack
- 22 :: small-integer n(1) value(n) => stack :: put integer on stack
- 23 :: word-integer value(4) => stack
- 24 :: byte-integer value(1) => stack
- 25 :: string n(4) name(n) => stack
- 26 :: small-string n(1) name(n) => stack
- 27 :: vector n(4) => stack
- 28 :: small-vector n(1) => stack
- 2D :: layout :: pop layout object from stack (4 32bit words)
- 2E :: single-float data(4) ::
- 2F :: double-float data(8)
- 30 :: struct n(4) :: n = len of structure to construct
- 31 :: small-struct n(1)
- 35 :: eval :: pop item and evaluate, push result on stack
- 36 :: eval-for-effect :: pop item evaluate and ignore result
- 37 :: funcall nargs(1) => stack :: pop nargs+1 and apply last one popped as function to the args, push result
- 38 :: funcall-for-effect nargs(1)
- 39 :: code-format implementation(1) version(1) :: define code format for following code object
- 3A :: code nitems(4) size(4) :: push compiled function on the stack
- 3B :: small-code nitems(1) size(2)
- 3C :: fdefinition :: pop fdefinition from stack
- 3D :: sanctify-for-execution ::
- 3E :: verify-table-size size(4)
- 3F :: verify-empty-stack :: check that stack is empty
- 40 :: end-group :: last op of a group
- 41 :: pop-for-effect
- 42 :: misc-trap :: push trap object
- 43 :: double-double-float value(8)
- 44 :: character character(3)
- 45 :: small-character char(1)
- 46 :: ratio :: creates ration from two tos ints
- 47 :: complex ::
- 51 :: normal-load
- 52 :: maybe-cold-load
- 53 :: array rank(4)
-  :: alter-code :: modify constant part of code object
  ....
** DONE Design of an Efficient Bytecode Machine and Compiler :VM:
[[file:Downloads/design_of_an_efficient_lisp_bytecode_compiler_and_interpreter.2023.pdf][paper]], 8p, 2023
*** bytecode
- vector of octets of pure byte code commands
  + vector of literals referenced through ~CONSTANT~ instruction
- each instruction has 0+ operands depending on the instruction
- there is a long prefix byte (instruction) allowing for instructions encoding > 8 bit
- goal: small set of orthogonal set of instructions
**** examples
- bind-required-args
- call
- call
- cell-ref
- check-arg-count
- check-arg-count-LE
- closure
- const
- exit
- fdefinition
- make-cell
- make-closure
- pop
- ref
- restore-sp
- return
- save-sp
- set
- special-bind
- unbind
*** vm
- stack machine
- call frame reserves fixed number of values on the stack
- these stack slots can be referenced throug ~REF~ instruction
- program counter
- values vector
- flat closures (no linked environments)
  - benefits: O(1) access time, only data accessible is kept alive, bytecode is simpler
  - drawbacks: mutation is difficult to support
- interoperability with native code and byte code
** DONE A Lisp with very compact bytecode :VM:
[[file:Downloads/lisp_with_compact_bytecode.pdf][paper]], 7p, 1973+
- all values are referenced with pointers
- to prevent too much allocation for integers,
  the most common ones are simple preallocated at fixed addresses
- commands are encoded and executed either in load or store mode
- use short encoding for low number of references (in functions etc.)
*** bytecode
**** control
- JUMP n :: always jump n bytes
- TJUMP n :: jump if tos = true
- FJUMP n :: jump of tos = false
- NTJUMP n :: jump if tos = true, else pop
- TYPEJUMP t d :: jump if tos = type (t) = d = true/false and pop
- GOTOSELF ::  tailcall
- RETURN :: return tos
**** data movement
- store v :: store tos into v
  - IVAR, GVAR, FVAR :: store into binding
  - CONST :: error
  - FN0..FN6 :: function is called in store context
  - FN* :: function with args is called in store context
- dstore v :: same as store + pop
- addrx :: increase range of addresses
- pop :: pop
- copy :: pushes tos (dup)
- ARG :: replace tos=N with Nth argument to function
- SETARG :: write tos to tos-1'th argument of the function
** DONE clisp bytecode specification :VM:
[[https://www.gnu.org/software/clisp/impnotes/bytecode.html][reference]]
*** instructions
**** constants
| mnemonic     | description                                     | semantics                                       |
|--------------+-------------------------------------------------+-------------------------------------------------|
| (NIL)        | Load [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]] into [[file:vm.html][values]].                           | [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]], [[file:vm.html][mv_count]] : 1                      |
| (PUSH-NIL n) | Push /n/ [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]]s into the [[file:vm.html][STACK]].                     | /n/ times do: *-- [[file:vm.html][STACK]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]], Invalidate [[file:vm.html][values]]. |
| (T)          | Load [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_t.html][T]] into [[file:vm.html][values]].                             | [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_t.html][T]], [[file:vm.html][mv_count]] : 1                        |
| (CONST n)    | Load the function's /n/th constant into [[file:vm.html][values]]. | [[file:vm.html][value1]] : [[file:comp-fun.html][consts]][ /n/], [[file:vm.html][mv_count]] : 1             |

**** lexical variables
| mnemonic            | description                                                                                     | semantics                                                                            |
|---------------------+-------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------|
| (LOAD n)            | Load a directly accessible local variable into [[file:vm.html][values]].                                          | [[file:vm.html][value1]] : *( [[file:vm.html][STACK]]+ /n/), [[file:vm.html][mv_count]] : 1                                                  |
| (LOADI k_1 k_2 n)     | Load an indirectly accessible local variable into [[file:vm.html][values]].                                       | /k/ : /k =_{1 + [[file:vm.html][jmpbufsize]] * /k =_{2, [[file:vm.html][value1]] : *(*( [[file:vm.html][SP]]+ /k/)+ /n/), [[file:vm.html][mv_count]] : 1             |
| (LOADC n m)         | Load a closed-up variable, defined in the same function and directly accessible, into [[file:vm.html][values]].   | [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]](*( [[file:vm.html][STACK]]+ /n/),1+ /m/), [[file:vm.html][mv_count]] : 1                                      |
| (LOADV k m)         | Load a closed-up variable, defined in an outer function, into [[file:vm.html][values]].                           | /v/ : [[file:comp-fun.html][venv-const]], /m/ times do: /v/ : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]]( /v/,0), [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]]( /v/, /m/), [[file:vm.html][mv_count]] : 1     |
| (LOADIC k_1 k_2 n m)  | Load a closed-up variable, defined in the same function and indirectly accessible, into [[file:vm.html][values]]. | /k/ : /k =_{1 + [[file:vm.html][jmpbufsize]] * /k =_{2, [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]](*(*( [[file:vm.html][SP]]+ /k/)+ /n/),1+ /m/), [[file:vm.html][mv_count]] : 1 |
| (STORE n)           | Store values into a directly accessible local variable.                                         | *( [[file:vm.html][STACK]]+ /n/) : [[file:vm.html][value1]], [[file:vm.html][mv_count]] : 1                                                  |
| (STOREI k_1 k_2 n)    | Store values into an indirectly accessible local variable.                                      | /k/ : /k =_{1 + [[file:vm.html][jmpbufsize]] * /k =_{2, *(*( [[file:vm.html][SP]]+ /k/)+ /n/) : [[file:vm.html][value1]], [[file:vm.html][mv_count]] : 1             |
| (STOREC n m)        | Store values into a closed-up variable, defined in the same function and directly accessible.   | [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]](*( [[file:vm.html][STACK]]+ /n/),1+m) : [[file:vm.html][value1]], [[file:vm.html][mv_count]] : 1                                       |
| (STOREV k m)        | Store values into a closed-up variable, defined in an outer function.                           | /v/ : [[file:comp-fun.html][venv-const]], /m/ times do: /v/ : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]]( /v/,0), [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]]( /v/, /m/) : [[file:vm.html][value1]], [[file:vm.html][mv_count]] : 1     |
| (STOREIC k_1 k_2 n m) | Store values into a closed-up variable, defined in the same function and indirectly accessible. | /k/ : /k =_{1 + [[file:vm.html][jmpbufsize]] * /k =_{2, [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]](*(*( [[file:vm.html][SP]]+ /k/)+ /n/),1+ /m/) : [[file:vm.html][value1]], [[file:vm.html][mv_count]] : 1 |

**** dynamic variables
| mnemonic     | description                                           | semantics                                                                                                                                    |
|--------------+-------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------|
| (GETVALUE n) | Load a symbol's value into [[file:vm.html][values]].                    | [[file:vm.html][value1]] : symbol-value( [[file:comp-fun.html][consts]][ /n/]), [[file:vm.html][mv_count]] : 1                                                                                           |
| (SETVALUE n) | Store values into a symbol's value.                   | symbol-value( [[file:comp-fun.html][consts]][ /n/]) : [[file:vm.html][value1]], [[file:vm.html][mv_count]] : 1                                                                                           |
| (BIND n)     | Bind a symbol dynamically.                            | Bind the value of the symbol [[file:comp-fun.html][consts]][ /n/] to [[file:vm.html][value1]], implicitly [[file:vm.html][STACK]] - 3, Invalidate [[file:vm.html][values]].                                                |
| (UNBIND1)    | Dissolve one binding frame.                           | Unbind the binding frame [[file:vm.html][STACK]] is pointing to, implicitly [[file:vm.html][STACK]] + 3                                                                          |
| (UNBIND n)   | Dissolve /n/ binding frames.                            | /n/ times do: Unbind the binding frame [[file:vm.html][STACK]] is pointing to, thereby incrementing [[file:vm.html][STACK]] Thus, [[file:vm.html][STACK]] + 1+2* /n/                                   |
| (PROGV)      | Bind a set of symbols dynamically to a set of values. | /symbols/ : * [[file:vm.html][STACK]]++, *-- [[file:vm.html][SP]] : [[file:vm.html][STACK]], build a single binding frame binding the symbols in /symbols/ to the values in [[file:vm.html][value1]], Invalidate [[file:vm.html][values]]. |

**** stack operations
| mnemonic        | description                                                                           | semantics                                                                       |
|-----------------+---------------------------------------------------------------------------------------+---------------------------------------------------------------------------------|
| (PUSH)          | Push one object onto the [[file:vm.html][STACK]].                                                       | *-- [[file:vm.html][STACK]] : [[file:vm.html][value1]], Invalidate [[file:vm.html][values]].                                          |
| (POP)           | Pop one object from the [[file:vm.html][STACK]], into [[file:vm.html][values]].                                           | [[file:vm.html][value1]] : * [[file:vm.html][STACK]]++, [[file:vm.html][mv_count]] : 1                                                |
| (SKIP n)        | Restore a previous [[file:vm.html][STACK]] pointer. Remove /n/ objects from the [[file:vm.html][STACK]].                    | [[file:vm.html][STACK]] : [[file:vm.html][STACK]] + /n/                                                               |
| (SKIPI k_1 k_2 n) | Restore a previous [[file:vm.html][STACK]] pointer. Remove an unknown number of objects from the [[file:vm.html][STACK]]. | /k/ : /k_1 + [[file:vm.html][jmpbufsize]] * /k_2, [[file:vm.html][STACK]] : *( [[file:vm.html][SP]]+ /k/), [[file:vm.html][SP]] : [[file:vm.html][SP]]+ /k/+1, [[file:vm.html][STACK]] : [[file:vm.html][STACK]] + /n/ |
| (SKIPSP k_1 k_2)  | Restore a previous [[file:vm.html][SP]] pointer.                                                        | /k/ : /k_1 + [[file:vm.html][jmpbufsize]] * /k_2, [[file:vm.html][SP]] : [[file:vm.html][SP]]+ /k/                                          |

**** control flow, jumps
| mnemonic               | description                                                        | semantics                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| (SKIP&RET n)           | Clean up the [[file:vm.html][STACK]], and return from the function.                  | [[file:vm.html][STACK]] : [[file:vm.html][STACK]]+ /n/, return from the function, returning values.                                                                                                                                                                                                                                                                                                                                                                                   |
| (SKIP&RETGF n)         | Clean up the [[file:vm.html][STACK]], and return from the generic function.          | If bit 3 is set in the function's [[file:comp-fun.html][flags]], then [[file:vm.html][STACK]] : [[file:vm.html][STACK]]+ /n/, [[file:vm.html][mv_count]] : 1, and return from the function. Otherwise: if the current function has no [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&REST]] argument, then [[file:vm.html][STACK]] : [[file:vm.html][STACK]]+ /n/- [[file:comp-fun.html][numreq]], apply [[file:vm.html][value1]] to the [[file:comp-fun.html][numreq]] arguments still on the [[file:vm.html][STACK]], and return from the function. Else [[file:vm.html][STACK]] : [[file:vm.html][STACK]]+ /n/- [[file:comp-fun.html][numreq]]-1, apply [[file:vm.html][value1]] to the [[file:comp-fun.html][numreq]] arguments and the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&REST]] argument, all still on the [[file:vm.html][STACK]], and return from the function. |
| (JMP label)            | Jump to /label/.                                                     | PC : /label/.                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| (JMPIF label)          | Jump to /label/, if [[file:vm.html][value1]] is true.                                  | If [[file:vm.html][value1]] is not [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]], PC : /label/.                                                                                                                                                                                                                                                                                                                                                                                                               |
| (JMPIFNOT label)       | Jump to /label/, if [[file:vm.html][value1]] is false.                                 | If [[file:vm.html][value1]] is [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]], PC : /label/.                                                                                                                                                                                                                                                                                                                                                                                                                   |
| (JMPIF1 label)         | Jump to /label/ and forget secondary values, if [[file:vm.html][value1]] is true.      | If [[file:vm.html][value1]] is not [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]], [[file:vm.html][mv_count]] : 1, PC : /label/.                                                                                                                                                                                                                                                                                                                                                                                                 |
| (JMPIFNOT1 label)      | Jump to /label/ and forget secondary values, if [[file:vm.html][value1]] is false.     | If [[file:vm.html][value1]] is [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]], [[file:vm.html][mv_count]] : 1, PC : /label/.                                                                                                                                                                                                                                                                                                                                                                                                     |
| (JMPIFATOM label)      | Jump to /label/, if [[file:vm.html][value1]] is not a cons.                            | If [[file:vm.html][value1]] is not a cons, PC : /label/. Invalidate [[file:vm.html][values]].                                                                                                                                                                                                                                                                                                                                                                                         |
| (JMPIFCONSP label)     | Jump to /label/, if [[file:vm.html][value1]] is a cons.                                | If [[file:vm.html][value1]] is a cons, PC : /label/. Invalidate [[file:vm.html][values]].                                                                                                                                                                                                                                                                                                                                                                                             |
| (JMPIFEQ label)        | Jump to /label/, if [[file:vm.html][value1]] is [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_eq.html][EQ]] to the top-of-stack.                | If eq( [[file:vm.html][value1]],* [[file:vm.html][STACK]]++), PC : /label/. Invalidate [[file:vm.html][values]].                                                                                                                                                                                                                                                                                                                                                                                        |
| (JMPIFNOTEQ label)     | Jump to /label/, if [[file:vm.html][value1]] is not [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_eq.html][EQ]] to the top-of-stack.            | If not eq( [[file:vm.html][value1]],* [[file:vm.html][STACK]]++), PC : /label/. Invalidate [[file:vm.html][values]].                                                                                                                                                                                                                                                                                                                                                                                    |
| (JMPIFEQTO n label)    | Jump to /label/, if the top-of-stack is [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_eq.html][EQ]] to a constant.            | If eq(* [[file:vm.html][STACK]]++, [[file:comp-fun.html][consts]][ /n/]), PC : /label/. Invalidate [[file:vm.html][values]].                                                                                                                                                                                                                                                                                                                                                                                   |
| (JMPIFNOTEQTO n label) | Jump to /label/, if the top-of-stack is not [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_eq.html][EQ]] to a constant.        | If not eq(* [[file:vm.html][STACK]]++, [[file:comp-fun.html][consts]][ /n/]), PC : /label/. Invalidate [[file:vm.html][values]].                                                                                                                                                                                                                                                                                                                                                                               |
| (JMPHASH n label)      | Table-driven jump, depending on [[file:vm.html][value1]].                            | Lookup [[file:vm.html][value1]] in the hash table [[file:comp-fun.html][consts]][ /n/]. (The hash table's test is either [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_eq.html][EQ]] or [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_eql.html][EQL]].) If found, the hash table value is a signed [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/typ_fixnum.html][FIXNUM]], jump to it: PC : PC + value. Else jump to /label/. Invalidate [[file:vm.html][values]].                                                                                                                                                                                                                                |
| (JMPHASHV n label)     | Table-driven jump, depending on [[file:vm.html][value1]], inside a generic function. | Lookup [[file:vm.html][value1]] in the hash table [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]]( [[file:comp-fun.html][consts]][0], /n/). (The hash table's test is either [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_eq.html][EQ]] or [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_eql.html][EQL]].) If found, the hash table value is a signed [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/typ_fixnum.html][FIXNUM]], jump to it: PC : PC + value. Else jump to /label/. Invalidate [[file:vm.html][values]].                                                                                                                                                                                                                       |
| (JSR label)            | Subroutine call.                                                   | *-- [[file:vm.html][STACK]] : function. Then start interpreting the bytecode at /label/, with [[file:vm.html][values]] undefined. When a (RET) is encountered, program execution is resumed at the instruction after (JSR label).                                                                                                                                                                                                                                                     |
| (JMPTAIL m n label)    | Tail subroutine call.                                              | /n/ [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_eqcm_sleq__lteqcm_gteq.html][>]] /m/. The [[file:vm.html][STACK]] frame of size /n/ is reduced to size /m/: {*( [[file:vm.html][STACK]]+ /n/- /m/), ..., *( [[file:vm.html][STACK]]+ /n/-1)} : {* [[file:vm.html][STACK]], ..., *( [[file:vm.html][STACK]]+ /m/-1)}. [[file:vm.html][STACK]] + n-m. *-- [[file:vm.html][STACK]] : function. Then jump to /label/, with [[file:vm.html][values]] undefined.                                                                                                                                                                                                                                      |

**** [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-1-1-3.html][lexical environment]], creation of closures
| mnemonic              | description                                                                       | semantics                                                                                                                |
|-----------------------+-----------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------|
| (VENV)                | Load the [[file:comp-fun.html][venv-const]] into [[file:vm.html][values]].                                                  | [[file:vm.html][value1]] : [[file:comp-fun.html][consts]][0], [[file:vm.html][mv_count]] : 1.                                                                                        |
| (MAKE-VECTOR1&PUSH n) | Create a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/typ_simple-vector.html][SIMPLE-VECTOR]] used for closed-up variables.                              | /v/ : new [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/typ_simple-vector.html][SIMPLE-VECTOR]] of size /n/+1. [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]]( /v/,0) : [[file:vm.html][value1]]. *-- [[file:vm.html][STACK]] : /v/. Invalidate [[file:vm.html][values]].                              |
| (COPY-CLOSURE m n)    | Create a closure by copying the prototype and filling in the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-1-1-3.html][lexical environment]]. | /f/ : copy-function( [[file:comp-fun.html][consts]][ /m/]). For /i/0,.., /n/-1: /f/_ [[file:comp-fun.html][consts]][i] : *( [[file:vm.html][STACK]]+ /n/-1- /i/). [[file:vm.html][STACK]] + /n/. [[file:vm.html][value1]] : /f/, [[file:vm.html][mv_count]] : 1 |

**** function calls
| mnemonic     | description                                                    | semantics                                                                                                                                                                                                                                       |
|--------------+----------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| (CALL k n)   | Calls a constant function with /k/ arguments.                    | The function [[file:comp-fun.html][consts]][ /n/] is called with the arguments *( [[file:vm.html][STACK]]+ /k/-1), ..., *( [[file:vm.html][STACK]]+0). [[file:vm.html][STACK]] + /k/. The returned values go into [[file:vm.html][values]].                                                                                                          |
| (CALL0 n)    | Calls a constant function with 0 arguments.                    | The function [[file:comp-fun.html][consts]][ /n/] is called with 0 arguments. The returned values go into [[file:vm.html][values]].                                                                                                                                                       |
| (CALL1 n)    | Calls a constant function with 1 argument.                     | The function [[file:comp-fun.html][consts]][ /n/] is called with one argument * [[file:vm.html][STACK]]. [[file:vm.html][STACK]] + 1. The returned values go into [[file:vm.html][values]].                                                                                                                                   |
| (CALL2 n)    | Calls a constant function with 2 arguments.                    | The function [[file:comp-fun.html][consts]][ /n/] is called with two arguments *( [[file:vm.html][STACK]]+1) and *( [[file:vm.html][STACK]]+0). [[file:vm.html][STACK]] + 2. The returned values go into [[file:vm.html][values]].                                                                                                              |
| (CALLS1 b)   | Calls a system function with no [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&REST]].                         | Calls the system function [[file:recompile.html#byte-version][FUNTAB]][ /b/]. The right number of arguments is already on the [[file:vm.html][STACK]] (including #s in place of absent [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&OPTIONAL]] or [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&KEY]] parameters). The arguments are removed from the [[file:vm.html][STACK]]. The returned values go into [[file:vm.html][values]].     |
| (CALLS2 b)   | Calls a system function with no [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&REST]].                         | Calls the system function [[file:recompile.html#byte-version][FUNTAB]][256+ /b/]. The right number of arguments is already on the [[file:vm.html][STACK]] (including #s in place of absent [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&OPTIONAL]] or [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&KEY]] parameters). The arguments are removed from the [[file:vm.html][STACK]]. The returned values go into [[file:vm.html][values]]. |
| (CALLSR m b) | Calls a system function with [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&REST]].                            | Calls the system function [[file:recompile.html#byte-version][FUNTAB]]R[ /b/]. The minimum number of arguments is already on the [[file:vm.html][STACK]], and /m/ additional arguments as well. The arguments are removed from the [[file:vm.html][STACK]]. The returned values go into [[file:vm.html][values]].                              |
| (CALLC)      | Calls a computed compiled function with no [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&KEY]]s.              | Calls the compiled function [[file:vm.html][value1]]. The right number of arguments is already on the [[file:vm.html][STACK]] (including #s in place of absent [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&OPTIONAL]] parameters). The arguments are removed from the [[file:vm.html][STACK]]. The returned values go into [[file:vm.html][values]].                 |
| (CALLCKEY)   | Calls a computed compiled function with [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&KEY]]s.                 | Calls the compiled function [[file:vm.html][value1]]. The right number of arguments is already on the [[file:vm.html][STACK]] (including #s in place of absent [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&OPTIONAL]] or [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_3-4-1.html][&KEY]] parameters). The arguments are removed from the [[file:vm.html][STACK]]. The returned values go into [[file:vm.html][values]].         |
| (FUNCALL n)  | Calls a computed function.                                     | Calls the function *( [[file:vm.html][STACK]]+ /n/) with the arguments *( [[file:vm.html][STACK]]+ /n/-1), ..., *( [[file:vm.html][STACK]]+0). [[file:vm.html][STACK]] + /n/+1. The returned values go into [[file:vm.html][values]].                                                                                                         |
| (APPLY n)    | Calls a computed function with an unknown number of arguments. | Calls the function *( [[file:vm.html][STACK]]+ /n/) with the arguments *( [[file:vm.html][STACK]]+ /n/-1), ..., *( [[file:vm.html][STACK]]+0) and a list of additional arguments [[file:vm.html][value1]]. [[file:vm.html][STACK]] + /n/+1. The returned values go into [[file:vm.html][values]].                                                               |

**** optional and keyword parameters
| mnemonic              | description                                                                | semantics                                                                                                                                                                                                                                                    |
|-----------------------+----------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| (PUSH-UNBOUND n)      | Push /n/ #s into the [[file:vm.html][STACK]].                                                  | /n/ times do: *-- [[file:vm.html][STACK]] : =#=. Invalidate [[file:vm.html][values]].                                                                                                                                                                                                                |
| (UNLIST n m)          | Destructure a proper [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/syscla_list.html][LIST]].                                                 | 0 ≤ /m/ ≤ /n/. /n/ times do: *-- [[file:vm.html][STACK]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CAR]]( [[file:vm.html][value1]]), [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( [[file:vm.html][value1]]). During the last /m/ iterations, the list [[file:vm.html][value1]] may already have reached its end; in this case, *-- [[file:vm.html][STACK]] : =#=. At the end, [[file:vm.html][value1]] must be [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]]. Invalidate [[file:vm.html][values]].                      |
| (UNLIST* n m)         | Destructure a proper or dotted [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/syscla_list.html][LIST]].                                       | 0 ≤ /m/ ≤ /n/, /n/ > 0. /n/ times do: *-- [[file:vm.html][STACK]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CAR]]( [[file:vm.html][value1]]), [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( [[file:vm.html][value1]]). During the last /m/ iterations, the list [[file:vm.html][value1]] may already have reached its end; in this case, *-- [[file:vm.html][STACK]] : =#=. At the end, after /n/ [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]s, *-- [[file:vm.html][STACK]] : [[file:vm.html][value1]]. Invalidate [[file:vm.html][values]]. |
| (JMPIFBOUNDP n label) | Jump to /label/, if a local variable is not unbound.                         | If *( [[file:vm.html][STACK]]+ /n/) is not =#=, [[file:vm.html][value1]] : *( [[file:vm.html][STACK]]+ /n/), [[file:vm.html][mv_count]] : 1, PC : /label/. Else: Invalidate [[file:vm.html][values]]..                                                                                                                                                         |
| (BOUNDP n)            | Load [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_t.html][T]] or [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]] into [[file:vm.html][values]], depending on whether a local variable is bound. | If *( [[file:vm.html][STACK]]+ /n/) is not =#=, [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_t.html][T]], [[file:vm.html][mv_count]] : 1. Else: [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]], [[file:vm.html][mv_count]] : 1.                                                                                                                                                                        |
| (UNBOUND->NIL n)      | If a local variable is unbound, assign a default value [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]] to it.          | If *( [[file:vm.html][STACK]]+ /n/) is =#=, *( [[file:vm.html][STACK]]+ /n/) : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]].                                                                                                                                                                                                                    |

**** [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/glo_m.html#multiple_values][multiple values]]
| mnemonic         | description                                     | semantics                                                                                                                                                          |
|------------------+-------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| (VALUES0)        | Load no values into [[file:vm.html][values]].                     | [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]], [[file:vm.html][mv_count]] : 0                                                                                                                                         |
| (VALUES1)        | Forget secondary values.                        | [[file:vm.html][mv_count]] : 1                                                                                                                                                       |
| (STACK=-TO-MV n) | Pop the first /n/ objects from [[file:vm.html][STACK]] into [[file:vm.html][values]]. | Load values(*( [[file:vm.html][STACK]]+ /n/-1),...,*( [[file:vm.html][STACK]]+0)) into values. [[file:vm.html][STACK]] + /n/.                                                                                                |
| (MV-TO-STACK)    | Save values on [[file:vm.html][STACK]].                           | Push the [[file:vm.html][mv_count]] values onto the [[file:vm.html][STACK]] (in order: [[file:vm.html][value1]] comes first). [[file:vm.html][STACK]] - [[file:vm.html][mv_count]]. Invalidate [[file:vm.html][values]].                                                       |
| (NV-TO-STACK n)  | Save /n/ values on [[file:vm.html][STACK]].                         | Push the first /n/ values onto the [[file:vm.html][STACK]] (in order: [[file:vm.html][value1]] comes first). [[file:vm.html][STACK]] - /n/. Invalidate [[file:vm.html][values]].                                                               |
| (MV-TO-LIST)     | Convert [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/glo_m.html#multiple_values][multiple values]] into a list.            | [[file:vm.html][value1]] : list of values, [[file:vm.html][mv_count]] : 1                                                                                                                              |
| (LIST-TO-MV)     | Convert a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/syscla_list.html][LIST]] into [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/glo_m.html#multiple_values][multiple values]].            | Call the function [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_values-list.html][VALUES-LIST]] with [[file:vm.html][value1]] as argument. The returned values go into [[file:vm.html][values]].                                                                         |
| (MVCALLP)        | Start a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_multiple-value-call.html][MULTIPLE-VALUE-CALL]] invocation.         | *-- [[file:vm.html][SP]] : [[file:vm.html][STACK]]. *-- [[file:vm.html][STACK]] : [[file:vm.html][value1]].                                                                                                                                |
| (MVCALL)         | Finish a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_multiple-value-call.html][MULTIPLE-VALUE-CALL]] invocation.        | newSTACK : * [[file:vm.html][SP]]++. Call the function *(newSTACK-1), passing it *(newSTACK-2), ..., *( [[file:vm.html][STACK]]+0) as arguments. [[file:vm.html][STACK]] : newSTACK. The returned values go into [[file:vm.html][values]]. |

**** [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_block.html][BLOCK]] and [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_return-from.html][RETURN-FROM]]
| mnemonic                | description                                              | semantics                                                                                                                                                                                                                                        |
|-------------------------+----------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| (BLOCK-OPEN n label)    | Create a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_block.html][BLOCK]] frame.                                    | Create a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_block.html][BLOCK]] frame, [[file:vm.html][STACK]] - 3, [[file:vm.html][SP]] - 2+ [[file:vm.html][jmpbufsize]]. The topmost (third) object in the block frame is [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_cons.html][CONS]]( [[file:comp-fun.html][consts]][ /n/],frame-pointer) (its /block-cons/). Upon a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_return-from.html][RETURN-FROM]] to this frame, execution will continue at /label/. Invalidate [[file:vm.html][values]].. |
| (BLOCK-CLOSE)           | Dissolve a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_block.html][BLOCK]] frame.                                  | Dissolve the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_block.html][BLOCK]] frame at [[file:vm.html][STACK]], [[file:vm.html][STACK]] + 3, [[file:vm.html][SP]] + 2+ [[file:vm.html][jmpbufsize]]. Mark the /block-cons/ as invalid.                                                                                                                                                |
| (RETURN-FROM n)         | Leave a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_block.html][BLOCK]] whose /block-cons/ is given.                 | /block-cons/ : [[file:comp-fun.html][consts]][ /n/]. If [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( /block-cons/)  =#=, an [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/contyp_error.html][ERROR]] is [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_signal.html][SIGNAL]]ed. Else [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( /block-cons/) is a frame-pointer. Unwind the stack up to this frame, pass it values.                                                                             |
| (RETURN-FROM-I k_1 k_2 n) | Leave a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_block.html][BLOCK]] whose /block-cons/ is indirectly accessible. | /k/ : /k_1 + [[file:vm.html][jmpbufsize]] * /k_2, /block-cons/ : *(*( [[file:vm.html][SP]]+ /k/)+ /n/). If [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( /block-cons/)  =#=, an [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/contyp_error.html][ERROR]] is [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_signal.html][SIGNAL]]ed. Else [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( /block-cons/) is a frame-pointer. Unwind the stack up to this frame, pass it values.                                             |

**** [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_tagbody.html][TAGBODY]] and [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_go.html][GO]]
| mnemonic                            | description                                                      | semantics                                                                                                                                                                                                                                                                                                                                     |
|-------------------------------------+------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| (TAGBODY-OPEN m label_1 ... label_n)  | Create a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_tagbody.html][TAGBODY]] frame.                                          | Fetch [[file:comp-fun.html][consts]][ /m/], this is a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/typ_simple-vector.html][SIMPLE-VECTOR]] with /n/ elements, then decode /n/ label operands. Create a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_tagbody.html][TAGBODY]] frame, [[file:vm.html][STACK]] - 3+ /n/, [[file:vm.html][SP]] - 1+ [[file:vm.html][jmpbufsize]]. The third object in the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_tagbody.html][TAGBODY]] frame is [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_cons.html][CONS]]( [[file:comp-fun.html][consts]][ /m/],frame-pointer) (the /tagbody-cons/) Upon a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_go.html][GO]] to tag /label/ of this frame, execution will continue at /label_l/. Invalidate [[file:vm.html][values]]. |
| (TAGBODY-CLOSE-NIL)                 | Dissolve a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_tagbody.html][TAGBODY]] frame, and load [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]] into [[file:vm.html][values]].              | Dissolve the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_tagbody.html][TAGBODY]] frame at [[file:vm.html][STACK]], [[file:vm.html][STACK]] + 3+ /m/, [[file:vm.html][SP]] + 1+ [[file:vm.html][jmpbufsize]]. Mark the /tagbody-cons/ as invalid. [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/convar_nil.html][NIL]], [[file:vm.html][mv_count]] : 1.                                                                                                                                                                                                          |
| (TAGBODY-CLOSE)                     | Dissolve a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_tagbody.html][TAGBODY]] frame.                                        | Dissolve the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_tagbody.html][TAGBODY]] frame at [[file:vm.html][STACK]], [[file:vm.html][STACK]] + 3+ /m/, [[file:vm.html][SP]] + 1+ [[file:vm.html][jmpbufsize]]. Mark the /tagbody-cons/ as invalid.                                                                                                                                                                                                                                      |
| (GO n label)                        | Jump into a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_tagbody.html][TAGBODY]] whose /tagbody-cons/ is given.                 | /tagbody-cons/ : [[file:comp-fun.html][consts]][ /n/]. If [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( /tagbody-cons/)  =#=, an [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/contyp_error.html][ERROR]] is [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_signal.html][SIGNAL]]ed. Else [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( /tagbody-cons/) is a frame-pointer. Unwind the stack up to this frame, pass it the number /label/.                                                                                                                                                          |
| (GO-I k_1 k_2 n label)                | Jump into a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_tagbody.html][TAGBODY]] whose /tagbody-cons/ is indirectly accessible. | /k/ : /k_1 + [[file:vm.html][jmpbufsize]] * /k_2, /tagbody-cons/ : *(*( [[file:vm.html][SP]]+ /k/)+ /n/). If [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( /tagbody-cons/)  =#=, an [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/contyp_error.html][ERROR]] is [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_signal.html][SIGNAL]]ed. Else [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( /tagbody-cons/) is a frame-pointer. Unwind the stack up to this frame, pass it the number /label/.                                                                                                                          |

**** [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_catch.html][CATCH]] and [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_throw.html][THROW]]
| mnemonic           | description                      | semantics                                                                                                                       |
|--------------------+----------------------------------+---------------------------------------------------------------------------------------------------------------------------------|
| (CATCH-OPEN label) | Create a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_catch.html][CATCH]] frame.            | Create a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_catch.html][CATCH]] frame, with [[file:vm.html][value1]] as tag. [[file:vm.html][STACK]] - 3, [[file:vm.html][SP]] - 2+ [[file:vm.html][jmpbufsize]]. Upon a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_throw.html][THROW]] to this tag execution continues at /label/. |
| (CATCH-CLOSE)      | Dissolve a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_catch.html][CATCH]] frame.          | Dissolve the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_catch.html][CATCH]] frame at [[file:vm.html][STACK]]. [[file:vm.html][STACK]] + 3, [[file:vm.html][SP]] + 2+ [[file:vm.html][jmpbufsize]].                                                               |
| (THROW)            | Non-local exit to a [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_catch.html][CATCH]] frame. | /tag/ : * [[file:vm.html][STACK]]++. Search the innermost [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_catch.html][CATCH]] frame with tag /tag/ on the [[file:vm.html][STACK]], unwind the stack up to it, pass it values.         |

**** [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_unwind-protect.html][UNWIND-PROTECT]]
| mnemonic                     | description                                                                            | semantics                                                                                                                                                                                                                                                                                               |
|------------------------------+----------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| (UNWIND-PROTECT-OPEN label)  | Create an [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_unwind-protect.html][UNWIND-PROTECT]] frame.                                                        | Create an [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_unwind-protect.html][UNWIND-PROTECT]] frame. [[file:vm.html][STACK]] - 2, [[file:vm.html][SP]] - 2+ [[file:vm.html][jmpbufsize]]. When the stack will be unwound by a non-local exit, values will be saved on [[file:vm.html][STACK]], and execution will be transferred to /label/.                                                                                                           |
| (UNWIND-PROTECT-NORMAL-EXIT) | Dissolve an [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_unwind-protect.html][UNWIND-PROTECT]] frame, and start the cleanup code.                          | Dissolve the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_unwind-protect.html][UNWIND-PROTECT]] frame at [[file:vm.html][STACK]]. [[file:vm.html][STACK]] + 2, [[file:vm.html][SP]] + 2+ [[file:vm.html][jmpbufsize]]. *-- [[file:vm.html][SP]] : 0, *-- [[file:vm.html][SP]] : 0, *-- [[file:vm.html][SP]] : [[file:vm.html][STACK]]. Save the values on the [[file:vm.html][STACK]], [[file:vm.html][STACK]] - [[file:vm.html][mv_count]].                                                                                                                                      |
| (UNWIND-PROTECT-CLOSE)       | Terminate the cleanup code.                                                            | newSTACK : * [[file:vm.html][SP]]++. Load values(*(newSTACK-1), ..., *( [[file:vm.html][STACK]]+0)) into [[file:vm.html][values]]. [[file:vm.html][STACK]] : newSTACK. SPword1 : * [[file:vm.html][SP]]++, SPword2 : * [[file:vm.html][SP]]++. Continue depending on SPword1 and SPword2. If both are 0, simply continue execution. If SPword2 is 0 but SPword1 is nonzero, interpret it as a label and jump to it. |
| (UNWIND-PROTECT-CLEANUP)     | Dissolve an [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_unwind-protect.html][UNWIND-PROTECT]] frame, and execute the cleanup code like a subroutine call. | Dissolve the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/speope_unwind-protect.html][UNWIND-PROTECT]] frame at [[file:vm.html][STACK]], get /label/ out of the frame. [[file:vm.html][STACK]] + 2, [[file:vm.html][SP]] + 2+ [[file:vm.html][jmpbufsize]]. *-- [[file:vm.html][SP]] : 0, *-- [[file:vm.html][SP]] : PC, *-- [[file:vm.html][SP]] : [[file:vm.html][STACK]]. Save the values on the [[file:vm.html][STACK]], [[file:vm.html][STACK]] - [[file:vm.html][mv_count]]. PC : /label/.                                                                                             |

**** [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/mac_handler-bind.html][HANDLER-BIND]]
| mnemonic             | description             | semantics                                                                                                                                                           |
|----------------------+-------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| (HANDLER-OPEN n)     | Create a handler frame. | Create a handler frame, using [[file:comp-fun.html][consts]][ /n/] which contains the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/contyp_condition.html][CONDITION]] types, the corresponding labels and the current [[file:vm.html][SP]] depth ( function entry [[file:vm.html][SP]] - current [[file:vm.html][SP]]). |
| (HANDLER-BEGIN&PUSH) | Start a handler.        | Restore the same [[file:vm.html][SP]] state as after the HANDLER-OPEN. [[file:vm.html][value1]] : the [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/contyp_condition.html][CONDITION]] that was passed to the handler, [[file:vm.html][mv_count]] : 1. *-- [[file:vm.html][STACK]] : [[file:vm.html][value1]].                       |

**** some inlined functions
| mnemonic          | description                      | semantics                                                                                                         |
|-------------------+----------------------------------+-------------------------------------------------------------------------------------------------------------------|
| (NOT)             | Inlined call to [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_not.html][NOT]].             | [[file:vm.html][value1]] : not( [[file:vm.html][value1]]), [[file:vm.html][mv_count]] : 1.                                                                              |
| (EQ)              | Inlined call to [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_eq.html][EQ]].              | [[file:vm.html][value1]] : eq(* [[file:vm.html][STACK]]++, [[file:vm.html][value1]]), [[file:vm.html][mv_count]] : 1.                                                                     |
| (CAR)             | Inlined call to [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CAR]].             | [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CAR]]( [[file:vm.html][value1]]), [[file:vm.html][mv_count]] : 1.                                                                              |
| (CDR)             | Inlined call to [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]].             | [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_carcm_cdr_darcm_cddddr.html][CDR]]( [[file:vm.html][value1]]), [[file:vm.html][mv_count]] : 1.                                                                              |
| (CONS)            | Inlined call to [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_cons.html][CONS]].            | [[file:vm.html][value1]] : cons(* [[file:vm.html][STACK]]++, [[file:vm.html][value1]]), [[file:vm.html][mv_count]] : 1.                                                                   |
| (SYMBOL-FUNCTION) | Inlined call to [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_symbol-function.html][SYMBOL-FUNCTION]]. | [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_symbol-function.html][SYMBOL-FUNCTION]]( [[file:vm.html][value1]]), [[file:vm.html][mv_count]] : 1.                                                                  |
| (SVREF)           | Inlined call to [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]].           | [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]](* [[file:vm.html][STACK]]++, [[file:vm.html][value1]]), [[file:vm.html][mv_count]] : 1.                                                                  |
| (SVSET)           | Inlined call to SETF [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]].      | /arg1 : *( [[file:vm.html][STACK]]+1), /arg2 : *( [[file:vm.html][STACK]]+0), [[file:vm.html][STACK]] + 2. [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_svref.html][SVREF]]( /arg2, [[file:vm.html][value1]]) : /arg1. [[file:vm.html][value1]] : /arg1, [[file:vm.html][mv_count]] : 1. |
| (LIST n)          | Inlined call to [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_listcm_listst.html][LIST]].            | [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_listcm_listst.html][LIST]](*( [[file:vm.html][STACK]]+ /n/-1),...,*( [[file:vm.html][STACK]]+0)), [[file:vm.html][mv_count]] : 1, [[file:vm.html][STACK]] + /n/.                                           |
| (LIST* n)         | Inlined call to [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_listcm_listst.html][LIST*]].           | [[file:vm.html][value1]] : [[http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_listcm_listst.html][LIST*]](*( [[file:vm.html][STACK]]+ /n/-1),..., *( [[file:vm.html][STACK]]+0), [[file:vm.html][value1]]), [[file:vm.html][mv_count]] : 1, [[file:vm.html][STACK]] + /n/.                                 |

**** Combined instructions
The most frequent short sequences of instructions have an equivalent combined instruction. They are only present for space and speed
optimization. The only exception is =FUNCALL&SKIP&RETGF=, which is needed for generic functions.
| mnemonic                          | equivalent                            |
|-----------------------------------+---------------------------------------|
| (NIL&PUSH)                        | (NIL) (PUSH)                          |
| (T&PUSH)                          | (T) (PUSH)                            |
| (CONST&PUSH n)                    | (CONST n) (PUSH)                      |
| (LOAD&PUSH n)                     | (LOAD n) (PUSH)                       |
| (LOADI&PUSH k_1 k_2 n)              | (LOADI k_1 k_2 n) (PUSH)                |
| (LOADC&PUSH n m)                  | (LOADC n m) (PUSH)                    |
| (LOADV&PUSH k m)                  | (LOADV k m) (PUSH)                    |
| (POP&STORE n)                     | (POP) (STORE n)                       |
| (GETVALUE&PUSH n)                 | (GETVALUE n) (PUSH)                   |
| (JSR&PUSH label)                  | (JSR label) (PUSH)                    |
| (COPY-CLOSURE&PUSH m n)           | (COPY-CLOSURE m n) (PUSH)             |
| (CALL&PUSH k n)                   | (CALL k n) (PUSH)                     |
| (CALL1&PUSH n)                    | (CALL1 n) (PUSH)                      |
| (CALL2&PUSH n)                    | (CALL2 n) (PUSH)                      |
| (CALLS1&PUSH b)                   | (CALLS1 b) (PUSH)                     |
| (CALLS2&PUSH b)                   | (CALLS2 b) (PUSH)                     |
| (CALLSR&PUSH m n)                 | (CALLSR m n) (PUSH)                   |
| (CALLC&PUSH)                      | (CALLC) (PUSH)                        |
| (CALLCKEY&PUSH)                   | (CALLCKEY) (PUSH)                     |
| (FUNCALL&PUSH n)                  | (FUNCALL n) (PUSH)                    |
| (APPLY&PUSH n)                    | (APPLY n) (PUSH)                      |
| (CAR&PUSH)                        | (CAR) (PUSH)                          |
| (CDR&PUSH)                        | (CDR) (PUSH)                          |
| (CONS&PUSH)                       | (CONS) (PUSH)                         |
| (LIST&PUSH n)                     | (LIST n) (PUSH)                       |
| (LIST*&PUSH n)                    | (LIST* n) (PUSH)                      |
| (NIL&STORE n)                     | (NIL) (STORE n)                       |
| (T&STORE n)                       | (T) (STORE n)                         |
| (LOAD&STOREC k n m)               | (LOAD k) (STOREC n m)                 |
| (CALLS1&STORE b k)                | (CALLS1 b) (STORE k)                  |
| (CALLS2&STORE b k)                | (CALLS2 b) (STORE k)                  |
| (CALLSR&STORE m n k)              | (CALLSR m n) (STORE k)                |
| (LOAD&CDR&STORE n)                | (LOAD n) (CDR) (STORE n)              |
| (LOAD&CONS&STORE n)               | (LOAD n/+1) (CONS) (STORE n)          |
| (LOAD&INC&STORE n)                | (LOAD n) (CALL1 #'1+) (STORE n)       |
| (LOAD&DEC&STORE n)                | (LOAD n) (CALL1 #'1-) (STORE n)       |
| (LOAD&CAR&STORE m n)              | (LOAD m) (CAR) (STORE n)              |
| (CALL1&JMPIF n label)             | (CALL1 n) (JMPIF label)               |
| (CALL1&JMPIFNOT n label)          | (CALL1 n) (JMPIFNOT label)            |
| (CALL2&JMPIF n label)             | (CALL2 n) (JMPIF label)               |
| (CALL2&JMPIFNOT n label)          | (CALL2 n) (JMPIFNOT label)            |
| (CALLS1&JMPIF b label)            | (CALLS1 b) (JMPIF label)              |
| (CALLS1&JMPIFNOT b label)         | (CALLS1 b) (JMPIFNOT label)           |
| (CALLS2&JMPIF b label)            | (CALLS2 b) (JMPIF label)              |
| (CALLS2&JMPIFNOT b label)         | (CALLS2 b) (JMPIFNOT label)           |
| (CALLSR&JMPIF m n label)          | (CALLSR m n) (JMPIF label)            |
| (CALLSR&JMPIFNOT m n label)       | (CALLSR m n) (JMPIFNOT label)         |
| (LOAD&JMPIF n label)              | (LOAD n) (JMPIF label)                |
| (LOAD&JMPIFNOT n label)           | (LOAD n) (JMPIFNOT label)             |
| (LOAD&CAR&PUSH n)                 | (LOAD n) (CAR) (PUSH)                 |
| (LOAD&CDR&PUSH n)                 | (LOAD n) (CDR) (PUSH)                 |
| (LOAD&INC&PUSH n)                 | (LOAD n) (CALL1 #'1+) (PUSH)          |
| (LOAD&DEC&PUSH n)                 | (LOAD n) (CALL1 #'1-) (PUSH)          |
| (CONST&SYMBOL-FUNCTION n)         | (CONST n) (SYMBOL-FUNCTION)           |
| (CONST&SYMBOL-FUNCTION&PUSH n)    | (CONST n) (SYMBOL-FUNCTION) (PUSH)    |
| (CONST&SYMBOL-FUNCTION&STORE n k) | (CONST n) (SYMBOL-FUNCTION) (STORE k) |
| (APPLY&SKIP&RET n k)              | (APPLY n) (SKIP&RET k)                |
| (FUNCALL&SKIP&RETGF n k)          | (FUNCALL n) (SKIP&RETGF k)            |

**** Shortcut instructions
There are special one-byte instructions (without explicit operands) for the following frequent instructions:

| mnemonic       | operand range |
|----------------+---------------|
| (LOAD n)       | 0 ≤ /n/ < 15    |
| (LOAD&PUSH n)  | 0 ≤ /n/ < 25    |
| (CONST n)      | 0 ≤ /n/ < 21    |
| (CONST&PUSH n) | 0 ≤ /n/ < 30    |
| (STORE n)      | 0 ≤ /n/ < 8     |

** DONE pico lisp :VM:SYS:
[[https://software-lab.de/doc/ref.html#cell][pico lisp reference]]
*** concepts
- all values are stored in a cell, which is made of a 2x64 bit value
- cells a pointed to by pointers tagged with the type  (using 2 bits)
- garbage collector uses one bit [w/i the pointer]
- type can be
  - pair     (... 000[0])
  - number    (...S01[0])
  - bignumber (...S10[0])
  - symbol    (...100[0])
    - NIL
    - external
    - internal
    - transient
  - big numbers are held on the heap (as list of digits) and pointed to
- grabage collection makes use of a simple mark and sweep
  no compaction necessary, since there is no defragmentation (only cells on the heap).
- more complex types are made of lists, having the benefit of very simple memory and type system
  hash map = list of key value pairs
  array = list
- simplicity gives way to simple/fast algorithms
** design of virtual machines :VM:MEM:T:
[[file:~/Downloads/compiler/vdoc.pub_compiler-design-virtual-machines.pdf][book]], 193p, 2010
- *no* cookbook!
- concepts of compiler design
- targets virtual machines
- virtual machines discussed in detail
- discusses translation of [[pdfview:~/Downloads/c64_classics/minilisp/02_Compiler_Design_Virtual_Machines_-_Wilhelm_Reinhard.pdf::66++0.00][function programming languages]] in detail
- defines a vm for function languages
** LeLisp: A complete LISP System :SYS:VM:
[[pdfview:~/Downloads/c64_classics/minilisp/03_lelisp.pdf][book]], 709p, 1993
- includes chapter about [[pdfview:~/Downloads/c64_classics/minilisp/03_lelisp.pdf::498++0.00][LLM3]], a VM for LeLisp
** The Design of an Instruction Set for Common Lisp :VM:
[[file:Downloads/The Design of an Instruction Set for Common Lisp.pdf][paper]], 9p, 1984
** Performance and Evaluation of Lisp Systems :SYS:VM:
describes some lisp implementations (with some techn. detail) and does perforamce measures
[[file:fp4/Docs/Timrep.pdf][book]], 294p, 1985
** assemblers and loaders
[[file:fp4/Docs/asl.pdf][book]], 299p, 1982
** anatomy of lisp
[[file:fp4/Docs/document.pdf][book]], 470p, 1978
** Paradigms of Artificial Intelligence Programming Case Studies in Common Lisp
[[file:fp4/Docs/Peter Norvig - Paradigms of Artificial Intelligence Programming Case Studies in Common Lisp, 6th ed..pdf][book]], 948p, 1992
** An architecture for efficient Lisp list access :VM:
[[file:Downloads/An_architecture_for_efficient_Lisp_list_access.pdf][paper]], 9p, 1986
** A Tractable Native-Code Scheme System :VM:
[[https://www.deinprogramm.de/sperber/papers/tractable-native-code-scheme-system.pdf][www]], [[file:Downloads/c64_classics/minilisp/tractable-native-code-scheme-system.pdf][paper]], 11p, 2007
- byte code compiler, optimizer and native compiler for pre-scheme
- add this to the existing tractable implemenation of scheme 48
** Lisp64: A Lisp implementation on the C64 :SC:SYS:
[[file:Downloads/c64_classics/minilisp/01_Lisp64.pdf][manual]], 120p, 1986
** a survey of memory management techniques for lisp on small machines :MEM:
[[file:Downloads/c64_classics/minilisp/01_lisp.memory-management.small-machine.pdf][paper]], 78p, 1989
- find best memory management for small machines
** Lisp in Small Pieces :T:
[[pdfview:~/Downloads/c64_classics/minilisp/03_lisp-in-small-pieces_compress.pdf::7++0.00][book]], 536p, 2003
- theoretical book about lisp
- evaluation of lisp
- continuations
- assignments and side effects
- denotational semantics
- compilation
  - macros
** Three Implementation Models for Scheme :T:
[[pdfview:~/Downloads/c64_classics/minilisp/09_implementation models for scheme.pdf::7++0.00][thesis]], 190p, 1987
- [[pdfview:~/Downloads/c64_classics/minilisp/09_implementation models for scheme.pdf::53++0.00][heap based model]]
- [[pdfview:~/Downloads/c64_classics/minilisp/09_implementation models for scheme.pdf::79++0.00][stack based model]]
- [[pdfview:~/Downloads/c64_classics/minilisp/09_implementation models for scheme.pdf::127++0.00][string based model]]
** essentials of compilation :VM:T:
[[file:Downloads/essentials_of_compilation.2021.pdf][book]], 257p, 2021
** the optimal implementation of functional programming languages :T:
[[file:Downloads/The Optimal Implementation of Functional Programming Languages.1998.pdf][book]], 403p, 1998
** the design of intermediate languages for optimizing :VM:T:
[[file:Downloads/the design of intermediate languages in optimizing.phd.2018.pdf][thesis]], 194p, 2018
** Advanced Design and Implementation of Virtual Machines :T:VM:MEM:
[[file:Downloads/c64_classics/minilisp/02_advanced_design_and_implementation_of_virtual_machines.2017.book.pdf][book]], 465p, 2017
- discusses existing VMs
- JIT
- memory management and GC in VMs
- native interfaces
- exceptions
** LOOP: A Lisp Oriented Architecture :T:VM:
[[file:Downloads/c64_classics/minilisp/09_implementation models for scheme.pdf][thesis]], 67p, 1994
- [[pdfview:~/Downloads/c64_classics/minilisp/03_lisp_oriented_architecture.pdf::15++0.00][architecture]] for efficient execution
- hardware support
- (vm) [[pdfview:~/Downloads/c64_classics/minilisp/03_lisp_oriented_architecture.pdf::21++0.00][instructions]], [[pdfview:~/Downloads/c64_classics/minilisp/03_lisp_oriented_architecture.pdf::33++0.00][instruction format]] 
** the mu micro virtual machine :VM:
https://microvm.github.io
* references
- lisp interpreter in "C" for the 6502 https://github.com/SvenMichaelKlose/tunix/blob/main/src/bin/lisp/doc/manual.md
- bytecode interpreter for tiny computers https://dercuano.github.io/notes/tiny-interpreters-for-microcontrollers.html
- proto language assembler for apple https://dwheeler.com/6502/#plasma
- attempt at a bytecode interpreter https://www.lemon64.com/forum/viewtopic.php?t=55465&sid=4c129dfc21d6f951f7e046f42187beb0&start=15
  #+begin_src asm
    	; Stacker mk. 2
    	; "The Fast Version"

    	.org 1024		; or wherever

    stack	.set 0			; stack is in zero page

    ip	.set 0			; two bytes in zero page
    ptr	.set 2			; two bytes in zero page
    tmp	.set 4			; two bytes in zero page
    tmp2	.set 6			; one byte in zero page
    sp	.set 7			; one byte in zero page

    	; Macros

    bc_fetch	.macro		; 7 bytes
    	lda (ip),y
    	iny
    	bne .noinc
    	inc ip+1
    .noinc:
    	.endm

    bc_pop	.macro			; 3 bytes
    	lda <stack, x
    	inx
    	.endm

    bc_push	.macro			; 3 bytes
    	dex
    	sta <stack, x
    	.endm

    bc_setptr	.macro		; 8 bytes
    	lda <stack+2,x		; get LSB of pointer from stack
    	sta <ptr
    	lda <stack+3,x		; get MSB of pointer from stack
    	sta <ptr+1
    	.endm

    	; General-purpose routines

    bc_resume:			; resumes from the point after the last BREAK opcode
    	ldx <sp
    	ldy <ip
    	lda #$00
    	sta <ip
    	beq bc_next

    bc_enter:			; bytecode address in XY
    	stx <ip+1
    	lda #$00
    	sta <ip
    	ldx <sp
    bc_next:
    	bc_fetch
    	stx tmp
    	asl			; safe because we have nowhere near >128 opcodes
    	tax
    	lda jumptable+1, x
    	pha
    	lda jumptable, x
    	pha
    	ldx tmp
    	rts

    bc_branch:
    	bc_fetch		; get branch offset from instruction stream
    	sta <tmp
    	ora #$7f		; makes $ff if negative
    	bmi .ext
    	lda #$00		; $00 if positive
    .ext:
    	pha
    	tya			; Y is the low byte of the instruction pointer
    	clc
    	adc <tmp
    	tay
    	pla
    	adc <ip+1
    	sta <ip+1
    	rts

    	; Opcode routines

    op_break:
    	sty <ip			; save the LSB of the instruction pointer
    	stx <sp			; save the stack pointer
    	rts

    op_jump:
    	bc_fetch		; fetch MSB of new location from instruction stream
    	pha
    	bc_fetch		; fetch LSB of new location from instruction stram
    	tay			; Y is the low byte of the instruction pointer
    	pla
    	sta <ip+1
    	jmp bc_next

    op_jumps:
    	bc_pop			; fetch LSB of new location from stack
    	tay			; Y is the low byte of the instruction pointer
    	bc_pop			; fetch MSB of new location from stack
    	sta <ip+1
    	jmp bc_next

    op_call:
    	lda <ip+1		; get the MSB of the current instruction pointer
    	pha			; save it
    	tya			; get the LSB of the current instruction pointer
    	pha			; save it
    	bc_pop			; get the LSB of the new instruction pointer
    	tay
    	bc_pop			; get the MSB of the new instruction pointer
    	sta <ip+1
    	jmp bc_next

    op_ret:
    	pla			; get the LSB of the saved instruction pointer
    	tay			; restore it
    	pla			; get the MSB of the saved instruction pointer
    	sta <ip+1		; restore it
    	jmp bc_next

    op_bn:
    	lda <stack+1,x		; get MSB of value from stack
    	bpl .drop
    	jsr bc_branch
    .drop:
    	inx
    	inx
    	jmp bc_next

    op_bp:
    	lda <stack+1,x		; get MSB of value from stack
    	bmi .drop		; if negative, don't branch
    	ora <stack,x		; OR with LSB to see if there are any 1s
    	beq .drop
    	jsr bc_branch
    .drop
    	inx
    	inx
    	jmp bc_next

    op_bnz:
    	lda <stack,x		; get LSB of value from stack
    	ora <stack+1,x		; OR with MSB to see if there are any 1s
    	beq .drop
    	jsr bc_branch
    .drop:
    	inx
    	inx
    	jmp bc_next

    op_push1:
    	lda #$00		; MSB is 0
    	bc_push
    	lda #$01		; LSB is 1
    	bc_push
    	jmp bc_next

    op_pushb:
    	lda #$00		; MSB is 0
    	bc_push
    	bc_fetch		; get LSB from instruction stream
    	bc_push
    	jmp bc_next

    op_pushw:
    	bc_fetch		; get MSB from instruction stream
    	bc_push
    	bc_fetch		; get LSB from instruction stream
    	bc_push
    	jmp bc_next

    op_pushib:
    	lda #$00		; pre-push word with an MSB of 0
    	bc_push
    	dex
    	bc_setptr		; set up pointer from stack
    	sty tmp			; save Y
    	ldy #$00
    	lda (ptr),y		; get LSB from pointer
    	sta <stack,x		; save LSB to new stack word
    	ldy tmp
    	jmp bc_next

    op_pushiw:
    	dex			; pre-push word with undefined value
    	dex
    	bc_setptr		; set up pointer from stack
    	sty tmp			; save Y
    	ldy #$00
    	lda (ptr),y		; get LSB from pointer
    	sta <stack,x		; save LSB to new stack word
    	iny
    	lda (ptr),y		; get MSB from pointer
    	sta <stack+1,x		; save MSB to new stack word
    	ldy tmp
    	jmp bc_next

    op_popib:
    	bc_setptr		; set up pointer from stack
    	sty tmp
    	ldy #$00
    	bc_pop			; get LSB from stack
    	sta (ptr),y		; store LSB to pointer
    	inx			; drop MSB from stack
    	ldy tmp
    	jmp bc_next

    op_popiw:
    	bc_setptr		; set up pointer from stack
    	sty tmp
    	ldy #$00
    	bc_pop			; get LSB from stack
    	sta (ptr),y		; store LSB to pointer
    	iny
    	bc_pop			; get MSB from stack
    	sta (ptr),y		; store LSB to pointer
    	ldy tmp
    	jmp bc_next

    op_drop:
    	inx
    	inx
    	jmp bc_next

    op_dup:
    	lda <stack+1,x		; get MSB from stack
    	bc_push			; push MSB on stack
    	lda <stack+1,x		; get LSB from stack
    	bc_push			; push LSB on stack
    	jmp bc_next

    op_swap:
    	lda <stack+3,x
    	pha
    	lda <stack+2,x
    	pha
    	lda <stack+1,x
    	sta <stack+3,x
    	lda <stack,x
    	sta <stack+2,x
    	pla
    	sta <stack,x
    	pla
    	sta <stack+1,x
    	jmp bc_next

    op_roll:
    	lda <stack+5,x		; get word #2
    	pha			; save it
    	lda <stack+4,x
    	pha
    	lda <stack+3,x
    	sta <stack+5,x
    	lda <stack+2,x
    	sta <stack+4,x
    	lda <stack+1,x
    	sta <stack+3,x
    	lda <stack,x
    	sta <stack+2,x
    	pla
    	sta <stack,x
    	pla
    	sta <stack+1,x
    	jmp bc_next

    op_pick:
    	bc_pop			; get word number from stack
    	inx			; discard MSB
    	asl			; turn the word number into an index
    	stx <tmp
    	clc
    	adc <tmp		; stack pointer + index = source index
    	sty <tmp		; save Y
    	tay
    	lda <stack+1,y		; get MSB of source word
    	bc_push			; save it to the stack
    	lda <stack,y		; get LSB of source word
    	bc_push			; save it to the stack
    	ldy <tmp		; restore Y
    	jmp bc_next

    op_dupb:
    	lda <stack,x		; get LSB from stack
    	sta <stack+1,x		; duplicate LSB to MSB
    	jmp bc_next

    op_sext:
    	lda <stack,x		; get LSB from stack
    	ora #$7f		; makes $FF if negative
    	bmi .store
    	lda #$00		; replace with $00 if positive
    .store:
    	sta <stack+1,x		; save value to MSB
    	jmp bc_next

    op_neg:
    	lda <stack,x		; get LSB from stack
    	eor #$ff		; flip all the bits
    	clc
    	adc #$01		; add 1
    	sta <stack,x		; save LSB to stack
    	lda <stack+1,x		; get MSB from stack
    	eor #$ff		; flip all the bits
    	adc #$00		; handle any carry
    	sta <stack+1,x		; save MSB to stack
    	jmp bc_next

    op_abs:
    	lda <stack+1,x		; check MSB from stack
    	bmi op_neg		; negate if negative
    	jmp bc_next

    op_add:
    	clc
    	lda <stack+2,x		; get LSB of addend 1
    	adc <stack,x		; add LSB of addend 0
    	sta <stack+2,x
    	lda <stack+3,x		; get MSB of addend 1
    	adc <stack+1,x		; add MSB of addend 0
    	sta <stack+1,x
    	inx			; drop addend 0
    	inx
    	jmp bc_next

    op_sub:
    	sec
    	lda <stack+2,x		; get LSB of subtrahend
    	sbc <stack,x		; subtract LSB of minuend
    	sta <stack+2,x
    	lda <stack+3,x		; get MSB of subtrahend
    	sbc <stack+1,x		; subtract MSB of minuend
    	sta <stack+3,x
    	inx			; drop minuend
    	inx
    	jmp bc_next

    op_not:
    	lda <stack,x		; get LSB of operand 0
    	eor #$ff		; flip all the bits
    	sta <stack,x
    	lda <stack+1,x		; get MSB of operand 0
    	eor #$ff		; flip all the bits
    	sta <stack+1,x
    	jmp bc_next

    op_and:
    	lda <stack+2,x		; get LSB of operand 1
    	and <stack,x		; AND with LSB of operand 0
    	sta <stack+2,x
    	lda <stack+3,x		; get MSB of operand 1
    	and <stack+1,x		; AND with MSB of operand 0
    	sta <stack+3,x
    	inx			; drop operand 0
    	inx
    	jmp bc_next

    op_or:
    	lda <stack+2,x		; get LSB of operand 1
    	ora <stack,x		; AND with LSB of operand 0
    	sta <stack+2,x
    	lda <stack+3,x		; get MSB of operand 1
    	ora <stack+1,x		; AND with MSB of operand 0
    	sta <stack+3,x
    	inx			; drop operand 0
    	inx
    	jmp bc_next

    op_xor:
    	lda <stack+2,x		; get LSB of operand 1
    	eor <stack,x		; AND with LSB of operand 0
    	sta <stack+2,x
    	lda <stack+3,x		; get MSB of operand 1
    	eor <stack+1,x		; AND with MSB of operand 0
    	sta <stack+3,x
    	inx			; drop operand 0
    	inx
    	jmp bc_next

    op_shl:
    	bc_pop			; get shift count
    	sta <tmp		; save it
    	inx			; discard the MSB
    .loop:
    	asl <stack,x		; shift LSB left
    	rol <stack+1,x		; shift MSB left with carry
    	dec tmp
    	bne .loop
    	jmp bc_next

    op_shr:
    	bc_pop			; get shift count
    	sta <tmp		; save it
    	inx			; discard the MSB
    .loop:
    	lsr <stack+1,x		; shift MSB right
    	ror <stack,x		; shift LSB right with carry
    	dec tmp
    	bne .loop
    	jmp bc_next

    op_ashr:
    	bc_pop			; get shift count
    	sta <tmp		; save it
    	inx			; discard the MSB
    .loop:
    	lda <stack+1,x		; get MSB
    	asl			; put high bit into carry
    	ror <stack+1,x		; shift MSB right
    	ror <stack,x		; shift LSB right with carry
    	dec tmp
    	bne .loop
    	jmp bc_next

    op_rotl:
    	bc_pop			; get shift count
    	sta <tmp		; save it
    	inx			; discard the MSB
    .loop:
    	lda <stack+1,x		; get MSB
    	asl			; put high bit into carry
    	rol <stack+1,x		; shift MSB right
    	rol <stack,x		; shift LSB right with carry
    	dec tmp
    	bne .loop
    	jmp bc_next

    op_rotr:
    	bc_pop			; get shift count
    	sta <tmp		; save it
    	inx			; discard the MSB
    .loop:
    	lda <stack,x		; get LSB
    	lsr			; put low bit into carry
    	ror <stack+1,x		; shift MSB right
    	ror <stack,x		; shift LSB right with carry
    	dec tmp
    	bne .loop
    	jmp bc_next


    jumptable:			; Jump table - ordering here affects opcode number!
    	.dw op_break

    	.dw op_jump
    	.dw op_jumps

    	.dw op_call
    	.dw op_ret

    	.dw op_bn
    	.dw op_bp
    	.dw op_bnz

    	.dw op_push1
    	.dw op_pushb
    	.dw op_pushw

    	.dw op_pushib
    	.dw op_pushiw
    	.dw op_popib
    	.dw op_popiw

    	.dw op_drop
    	.dw op_dup
    	.dw op_swap
    	.dw op_roll
    	.dw op_pick

    	.dw op_dupb

    	.dw op_sext
    	.dw op_neg
    	.dw op_abs

    	.dw op_add
    	.dw op_sub

    	.dw op_not
    	.dw op_and
    	.dw op_or
    	.dw op_xor

    	.dw op_shl
    	.dw op_shr
    	.dw op_ashr
    	.dw op_rotl
    	.dw op_rotr


    opcodes:
    	; Opcode/mnemonic table and instruction reference - for reference purposes
    	; and development of an assembler, not actually used by the interpreter.
    	; Format: mnemonic + null-terminator + opcode

    	; Stack terminology: current top item on stack is #0. Subsequent items are
    	; #1, #2, etc. up to #127 if the stack is completely full.

    	; BREAK - ends bytecode execution
    	; ( -- )
    	.db "BREAK",0
    	.db $00

    	; JUMP - changes the instruction pointer to a new location
    	; ( -- )
    	.db "JUMP",0
    	.db $01
    	; JUMPS - changes the instruction pointer to the value of #0
    	; (a-addr -- )
    	.db "JUMPS",0
    	.db $02

    	; CALL - saves the current location to the call stack and calls a subroutine
    	; ( -- )
    	.db "CALL",0
    	.db $03
    	; RET - restores a saved location from the call stack
    	; ( -- )
    	.db "RET",0
    	.db $04

    	; BN - branches if #0 is negative
    	; (n -- )
    	.db "BN",0
    	.db $05
    	; BP - branches if #0 is positive (greater than 0)
    	; (n -- )
    	.db "BP",0
    	.db $06
    	; BNZ - branches if #0 is not zero
    	; (n -- )
    	.db "BNZ",0
    	.db $07

    	; PUSH1	- push a 1 on the stack
    	; ( -- 1)
    	.db "PUSH1",0
    	.db $08
    	; PUSHB - push a byte constant on the stack, zero-extended
    	; ( -- c)
    	.db "PUSHB",0
    	.db $09
    	; PUSHW - push a word constant on the stack
    	; ( -- w)
    	.db "PUSHW",0
    	.db $0A

    	; Pointer operations leave the pointer on the stack, you will need to drop
    	; it manually when you're done! This is to make block operations simpler.
    	; They also do not manipulate the pointer on the stack directly, but a copy.

    	; PUSHIB - fetch a byte from the pointer in #0, zero-extend, and push
    	; (c-addr -- c c-addr)
    	.db "PUSHIB",0
    	.db $0B
    	; PUSHIW - fetch a word from the pointer in #0 and push
    	; (a-addr -- w a-addr)
    	.db "PUSHIW",0
    	.db $0C
    	; POPIB - store the LSB of #0 to the pointer in #1 and drop #0
    	; (c c-addr -- c-addr)
    	.db "POPIB",0
    	.db $0D
    	; POPIW - store #0 to the pointer in #1 and drop #0
    	; (a a-addr -- a-addr)
    	.db "POPIW",0
    	.db $0E

    	; DROP - discard #0
    	; (w -- )
    	.db "DROP",0
    	.db $0F
    	; DUP - duplicate #0
    	; (w -- w w)
    	.db "DUP",0
    	.db $10
    	; SWAP - exchange #0 and #1
    	; (w w -- w w)
    	.db "SWAP",0
    	.db $11
    	; ROLL - cycle #0-#2 (#2 -> #0 -> #1 -> #2)
    	; (w w w -- w w w)
    	.db "ROLL",0
    	.db $12
    	; PICK - use #0 as an index into the stack, fetch that word, and replace #0
    	; (n -- w)
    	.db "PICK",0
    	.db $13

    	; DUPB - duplicate the low byte of a word to the high byte
    	; (c -- w)
    	.db "DUPB",0
    	.db $14

    	; SEXT - sign-extend #0 from its byte value
    	; (c -- n)
    	.db "SEXT",0
    	.db $15
    	; NEG - negate #0
    	; (n -- n)
    	.db "NEG",0
    	.db $16
    	; ABS - replace #0
    	; (n -- n)
    	.db "ABS",0
    	.db $17

    	; ADD - add #0 and #1
    	; (n n -- n)
    	.db "ADD",0
    	.db $18
    	; SUB - subtract #1 from #0
    	; (n n -- n)
    	.db "SUB",0
    	.db $19

    	; NOT - logically-invert #0
    	; (w -- w)
    	.db "NOT",0
    	.db $1A
    	; AND - logically-AND #0 and #1
    	; (w w -- w)
    	.db "AND",0
    	.db $1B
    	; OR - logically-OR #0 and #1
    	; (w w -- w)
    	.db "OR",0
    	.db $1C
    	; XOR - exclusive-OR #0 and #1
    	; (w w -- w)
    	.db "XOR",0
    	.db $1D

    	; SHL - shifts #1 left by #0 places
    	; (n w -- w)
    	.db "SHL",0
    	.db $1E
    	; SHR - shifts #1 right by #0 places
    	; (n w -- w)
    	.db "SHR",0
    	.db $1F
    	; ASHR - shifts #1 right by #0 places with sign-extend
    	; (n w -- w)
    	.db "ASHR",0
    	.db $20
    	; ROTL - rotates #1 left by #0 places
    	; (n w -- w)
    	.db "ROTL",0
    	.db $21
    	; ROTR - rotates #1 right by #0 places
    	; (n w -- w)
    	.db "ROTR",0
    	.db $22
  #+end_src
- multiplizieren und dividieren größerer Zahlen https://www.64er-magazin.de/8505/assembler.html
* collected notes and considerations
** general ideas
- implement byte code interpreter in racket
- implement interpreter in byte code itself
- iterate
- optimize byte code (size/decoding speed)
- implement interpreter in 6510 assembly
- optimize (size/decoding speed)
- iterate
*** DONE (mostly) first iteration
- simple function to do byte plus two parameter
  #+begin_src scheme
    (def (f (a : byte) (b : byte)) : byte
         "add a and b by using vm-instruction byte add"
         (b+ a b))

    (f 10 11)
  #+end_src
- define byte code
  #+begin_src scheme
    (byte-cell 10 l0) ;; create new byte cell with constant 10 into local cells at index 0
    (byte-cell 11 l1)
    (call 'f 3 l0 l1 l2 -0-) ;; call f with 3 params l0, l1, l2<-result and 0 additional space allocated for locals of the called function

    (function f)
    ;; (ensure-args 3)
    ;; (ensure-byte-arg 0)
    ;; (ensure-byte-arg 1)
    ;; (ensure-byte-arg 2)
    (byte+ p0 p1 p2)
    (return)
  #+end_src
- tail recursive function using lists
  #+begin_src scheme
    (def (sum (bl (list byte)) (acc byte 0)) -> byte
         "tail recursive function with accumulator"
         (if (empty? list)
             acc
             (sum (cdr bl) (b+ acc (car bl)))))

    (sum (list 10 20))
  #+end_src
- byte code (no gc necessary)
  5 locals are used for this instatiation (2 for list creation, 2 for the actual list, and one for the result/accumulator)
  #+begin_src scheme
    (byte-cell l0 10) ;; create a byte cell with value 10 at local 0
    (byte-cell l1 20)
    (make-list l2 2 l0 l1) ;; make  a list of l0 and l1 into l2/l3 [optimization, could reuse l0 and l1 for list]
    (zero-byte-cell l4) ;; make default argument explicitly at caller site
    (call l4 'sum 2 l2 l4 0) ;; call sum with two input arguments, l2, l3, storing result in l4 (=> 2 parameters), allocating additional 0 locals

    (function sum)
    ; (ensure-args 3) ;; 1 byte + car/cons cells 2 = 3
    ; (ensure-list-arg 0)
    ; (ensure-byte-arg 2)
    (label -sum-recur)
    (bra-empty-list? a0 -sum2) ;; check car of list = 0 which means it is an empty list, could also be (bra-zero-cell 0) check arg 0 to be an empty cell = empty list
    (byte+ a2 a0 a2)
    (resolve-cdr a1 2 a0) ;; resolve ptr in cdr cell (arg 1), 2 consequtive cells (another list, that is car and cdr-cell) into arg 0 (and 1)
    (goto -sum-recur) ;; tailcall
    (label -sum2)
    (return a2) ;; a2 (last parameter) is automatically the return value
  #+end_src
- access defined structure
  #+begin_src scheme
    (def-struct point
      (x : byte)
      (y : byte))

    (point 1 2) ;; c-tor
  #+end_src
- data layout of a structure definition is an array of cells
  -> [
     byte: number of field
     string : name of struct
     string : field name 0
     ...
     string : field name n
     ]
- data layout of an instantiated structure
  byte offset
  2 [struct cell 0]
  4 [struct cell 1]
  ...
- bytecode
  #+begin_src scheme
    (struct-create l0 'point 1 2) ;; l0 = pointer to structure, structure is explicitly allocated (gc undefined yet)

    (byte-cell l1 1)
    (struct-set l0 0 l1) ;; set 0 offset field (which is x) in structure point (in l0) to value of l1 (a bytecell with value 1)
  #+end_src
- define interpreter (poc)
  - data layout
    - eval-stack = stack of cells
    - cell 16bit = byte/char 8bit | int xbit | pointer to cell 15bit | data-header (following cell holds value of given type) ybit
    - data-header-cell = struct | float | array | list ... cannot be car nor cdr cell but must be pointed at!
    - data-cell (following data-header) 16bit = ptr to
    - list = car-cell, cdr-cell (these cells cannot be data-header-cells)
  #+begin_src scheme
    (def-enum cell-type
      (pointer
       byte
       int
       header))
    ;; alternatively
    (def-type cell-type (or 'pointer 'byte 'int 'header)) ;; or for symbols

    (def-struct cell
      (tag cell-type)
      (or (cell-ptr    bytes2)  ;; or for fields
          (cell-byte   bytes2)
          (cell-header bytes2)
          (cell-int    bytes2)))

    (def-struct function
      (byte-code    (array byte) "vm instructions as array")
      (locals-count byte         "number of locals in this function")
      (name         string       "symbol name of function"))

    (def-struct continuation
      (byte-index     int "location in byte-code of function")
      (function-index int "function id"))

    (def-struct call-frame
      "data needed to store arguments and locals of a function and the continuation to return to"
      (cont         continuation "return")
      (param-count  byte         "actually passed parameters = len of parameters array")
      (locals-count byte         "number of locals to reserve")
      (locals       (array cell) "fixed number of cells used as locals"
      (params       (array cell) "parameters array (len defined by function) + actually passed parameter"))

    (def-struct vm
      "state of the virtual machine"
      (call-stack (list call-frame))
      (functions  (array function))
      (frame      call-frame)
      (globals    (array cell)))

    ;; def-struct create the following accessors
    ; (structname-fieldname a-struct)                ;; to read, returning the value of the field
    ;  (structname-fieldname! a-struct a-field-value) ;; to write (returning the struct itself

    (def (vm-new) -> vm
         "create an initialized vm"
         (vm :call-stack '()
             :functions  [(function :byte-code    [0]
                                    :locals-count 0
                                    :name         "just-break")]
             :frame      (call-frame :cont         (continuation 0 0)
                                     :param-count  0
                                     :locals-count 0
                                     :locals       []
                                     :parameters   [])
             :globals    []))

    (def (vm-next-inst-byte! (avm vm)) -> vm
         "return vm pointing to next instruction byte (no bounds check)"
         (def-local cont (call-frame-cont (vm-frame avm)))
         (continuation-byte-index!
          cont
          (int-inc (continuation-byte-index cont))))

    (def (vm-peek-inst-byte (avm vm) (off byte 0)) -> byte
         "return the byte currently pointed to by frame"
         (def-local cont (call-frame-cont (vm-frame avm)))
         (def-local functions (vm-functions vm))
         (def-local func (array-at functions (continuation-function-index cont)))
         (array-at (function-byte-code func) (+ off (continuation-byte-index cont))))

    (def (vm-peek-inst-int (avm vm) (off byte 0) -> int
         "return the int currently pointed to by the frame"
         (def-local cont (call-frame-cont (vm-frame avm)))
         (def-local functions (vm-functions vm))
         (def-local func (array-at functions (continuation-function-index cont)))
         (def-local index (+ off (continuation-byte-index cont)))
         (bytes->int
          :low (array-at (function-byte-code func) index)
          :high (array-at (function-byte-code func) (1+ index))))

    (def (vm-interpret-instruction (avm vm)) -> vm
         "execute the current instruction of the vm"
         (def-local byte-code (vm-peek-inst-byte avm))
         (case byte-code
           [00 (break)]
           [01 (vm-interpret-byte+ avm)]
           [else (throw-usr-exception "unknown opcode ~a" bc)]))

    (def (vm-decode-operand-ptr-high (op-code byte) (avm vm)) -> cell
         "return cell referenced by encoded (in the high 4 bits) of op-code"
         (vm-decode-operand-ptr (shift-right 4 op-code) avm))

    (def (vm-decode-operand-ptr-low (op-code byte) (avm vm)) -> cell
         "return cell referenced by encoded (in the high 4 bits) of op-code"
         (vm-decode-operand-ptr (bitwise-and op-code 0x00001111) avm))

    (def (vm-decode-operand-ptr (op-code byte) (avm vm)) -> cell
         "return cell referenced by encoded in op-code"
         (if (bitwise-and op-code 0x00001000) ;; is access to (parameter or local)  | arg, else access to global
             (if (bitwise-and op-code 0x00000100)
                 (nth (call-frame-params (vm-call-frame avm)) (bitwise-and op-code 0x00000011))
               (nth (call-frame-locals (vm-call-frame avm)) (bitwise-and op-code 0x00000011)))
           (nth (vm-globals avm) (bitwise-and op-code 0x00000111))))

    (def (vm-interpret-byte+ (avm vm)) -> vm
         "interpret byte+ instruction"
         (def-local src-ops (vm-peek-inst-byte avm 0))
         (def-local target (vm-peek-inst-byte avm 1))
         (byte-cell! (native+ (cell-byte (vm-decode-operand-ptr-high src-ops avm))
                              (cell-byte (vm-decode-operand-ptr-low src-ops avm)))
                     (vm-decode-operand-ptr-low target avm))
         (vm-next-inst-byte! avm 3))

    (def (copy-parameter
          (avm vm)
          (parameter-number byte "number of parameters")
          (parameters cell-array "array of locals+parameters")
          (start-idx byte        "current index into the parameters array"))
         -> void
         "copy parameter-number many parameters, encoded in the following instruction bytes
          of avm into the parameters array, starting at start-idx"
         (when (> parameter-number 0)
           (def-local encoded-param (vm-peek-inst-byte avm))
           ;; for single byte encoded parameter, if encoded in high/lowbyte, this is more complex
           (vm-next-inst-byte! avm)
           (nth-set! parameters start-idx (vm-decode-operand-ptr encoded-param avm))
           (copy-parameter avm (1- parameter-number) parameters (1+ start-idx)) ;; tailcall!
           )

    (def (vm-interpret-call (avm vm)) -> vm
         "interpret a call to a function"
         (vm-next-inst-byte! avm) ;; point to next byte
         (vm-call-stack! avm (cons (vm-frame avm) (vm-call-stack avm))) ;; push current call onto callstack
         (def-local function-index (vm-peek-inst-int avm))
         (vm-next-inst-byte! avm 2) ;; point to #of params
         (def-local parameter-number (vm-peek-inst-byte avm))
         (vm-next-inst-byte! avm) ;; point to first param (or next instruction)
         (def-local function (nth (vm-functions avm) function-indx))
         (def-local local-number (function-locals-count function))
         (def-local value-array (cell-array (+ local-number parameter-number)))
         (copy-parameters avm parameter-number values-array local-number)
         (vm-frame! avm
                    (call-frame
                     (continuation 0 function-index))
                    local-number
                    parameter-number
                    value-array)
         avm)

    (def (vm-interpret-return (avm vm)) -> vm
         "interpret the return of a called function"
         ;; implementation incomplete
         )
  #+end_src
- decomposed functions
  - complex structure creation
    #+begin_src scheme
      (def (vm-new) -> vm
           "create an initialized vm"
           (vm :call-stack '()
               :functions  [(function :byte-code    [0]
                                      :locals-count 0
                                      :name         "just-break")]
               :frame      (call-frame :cont         (continuation 0 0)
                                       :param-count  0
                                       :locals-count 0
                                       :locals       []
                                       :parameters   [])
               :globals    []))
    #+end_src
    #+begin_src scheme
      (empty-list l1)                           ;; '()

      (zero-byte l14)                           ;; l14 = 0
      (make-array l11 1 l14)                    ;; l11 = [0]
      (zero-byte l12)                           ;; l12 = 0
      (string l13 "just-break")                 ;; l13 = "just-break"
      (struct-create l5 'function l11 l12 l13)  ;; l5 = (function [0] 0 "just-break")
      (make-array l2 1 l5)                      ;; l2 = [(function [0] 0 "just-break")]

      (zero-int l10)                            ;; l10 = 0 (int)
      (zero-int l15)                            ;; l15 = 0 (int)
      (struct-create l9 'continuation l10 l15)  ;; l9 = (continuation 0 0)
      (zero-byte l16)                           ;; l16 = 0
      (zero-byte l17)                           ;; l17 = 0
      (empty-array l18)                         ;; l18 = []
      (empty-array l19)                         ;; l19 = []
      (struct-create l3 'call-frame l9 l16 l17 l18 l19) ;; l3 = (call-frame (continuation 0 0) 0 0 [] [])

      (empty-array l4)                          ;; l4 = []
      (struct-create l0 'vm l1 l2 l3 l4)        ;; (vm '() [(function [0] 0 "just-break")] (call-frame (continuation 0 0) 0 0 [] []) [])
    #+end_src
  - function with access to complex structure
    #+begin_src scheme
      (def (vm-next-inst-byte! (avm vm)) -> vm
           "return vm pointing to next instruction byte (no bounds check)"
           (def-local cont (call-frame-cont (vm-frame avm)))
           (continuation-byte-index!
            cont
            (int-inc (continuation-byte-index cont))))
    #+end_src
    the following byte code can optimize the locals usage by reusing registers that are no longer used
    #+begin_src scheme
      (function vm-next-inst-byte!)

      ;; (ensure-args 1) ;; structure ref cell
      ;; (ensure-struct 'vm 0) ;; arg0 = structure of type vm
      ;; (ensure-locals 3) ;;

      (struct-get l0 'frame p0)      ;; l0 - call-frame  (frame of avm)
      (struct-get l1 'cont l0)       ;; l1 - cont        (continuation of call-frame)
      (struct-get l2 'byte-index l1) ;; byte index
      (int++ l2)
      (struct-set 'byte-index l1 l2)
      (return arg0)
    #+end_src
  - function with struct access and array access
    #+begin_src scheme
      (def (vm-peek-inst-byte (avm vm) (off byte 0)) -> byte
           "return the byte currently pointed to by frame"
           (def-local cont (call-frame-cont (vm-frame avm)))
           (def-local functions (vm-functions vm))
           (def-local func (array-at functions (continuation-function-index cont)))
           (array-at (function-byte-code func) (+ off (continuation-byte-index cont))))
    #+end_src
    #+begin_src scheme
      (function vm-peek-inst-byte)

      ;; (ensure-args 2)
      ;; (ensure-struct 'vm 0)
      ;; (ensure-byte 1)
      ;; (ensure-locals 8)

      (struct-get l0 'frame p0)          ;; l0 = (vm-frame avm)
      (struct-get l1 'cont l0)           ;; l1 = (call-frame-cont (vm-frame avm))
      (struct-get l2 'functions p0)      ;; l2 = (vm-functions avm)
      (struct-get l3 'function-index l2) ;; l3 = (continuation-function-index l1)
      (array-at l4 l2 l3)                  ;; l4 = array (l2) at index (l3)
      (struct-get l5 'byte-code l4)      ;; l5 = (function-byte-code l4)
      (struct-get l6 'byte-index l1)     ;; l6 = (continuation-byte-index l1)
      (int+ l7 p1 l6)                      ;; l7 = (+ off l6)
      (array-at l8 l5 l7)                  ;; l8 - array (l5) at (l7)
      (return l8)
    #+end_src
  - function with byte->int conversion
    #+begin_src scheme
      (def (vm-peek-inst-int (avm vm) (off byte 0) -> int
           "return the int currently pointed to by the frame"
           (def-local cont (call-frame-cont (vm-frame avm)))
           (def-local functions (vm-functions vm))
           (def-local func (array-at functions (continuation-function-index cont)))
           (def-local index (+ off (continuation-byte-index cont)))
           (bytes->int
            :low (array-at (function-byte-code func) index)
            :high (array-at (function-byte-code func) (1+ index)))
    #+end_src
    #+begin_src scheme
      (function vm-peek-inst-int)

      ;; (ensure-args 2)
      ;; (ensure-struct-arg 'vm 0)
      ;; (ensure-byte-arg 1)
      ;; (ensure-locals 11)

      (struct-get l0 'frame p0)
      (struct-get l1 'cont l0)
      (struct-get l2 'functions p0)
      (struct-get l3 'function-index l1)
      (array-at l4 l2 l3)
      (struct-get l5 'byte-index l1)
      (int+ l6 p1 l5)
      (struct-get l7 'byte-code l2)
      (array-at l8 l7 l6)
      (int++ l6)
      (array-at l9 l7 l6)
      (make-int l10 l8 l9)
      (return l10)
    #+end_src
  - function reverse with list building and tail call recursion
    #+begin_src scheme
      (defun (revers (a-list (listof cell)) (b-list (list cell) '())) -> (list cell)
        "reverse a-list, consing it into b-list"
          (if (nil? a-list)
              b-list
              (reverse (cdr a-list) (cons (car a-list) b-list))))
    #+end_src
    #+begin_src scheme
      (label :tail-call)
      (bra-empty-list P0 :return)
      (car L0 P0)
      (cons P1 L0 P1)
      (cdr P0 P0)
      (goto :tail-call)
      (label :return)
      (return P1)
    #+end_src
  - function with case
    #+begin_src scheme
      (def (vm-interpret-instruction (avm vm)) -> vm
           "execute the current instruction of the vm"
           (def-local byte-code (vm-peek-inst-byte avm))
           (case byte-code
             [01 (vm-interpret-byte+ avm)]
             [else (throw-usr-exception "unknown opcode ~a" byte-code)]))
    #+end_src
    #+begin_src scheme
      (function vm-interpret-instruction)

      ;; (ensure-args 1)
      ;; (ensure-struct 'vm 0)
      ;; (ensure-locals 2)

      (call l0 'vm-peek-inst-byte 1 p0)
      (case l0 1
        1 'byte+-label)
      (throw-exception 1 "unknown-opcode ~a" l0)
      (label 'byte+-label)
      (call l1 'vm-interpret-byte+ 1 p0)
      (return l1)
    #+end_src
- define byte code for interpreter
  - idea: there is only one vm => can be statically assigned to a memory region (for snapshot, this vm can be copied into a separately allocated region if needed)
  - idea: statically created structures could be encoded into the actual values => need for data layout?
  - idea: for tight loops/tail calls, some locals could be held on zero page (register is probably not available)
  - idea: it seems like the copying of locals and parameters is a bit too much for just a function call. this should be more lightweight!!
          maybe keep a separate memory location where the currently passed parameters are?
          do a indirect copy, by copying only references?
          keep another offset that should be added to all local parameter access offsets? ldat (zp-current-args),x <- offset that is adjusted accordingly

          no shared args
          [call0-arg0-cell]      <- zp-current-args (during call 0)
          [call0-arg1-cell]
          ...
          [call1-arg0-cell]      <- zp-current-args (during call 1)
          [call1-arg1-cell]
          ...

          sharing arg1 (or start sharing here)
          [call0-arg0-cell]      <- zp-current-args (during call 0)
          [call0-arg1-cell]      <- zp-current-args (during call 1)   :  lda (..),x such that x = 0 for shared arg1, x = .. for call1-arg0 ... => x is set dynamically?
          ...                                                            indices are stored in separate memory: ldx $zp-arg0-idx, then lda (zp-current-args),x (for first 8 bits)
          [call1-arg0-cell]
          [call1-arg1-cell]
          ...
- collected-commands
  commands in braces are extended/optional commands
  commands tagged (!) do have allocation / deallocation requirements
  registers are always statically allocated locations for each function call (locals) or globally allocated (globals)
  a register is always a cell, a list-register is basically using two slots
  - [X] array-get <into-reg> <array-reg> <index-reg> ::
  - [X] array-set <array-reg> <index-reg> <value-reg> ::
  - [ ] array-cpy <into-reg> <array-reg> <reg-start> <reg-end> ::
  - [ ] array-len <into-reg> <array-reg> ::
  - [X] array-create <into-reg> <array-len> <default-val> ::
  - [X] bra-empty-list <reg> <label> :: jump to label if reg(tos) is an empty list (e.g. car = 0000 0000 0000 0001)
  - [ ] bra <boolean-reg> <label> ::
  - [ ] bra-b/i-(n)-less <reg-a> <reg-b> <label> ::
  - [ ] bra-b/i-(n)-greater <reg-a> <reg-b> <label> ::
  - [ ] bra-b/i-(n)-equal <reg-a> <reg-b> <label> ::
  - [ ] bra-b/i-(n)zero <reg> <label> :: branch on byte/integer (not) zero
  - [ ] break :: stop execution
  - [-] byte+-*/ <into-reg> <reg-1> <reg-2> :: add two registers into-reg
  - [-] byte-and/or/xor <into-reg> <reg-mask> <reg-value> ::
  - [ ] byte++-- :: increment/decrement byte register
  - [ ] byte-less/greater/equal? <into-reg> <reg-a> <reg-b> ::
  - [ ] byte-zero? <into-reg> <reg> ::
  - [X] call <into-reg> <fun> <#params> <p0> ... <pN> :: call a specific function (by ptr/int-id) + parameter (#locals is got from the function list/array)
  - [X] car <into-reg> <list-reg> :: is accessing the first cell of a list (car/cdr cell)
  - [X] cdr <into-reg> <list-reg> :: is resolving the second cell of a list (cdr cell), pointing to another cell-pair of (car/cdr) into-reg (and the next register) if <cell-num> = 2
  - [X] cons <into-reg> <value-reg> <list-reg> :: <list-reg> must be a pointer to a list, it cannot be the car/cdr pair, a new car/cdr pair needs to be allocated and the car/cdr cell pairs ref-count of the original list must be increment???!!!
  - [X] case <val-reg> <num> <const-0> <label-0> ... <const-n> <label-n>  ::
  - [ ] compare <into-reg> <reg-a> <reg-b> :: compare to values (char, byte, int, string? ...)
  (- empty-array <reg> :: set reg to an empty array)
  - [ ] empty-list? <into-reg> <reg> :: set boolean if list is empty
  (- ensure-args <num> :: make sure num arguments are on the eval stack for this function)
  (- ensure-locals <num> :: ensure enough locals are allocated for this function)
  (- ensure-struct <struct-label> <num> :: ensure arg-num is of type struct-label)
  (- ensure-byte-arg <idx> :: make sure that parameter at idx has type byte)
  (- ensure-int-arg <idx> :: make sure that parameter at idx has type int)
  (- ensure-string-arg <idx> :: make sure that parameter at idx has type string)
  (- ensure-float-arg <idx> :: make sure that parameter at idx has type float)
  (- ensure-array-arg <idx> :: make sure that parameter at idx has type array)
  (- ensure-list-arg <idx> :: make sure that parameter at idx has type list)
  (- ensure-map-arg <idx> :: make sure that parameter at idx has type map)
  - (!) free-list <reg>
  - (!) free-array <reg>
  - (!) free-float <reg>
  - (!) free-map <reg>
  - (!) free-struct <reg>
  - [X] goto <label> :: simply jump
  - [-] int+-*/ <into-reg> <reg-1> <reg-2> ::
  - [ ] int-and/or/xor <into-reg> <reg-mask> <reg-value> ::
  - [-] int++-- <reg> :: increment/decrement int register
  - [ ] int-(n)less/greater/equal <into-reg> <reg-a> <reg-b> :: integer (not) less/greater/equal the other
  - [ ] int-zero <into-reg> ::
  - [X] label <symbol> :: jump-target (has no bytecode!)
  - [ ] logical-and/or <into-reg> <reg-a> <reg-b> :: could be encoded using byte=0 for false, and byte=1 for true
  - [ ] logical-not <into-reg> <reg> ::
  - [X] make-array <into-reg> <num> <reg-1> ... <reg-n> :: create an array into-reg of num elements
  - [ ] (!) make-empty-list <reg> :: set reg to an empty list
  - [X] make-int <into-reg> <low-reg> <high-reg> ::
  - [ ] (!) make-list <into-reg> <num> <reg-1> ... <reg-n> :: create a list of the <num> topmost cells on the stack, putting car and cdr on the stack
  - [ ] (!) make-string <into-reg> <string> :: create string into-reg
  - [ ] make-zero-(byte/int) <reg> :: make a zero byte/int cell in reg
  - [X] make-byte-immediate <into-reg> byte-constant ::
  - [X] make-int-immediate <into-reg> int-constant ::
  - [ ] (!) string->list <into-reg> <string-reg> :: make a list of chars from a string
  - [ ] (!) list->string <into-reg> <list-reg> :: make a string from a list of chars
  - [ ] (!) array->list <into-reg> <array-reg> ::
  - [ ] (!) list->array <into-reg> <list-reg> ::
  - [ ] (!) map->list <into-reg> <list-reg> :: list of key-value pairs
  - [ ] (!) list->map <into-reg> <list-reg> :: make a map from a list of key-value pairs
  - [X] (!) return <reg> :: simple return
  - [ ] (!) return-list <reg> :: return list (reg and next reg)
  - [X] (!) struct-create <into-reg> <label> <reg-1> ... <reg-n> :: create structure label into-reg setting its fields to <reg-1>..<reg-n>
  - [-] struct-get <into-reg> <data-off> <struct-reg> :: get cell at data-off to structure in reg into-reg
  - [-] struct-set <data-off> <struct-reg> <value-reg> :: set cell at data-off in structure reg to value in second reg
  - [-] throw-exception <num> <string> <reg-0> ... <reg-n> :: throw an exception with num context vars and a string message
*** DONE syntax considerations and parser
- IDEA: make syntax for list-types more compact
  e.g postix * to indicate a list of a certain type, [] to indicate array
  #+begin_src scheme
    (m-def (my-fun (a-list byte*) (b-list byte*) -> byte*
                   "add")
           (;; body ...
            ))
  #+end_src
- simple translator scheme->byte-code
- (m-def (<name> (<arg> <type> <default) ..) -> <type>
   ...)
  gets translated to a funcion definition that can be added to the virtual machine
- (<name> <arg> ...)
  gets translated to (resolving name to function-index)
  (call <target-reg> function-index <param-no> ...)
- there needs to be done some register allocation (VM_​Lx)
  each (sub) expression is assigned to a local register
  a register that is not used later in the program can be reused (optimization => later)
*** DONE stack machine vs. register machine
**** excursion - code size (byte code) using a stack machine instead of register machine
#+begin_src scheme
  (m-def (reverse (a-list (list cell)) (b-list (list cell) '()) -> (list cell)
                  "reverse a-list, consing it into b-list")
         (if (nil? a-list)
             b-list
             (reverse (cdr a-list) (cons (car a-list) b-list))))
#+end_src
- transformed into stack machine code
  ;; the two parameter are on the stack
  ;; 0 nil? stack-1 (a-list) -> stack
  ;; 1 bra + ..
  ;; 3 cdr stack-1 (a-list) -> stack
  ;; 4 car stack-2 (a-list) -> stack
  ;; 5 cons tos (car a-list) stack-2 (b-list)  -> stack
  ;; 6 drop stack-3 .. stack-2 ;; tail call opt (drop original parameters, using tos and tos-1
  ;; 8 goto (nil?)
  ;; 10 drop stack-1 ;; just keeping b-list
  ;; 11 return
- total size 11..13 bytes (optimized)
  => potentially byte code more compact
  interpretation might be more costly (since no zero page optimization/register optimization) is done beforehand
  current idea: copy parameter/refs to zero page and operate with constant offsets there
  could be more costly because of copy from to zero page
  how about stack machine + copy relevant part of the stack into zero page to have indexed access (called method holds info of stack range used)
**** implement a stack vm (redo some of first iteration)
- byte code stays basically the same, except that operands are on the stack!
- the virtual machine has to redone to allow that
***** simple function
- simple function to do byte plus two parameter
  #+begin_src scheme
    (def (f (a : byte) (b : byte)) : byte
         "add a and b by using vm-instruction byte add"
         (b+ a b))

    (f 10 11)
  #+end_src
- define byte code
  #+begin_src scheme
    ;; function expecting 2 parameters on the stack (each stack element is one cell, => a list = two elements on the stack, car-cell, cdr-cell
    (call-byte+) ;;  replace tos with (+ tos tos-1)
    (ret)
  #+end_src
***** tail call function
- tail recursive function using lists
  #+begin_src scheme
    (def (sum (bl (list byte)) (acc byte 0)) -> byte
         "tail recursive function with accumulator"
         (if (nil? bl)
             acc
             (sum (cdr bl) (byte+ acc (car bl)))))

    (sum (list 10 20))
  #+end_src
- define byte code 1  <-- preferred solution
  explicit push of parameters on the value stack
  same smallest byte code size of program (17 bytes)
  makes copy of parameter explicit
  all functions use the (value) stack as parameters
  the params and locals can be held on freely accessible value stack
  these can be copied into the zero page for faster access (e.g. r/w access 2+ or something) and/or tailcalls
  #+begin_src scheme
    (push param0)               ;; 1..2             p0->p1->p0
    (nil? [tos -> tos ])        ;; 1                p0->p1->NIL? p0
    (bra [tos] -> +11)           ;; 2 removes tos    p0->p1
    (push param0)               ;; 1..2             p0->p1->p0
    (cdr [tos -> tos]           ;; 1                p0->p1->(cdr p0)
    (push param1)               ;; 1..2             p0->p1->(cdr p0)->p1
    (push param0)               ;; 1..2             p0->p1->(cdr p0)->p1->p0
    (car [tos -> tos]           ;; 1                p0->p1->(cdr p0)->p1->(car p0)
    (call-byte+)                ;; 1 tos = car bl, tos-2 acc, replace top 2 stack elements with 1 result   p0->p1->(cdr p0)->(+ p1 (car p0))
    (pop ->param1)              ;; 1..2             p1=(+ p1 (car p0))   p0->p1->(cdr p0)
    (pop ->param0)              ;; 1..2             p0=(cdr p0)          p0->p1
    (goto -13)                  ;; 2 recursive call
    (drop tos-1 .. tos-1)        ;; 2               p1
    (ret)                       ;; 1
  #+end_src
- define byte code 2
  relative to tos
  negative: params have changing offsets (depending on the current size of the stack)
  negative: encoding is more complext
  positive: less stacky, easier to read
  same smallest byte code size of program
  #+begin_src scheme
    (nil? tos-1 [ -> tos ])      ;; 2 increases stack
    (bra [tos] -> +x)            ;; 2 removes tos
    (cdr tos-1) -> tos           ;; 2 increases stack
    (car tos-2) -> tos           ;; 2 increases stack
    (call-byte+ [2] tos tos-2)   ;; 2 tos = car bl, tos-2 acc, replace top 2 stack elements with 1 result
    (drop tos-3 .. tis-2)        ;; 2
    (goto -x)                    ;; 2 recursive call
    (drop tos-1 .. tos-1)        ;; 2
    (ret)                        ;; 1
  #+end_src
- define byte code 3
  relative to base of stack (when entered function)
  sb+0 = param 0, sb + 1 = param 1
  positive: same values are accessed with same index (e.g. param-0 always with sb+0)
  negative: more complex command encoding
  same smallest byte code size of program
  #+begin_src scheme
    (nil? sb+0 [ -> tos ])      ;; 2 increases stack (sb+2)
    (bra [tos = sb+2] -> +x)    ;; 2..3 removes tos
    (cdr sb+1) -> tos           ;; 2 increases stack (sb+2)
    (car sb+0) -> tos           ;; 2 increases stack (sb+3)
    (call-byte+ [2] sb+3 sb+1)  ;; 2..3 sb+3 = car bl, sb+1 acc, replace top 2 stack elements with 1 result (sb+3)
    (drop sb+0 .. sb+1)          ;; 2 sb+0 .. sb+1
    (goto -x)                   ;; 2 recursive call
    (drop sb+0 .. sb+0)          ;; 2
    (ret)                       ;; 1
  #+end_src
- example call encoded
  #+begin_src scheme
    (push-byte 10) ;; 2
    (push-byte 20) ;; 2
    (push-byte 2)  ;; 1  two elements to make a list from
    (make-list)    ;; 1
    (push-byte 0)  ;; 2  default parameter (accumulator) initialized with 0
    (push-id 'sum) ;; 3  push the function id on the stack
    (call)         ;; 1  execute call on the following stack  p0->p1->low(function)->high(function)
  #+end_src
***** second tail recursive function
- original
  #+begin_src scheme
    (m-def (reverse (a-list (list cell)) (b-list (list cell) '()) -> (list cell)
                    "reverse a-list, consing it into b-list")
           (if (nil? a-list)
               b-list
               (reverse (cdr a-list) (cons (car a-list) b-list))))
  #+end_src
- byte code (optimized) ca. 14 bytes
  #+begin_src scheme
    (push param0)  ;; 1
    (nil?)         ;; 1
    (bra +9)      ;; 2
    (push param0)  ;; 1
    (car)          ;; 1
    (cons)         ;; 1 (reuse b-list, being second parameter and on the stack)
    (push param0)  ;; 1
    (cdr)          ;; 1
    (pop param0)   ;; 1
    (goto -11)     ;; 2
    (drop param0)  ;; 1
    (ret)          ;; 1
  #+end_src
- byte code (naiive) ca. 16 bytes
  #+begin_src scheme
    (push param0) ;; 1
    (nil?)        ;; 1
    (bra +11)     ;; 2
    (push param1) ;; 1
    (push param0) ;; 1
    (car)         ;; 1
    (cons)        ;; 1
    (push param0) ;; 1
    (cdr)         ;; 1
    (pop param0)  ;; 1
    (pop param1)  ;; 1
    (goto -13)    ;; 2
    (drop param0) ;; 1
    (ret)         ;; 1
  #+end_src
***** structures
****** create (programmatically)
#+begin_src scheme
  (push-byte 1)    ;; 2
  (push-byte 2)    ;; 2
  (push-id 'point) ;; 3
  (create-struct)  ;; 1   tos = structure reference
#+end_src
****** access
******* read
#+begin_src scheme
  ;; tos = structure reference
  (push-byte 2)    ;; field index
  (field-read)     ;; replace structure ref and field index with value read
#+end_src
******* write
#+begin_src scheme
  ;; tos = structure reference
  (push-byte 2)    ;; 2 field index
  (push-int 17)    ;; 3 value
  (field-write)    ;; replace structure ref, field index with value set ?
#+end_src
***** higher order function passing (closure is a anonymous function, just a function in the vm)
#+begin_src scheme
  (m-def (mapr (a-fun (fun T -> S)) (a-list (listof T)) (b-list (listof S) '()) -> (listof S))
         (if (empty? a-list)
             b-list
             (mapr a-fun (cdr a-list) (cons (a-fun (car a-list)) b-list))))

  (m-def (inc (a-byte byte) -> byte)
         (byte+ a-byte 1))

  (mapr inc '(1 2)) ;; yield '(3 2), since this map version reverses the original list
#+end_src
***** define interpreter (in racket)
****** state
- vm-frame :: execution frame
  fun-idx (int)
  byte-code-idx (int)
  [local-stack (arrayof cell), first n are the parameters passed]
  [tos-idx (byte), index into local-stack]
- vm-function-def :: a function definition
  total-stack-size-used (byte)
  name (string)
  byte-code (arrayof byte)
- vm :: the complete state of the virtual stack oriented machine
  frame-stack (listof vm-frame)
  value-stack (listof cell)
  functions (arrayof vm-function-def)
  active-frame (vm-frame)
  globals (arrayof cell)
  structs (arrayof vm-struct-def)
  options (listof symbol)
***** IDEA: speedup pop to param
- drawback: unified view of stack is lost
- params could be held in an array (number is known)
- local stack could be an array (number is limited)
  => push-local = store x idx++
  => push-for-call = store into array of called function?
  => result of function is either pushed to local or pushed to next call
*** DONE code generator
**** DONE tidy up code base
- find naming conventions for the different phases
  - ast- :: nodes in the ast
  - m- :: parsers for mil
- make elements of the ast more explicit to be relevant for a certain phase
- get an overview of what information is necessary for the different phases
- decide on where in the ast to keep this information
- find a way to make additions to racket structures less invasive and prone to include massive code changes (use typed attribute lists?)
**** DONE write code generator for stack machine (m-def ...)
**** OBSOLETE old ideas for vm interpreter
   thoughts about decoding (speed) of opcodes with 6510 assembly
   general: table: opcode -> address of handler
   e.g: BRK = 0 (opcode is in X), LDA 4000,X -> PHA -> LDA 4100,X -> PHA -> RTS : len=9, cycles=20
   alternative: LDA 4000,X -> STA $???? -> BNE $?? <- only byte byte offset possible, target contains e.g. JMP $???? => 127 / 3 opcodes possible (42): len = 8 + 3, cycles=14

   short instructions (shifted opcode) -> address of handler
   AND #$11110000 (maskout opcode),
   x-times LSR (shift to right index position)
   TAX
   use as index for table access (or), use sparse memory (use list-car-cdr fields for freelist to fill up?)
   after and us directly as index into some table?


   how about 16 commands in the low nibble if top bit is set
   and if msb is not set, use only 112 of the other 128 possibilites to code the rest
   then stuff them together such that 128 possibilies remain that can be mapped to 2 x 128 byte jump targets in one page!
   #b1rrrxxxx with xxxx = opcode selector, rrr = operand
   #b0tttxxxx (but only 112 used) with ttt != 000

           LDA ($PC),Y
           BPL OPCODE
           AND #$0F
   OPCODE: ASL
           STA JMPOP+1
   JMPOP   JMP OPTBL

   optimize to remove asl
   how about 16 commands in the low nibble if top bit is set
   and if msb is not set, use only 112 of the other 128 possibilites to code the rest
   then stuff them together such that 128 possibilies remain that can be mapped to 2 x 128 byte jump targets in one page!
   #b1rrxxxxr with xxxx = opcode selector, rrr = operand
   #b0xxxxxx0 (but only 112 used) with tt ...t != 00...0

           LDA ($PC),Y
           BPL OPCODE
           PHA ;; keep for register decoding
           AND #$1E
   OPCODE: STA JMPOP+1
   JMPOP   JMP OPTBL

   the memory layout of the handler table then is one page
   OPTBL+0:  low-byte  #b1rr0000r (short command PUSH)
   OPTBL+1:  high-byte #b1rr0000r (short command PUSH)
   OPTBL+2:  low-byte  #b1rr0001r (short command POP)
   OPTBL+3:  high-byte #b1rr0001r (short command POP)
           ...
   OPTBL+32  low-byte of command #b00010000 normal command (e.g. NOP)
   OPTBL+32  high-byte of command #b00010000 normal command (e.g. NOP)
           ...
   OPTBL+254 low byte of command #b01111110
   OPTBL+255 high byte of command #b01111110

   decoding rrr scattered over the byte takes too much processing => short commands may be scattered


   Current option
   TODO: move documentation into org file
   TODO: POC implementation for selected cases (normal opcode, short opcode, long opcode, normal operand, short operand [bra/goto, push, pop], long operand)

   alternative: use 128 (non short) commands with bit0 always 0 => LDA ($PC),Y -> STA JMPOP+1 -> JMP OPTBL (8 bytes, 12-cycles)

   13 bytes, (5,2,3|2+2,4,3) -cycles 17 regular|18 short
   INC-NEXT:   INY               ;; jump target if iny needs to be exexuted before fetch
   FETCH-NEXT: LDA ($PC),Y
               ASL
               BCC OPERAND
               AND $F0           ;; mask out has to take place to make sure, other bytecodes do not collide with short ones (after removing bit 7 through asl)
   OPERAND:    STA JMPOP+1
   JUMPOP:     JMP OPTBL

   OPTBL+$00: low/high #b10000rrr  (short e.g. PUSH-LOC/PARAM)
   OPTBL+$02: low/high #b00000001  (normal command e.g. NOP)
   OPTBL+$04: low/high #b00000010  (normal command e.g. BYTE-)
   ...
   OPTBL+$10: low/high #b10001rrr  (short e.g. POP-LOC/PARAM)  0..3 (registers)
   OPTBL+$12: low/high #b00001001  (normal command e.g. BYTE+)
   ...
   OPTBL+$40: low/high #b101xxrrr  (short e.g. GOTO) $40, $50, $60, $70 contain same jump address (GOTO)
   OPTBL+$50: low/high #b101xxrrr  (short e.g. GOTO)
   OPTBL+$60: low/high #b101xxrrr  (short e.g. GOTO)
   OPTBL+$70: low/high #b101xxrrr  (short e.g. GOTO)
   ...
   OPTBL+$80: low/high #b110xxrrr  (short e.g. BRA) xxrrr is the offset
   OPTBL+$90: low/high #b110xxrrr  (short e.g. BRA)
   OPTBL+$A0: low/high #b110xxrrr  (short e.g. BRA)
   OPTBL+$B0: low/high #b110xxrrr  (short e.g. BRA)

   OPTBL+$C0: PUSH-BYTE/PUSH-INT
   OPTBL+$D0: PUSH-ARRAY (e.g. tos = cell-ptr- -> cell-array-, rrr = array-index) <- useful for fast struct access?
   OPTBL+$E0: POP-ARRAY  (e.g. tos = cell-ptr- -> cell-array-, rrr = array-index)
   OPTBL+$F0: NIL?-RET-PARAM/...

   in case of an array, cell-ptr- points to the first field, the array meta data is located in the bytes before field0)
                    array metadata
   array: cell-ptr->field0
                    field1

   decoding operand for PUSH LOC/PARAM
               LDA ($PC),Y
               AND #$07
               LSR
               BCC PUSH-PARAM
   PUSH-LOCAL: ...    ;; A = index to local to push
               JMP FETCH-NEXT|INC-NEXT
   PUSH-PARAM: ...    ;; A = index to param to push
               JMP FETCH-NEXT|INC-NEXT

   decoding operand for short BRA
                ;; check TOS on true first
   SBRA:        LDX #$00  ;; maybe x always pointer to tos, then ldx would not be necessary
                LDA ($TOS,X)
                CMP #$TRUE ;; first byte (of 16-bit cell- on tos) holds true/false bitmask
                BEQ SGOTO ;; branching will behave as goto from here
                JMP INC-NEXT ;; could be saved if bne to another jmp inc-next and then just fall through

   decoding operand for short GOTO
   SGOTO:       TYA           ;; first add current Y offset into PC
                CLC           ;; (TYA, PHA, AND, LDA do not affect carry => yes, clc is necessary)
                ADC $PCL
                BCC NO_INC
                INC $PCH
   NO_INC:      LDY #$00      ;; now that y was added to PC, it can be set to 0
                LDA ($PC),Y   ;; load short opcode (again)
                AND #$1F      ;; mask out the offset part
                CMP #$0f      ;;
                CLC           ;; carry needs to be empty for both cases (has no influence on BPL)
                BPL GE_0F     ;; bitmask is (1xxxx) which is interpreted as negative
                ;; CLC already done
                ADC $PCL
                BCC NO_INC2
                INC $PCH
   NO_INC2:     JMP FETCH-NEXT
   GE_0F:       EOR #$E0      ;; bitmask 0001xxxx -> 1111xxxx (no influence on carry)
                ;; CLC already done
                ADC $PCL
                BCS NO_DEC
                DEC $PCH
   NO_DEC:      JMP FETCH-NEXT


   decoding code (16 bytes)
                  ;; load new opcode into A
                  LDA ($PC),Y ;; y = temp delta to program counter, which is held in $PC on the zero page
                  BPL  OPCODE ;; if negative (highest bit set, it is a short opcode)
   SHORT_OPCODE:  AND #$F0    ;; mask out irrelevant bits
   OPCODE:        TAX         ;; opcode as index into X
                  LDA $4000,X ;; load high byte of handler for this command from sparse table $4000-$40FF
                  PHA
                  LDA $4100,X ;; load low byte (-1) of handler for this command from sparse table $4100-$41FF
                  PHA
                  RTS

   memory layout of code table
   4000 ?? ;; high byte of handler for OPCODE 0
   4100 ?? ;; low byte (-1) of handler for OPCODE 0

   4080 ?? ;; high byte of handler for OPCODE 128 (short PUSH)
   4081..408F ;; unused -> sparse (15 bytes)
   4090 ?? ;; high byte of handler for OPCODE 144 (short POP)
   4091..409F ;; unused -> sparse (15 bytes)

   given this coding, the upper half of the page is used sparsely (4080..40FF, and 4180..41FF), leaving (* 2 (- 128 16)) => 224 bytes free for other usage
   this sparse usage could be blocked if the short code would be shifted right | the short code would use the lower 4 bits (better)
   BMI OPCODE
   AND #$0F

   memory layout would then be
   4000 ?? ;; high byte of handler for short opcode $0 (PUSH)
   4001 ?? ;; high byte of handler for short opcode $1 (POP)
   4010 .. 407f ;; free mem (112 bytes block free <- usable e block e.g. for (free) list-cells 28, if ref counted less of course ≅ 22)
   4080 ?? ;; high byte of handler for regular opcode $80
   4081 ?? ;; high byte of handler for regular opcode $81


   how about a way to calc handler address from bytecode itself (e.g.) some ands, shifts + offset store and jump <​= depends on size of code implementation
   but this is wishful thinking, probably
   e.g. jsr prepare operand
        jsr execute command
        jsr store result

   other implementation (from plasma: https://dwheeler.com/6502/PLAVM.S.txt)
   vm code has lower bit never set (only 128 byte codes available)
   PC = current program counter, PCL lowbyte of PC, PCH  is highbyte of PC
   OPTBL holds 2 byte handler reference, that is jumped to
   FETCHOP: LDY #$00
            LDA (PC),Y      ;; load vm byte code (lower bit 0, no need to multiply to use as index)
            STA JMPOP+1     ;; write vm byte code into low byte of jump indirect command (modify code)
            JSR JMPOP       ;; jump to the jump command
            INC PCL         ;; PC++
            BNE FETCHOP     ;;
            INC PCH         ;;
            BNE FETCHOP     ;; ?? what if no branch is executed
   JMPOP:   JMP (OPTBL)     ;; indirect jump to handler for byte code


   idea: - Y has INC for PC after code was handled,
         - after code was handled, JMP ADJUST-PC is executed or
         - using threaded interpretation adds 8 bytes to the end of the handler (prereq: Y=0, PC is up to date or no overflow expected?), maybe just for most important commands to keep mem usage low?
                         LDA (PC),Y         ;; if a function is always < 256 byte => PC needs increment executing call, since within one call, y cannot overflow!
                         STA JMPOP*+1
               JMPOP*    JMP (OPTBL)

   ADJUST-PC:  TYA
               ADC PCL
               STA PCL
               BCC FETCH
               INC PCH
   FETCH:      LDY #$00
               LDA (PC),Y
               STA JMPOP+1
   JMPOP       JMP (OPTBL)

   plasma uses a 16 element X indexed eval stack of 16-bit width located in the zero page! (https://github.com/dschmenk/PLASMA?tab=readme-ov-file#code-optimizations)
   all parameters and temp values her on this stack (params are copied into the frame)
   invocation frames are organized as stack
   call/return are implemented using the 6510 processor stack (for speed), limiting e.g. non-tailcalled recursion or regular call-stack to 128 calls (- offset used by interpreter/system)

*** IMPLEMENT next
**** DONE write a sketch of a 6510 vm interpreter (partially, validating some design decisions)
- alternative: use 128 (non short) commands with bit0 always 0 => LDA ($PC),Y -> STA JMPOP+1 -> JMP OPTBL (8 bytes, 12-cycles)
- general design of vm
  PC = zero page 16 bit program counter, pointing to the byte code
  VS = zero page location of the Value Stack (16-bit cells) (max n elements on VS)
  alternative to VS on zero page: VS is a list (pointed to)
  LS = zero page location of locals (16 bit cells) (max n elements)
  Y index register = offset to PC (temporary)
  X index register = offset to Value Stack
  FR = zero page 16-bit pointer to current call frame
  - call frame (never spread over a page=> low byte is always >= 6)
       FA/C pointer to previous frame
       [optional FC function id (16bit)] <- not optional, actually needed for tail call (but only then)!
       old program-counter
       FE #of parameters (8bit)
       FF #size of value stack before call (including parameters)
    -> 00 parameter0
       02 parameter1
       ...
       xx saved val-stack element 0
       xy saved val-stack element 1
       ...
  - function decriptor
    number of parameters x function id x byte-code ...
    function id = 16 bit address (or # that has to be decoded)
      -> 00 opcode length of function (byte)
         01 number of parameter (byte)
         02 max delta size of eval stack
         03 first opcode of function
         04 2nd opcode of function
  - structure descriptor
    number of fields x structure id
  - array data layout
    in case of an array, cell-ptr- points to the first field, the array meta data is located in the bytes before field0)
                     array metadata
    array: cell-ptr->field0
                     field1
- main interpreter loop
  #+begin_src asm
    ;; 13 bytes, (5,2,3|2+2,4,3) -cycles 17 regular|18 short
     INC-NEXT:   INY               ;; jump target if iny needs to be exexuted before fetch
     FETCH-NEXT: LDA ($PC),Y
                 ASL
                 BCC OPERAND
                 AND $F0           ;; mask out has to take place to make sure, other bytecodes do not collide with short ones (after removing bit 7 through asl)
     OPERAND:    STA JMPOP+1
     JUMPOP:     JMP OPTBL
  #+end_src
- layout of the opcode jump targets
  OPTBL+$00: low/high #b10000rrr  (short e.g. PUSH-LOC/PARAM)
  OPTBL+$02: low/high #b00000001  (normal command e.g. NOP)
  OPTBL+$04: low/high #b00000010  (normal command e.g. BYTE-)
  ...
  OPTBL+$10: low/high #b10001rrr  (short e.g. POP-LOC/PARAM)  0..3 (registers)
  OPTBL+$12: low/high #b00001001  (normal command e.g. BYTE+)
  ...
  OPTBL+$40: low/high #b101xxrrr  (short e.g. GOTO) $40, $50, $60, $70 contain same jump address (GOTO)
  OPTBL+$50: low/high #b101xxrrr  (short e.g. GOTO)
  OPTBL+$60: low/high #b101xxrrr  (short e.g. GOTO)
  OPTBL+$70: low/high #b101xxrrr  (short e.g. GOTO)
  ...
  OPTBL+$80: low/high #b110xxrrr  (short e.g. BRA) xxrrr is the offset
  OPTBL+$90: low/high #b110xxrrr  (short e.g. BRA)
  OPTBL+$A0: low/high #b110xxrrr  (short e.g. BRA)
  OPTBL+$B0: low/high #b110xxrrr  (short e.g. BRA)

  OPTBL+$C0: PUSH-BYTE/PUSH-INT
  OPTBL+$D0: PUSH-ARRAY (e.g. tos = cell-ptr- -> cell-array-, rrr = array-index) <- useful for fast struct access?
  OPTBL+$E0: POP-ARRAY  (e.g. tos = cell-ptr- -> cell-array-, rrr = array-index)
  OPTBL+$F0: NIL?-RET-PARAM/...
- decoding operand for PUSH LOC/PARAM
  #+begin_src asm
                 LDA ($PC),Y
                 AND #$07
                 LSR
                 BCC PUSH-PARAM
    PUSH-LOCAL:  ...    ;; A = index to local to push
                 JMP FETCH-NEXT|INC-NEXT
    PUSH-PARAM:  ...    ;; A = index to param to push
                 JMP FETCH-NEXT|INC-NEXT
  #+end_src
- decoding operand for short BRA
  #+begin_src asm
                 ;; check TOS on true first
    SBRA:        LDX #$00  ;; maybe x always pointer to tos, then ldx would not be necessary
                 LDA ($TOS,X)
                 CMP #$TRUE ;; first byte (of 16-bit cell- on tos) holds true/false bitmask
                 BEQ SGOTO ;; branching will behave as goto from here
                 JMP INC-NEXT ;; could be saved if bne to another jmp inc-next and then just fall through
  #+end_src
- decoding operand for short GOTO
  #+begin_src asm
    SGOTO:       TYA           ;; first add current Y offset into PC
                 CLC           ;; (TYA, PHA, AND, LDA do not affect carry => yes, clc is necessary)
                 ADC $PCL
                 BCC NO_INC
                 INC $PCH
    NO_INC:      LDY #$00      ;; now that y was added to PC, it can be set to 0
                 LDA ($PC),Y   ;; load short opcode (again)
                 AND #$1F      ;; mask out the offset part
                 CMP #$0f      ;;
                 CLC           ;; carry needs to be empty for both cases (has no influence on BPL)
                 BPL GE_0F     ;; bitmask is (1xxxx) which is interpreted as negative
                 ;; CLC already done
                 ADC $PCL
                 BCC NO_INC2
                 INC $PCH
    NO_INC2:     JMP FETCH-NEXT
    GE_0F:       EOR #$E0      ;; bitmask 0001xxxx -> 1111xxxx (no influence on carry)
                 ;; CLC already done
                 ADC $PCL
                 BCS NO_DEC
                 DEC $PCH
    NO_DEC:      JMP FETCH-NEXT
  #+end_src
- push parameter on the value stack
  #+begin_src asm
    ;; parameter # is in A destroyed, X += 2 (new TOS), Y used, restored
            STY TEMP
            ASL ;; times 2
            TAY
            INX
            INX
            LDA (FR),Y
            STA VS,X
            INY
            LDA (FR),Y
            STA VS+1,X
            LDY TEMP
  #+end_src
- push local on the value stack
  #+begin_src asm
    ;; local # is in A destroyed, X += 2 (new TOS), Y used, restored
            STY TEMP
            ASL ;; times 2
            TAY
            INX
            INX
            LDA LS,Y ;; absolute addressing with prefix 00
            STA VS,X
            INY
            LDA LS,Y ;; absolute addressing with prefix 00
            STA VS+1,X ;;
            LDY TEMP
  #+end_src
- pop from the value stack into local
  #+begin_src asm
    ;; local # is in A destroyed, X -= 2 (new TOS), Y used, restored
            STY TEMP
            ASL ;; times 2
            TAY
            LDA VS,X
            STA LS,Y ;; absolute addressing with prefix 00
            LDA VS+1,X ;;
            STA LS+1,Y ;; absolute addressing with prefix 00
            DEX
            DEX  ;; pointing at low byte (tos)
            LDY TEMP
  #+end_src
- call a function (stacked call <= allows for variable calls, call operation with operand <= static call)
  - call copies parameter from value stack->call frame and copies remaining values from value stack -> call frame (to restore after call)
    - static call (function id = 16 bit operand of call command)
      - create new invocation frame
        get # of parameters, params*2 + 6 = frame size to allocate
        NF = zero page new frame (16-bit)
        #+begin_src asm
                    ;; --- get new function as 16 bit operand of the current opcode
                    INY
                    LDA (PC),Y
                    STA NFUN
                    INY
                    LDA (PC),Y
                    STA NFUN+1

                    ;; --- allocate call frame
                    ;; LDY #$01
                    ;; LDA (NFUN),y ;; # params
                    TXA
                    ;; ASL ;; either keep the number of parameters doubled (number of bytes), or just use the length of the current value stack!
                    ADC #$06
                    JSR ALLOCATE_MEM ;; writes PTR

                    ;; --- fill call frame
                    DEY
                    LDA FR        ;; now fill allocated call frame with data
                    STA (PTR),Y
                    INY
                    LDA FR+1
                    STA (PTR),Y   ;; ptr to previous is set
                    INY

                    ;; function id is not strictly necessary in call frame, is it?
                    ;; LDA NFUN
                    ;; STA (PTR),y
                    ;; INY
                    ;; LDA NFUN+1
                    ;; STA (PTR),y   ;; ptr to function descriptor is set
                    ;; INY

                    ;; store old program counter
                    LDA PC
                    STA (PTR),y
                    INY
                    LDA PC+1
                    STA (PTR),y
                    INY

                    ;; store parameter count
                    STY TEMP
                    LDY #$01
                    LDA (NFUN),Y
                    LDY TEMP
                    STA (PTR),y  ;; # of parameters
                    ;; STA TEMP ;; count of parameter to copy
                    INY

                    ;; store value stack size
                    TXA
                    STA (PTR),y ;; # of elements on the value stack (including parameters)
                    INY

                    ;; --- copy parameter (and value stack) into call frame
                    ;;
                    ;; now copy parameters (from value stack => parameters) and rest of value stack to call frame
                    ;; edge case (x=0: no parameters on the value stack, and value stack is empty)
                    TXA ;; set zero flag if X is zero!
                    BEQ NO_COPY
            COPY_VS2PARAMS:
                    LDA VS,X
                    STA (PTR),Y
                    INY
                    LDA VS+1,X
                    STA (PTR),Y
                    INY
                    DEX
                    DEX
                    ;; DEC TEMP ;; use if only parameters are copied
                    BNE COPY_VS2PARAMS
           NO_COPY:

                    ;; ------ set frame ptr to parameter 0 if this new frame
                    LDA PTR
                    ADC #$06  ;; point to first parameter (if any) / =4 if function id is not part of call frame
                    STA FR
                    LDA PTR+1
                    BCC NO_INC
                    INC
           NO_INC:  STA FR+1

                  ;; --- set new pc to byte code start of new function (which is new function ptr + 2)
                   LDA NFUN
                   ADC #$02
                   STA PC
                   LDA NFUN+1
                   BCC NO_INC2
                   INC
          NO_INC2: STA PC+1
                   LDY #$00 ;; no offset to PC
                   LDX #$00 ;; value stack empty
                   JMP FETCH-NEXT


        #+end_src
    - return from call (restore data from call frame)
      remember tos (which is the result of the function)
      restore value stack (without parameters)
      push memorized tos
      restore ptr to previous call frame
      restore PC
      #+begin_src asm
                ;; remember tos in temp (if value is returned and caller wants it)
                LDA VS,X
                STA TEMP
                LDA VS+1,X
                STA TEMP+1

                ;; restore value stack
                LDA FR
                STA NFR ;; keep low byte of current fr
                DEC FR
                LDX #$00
                LDA (FR,X)
                STA TEMP_VSSIZE
                DEC FR ;; make sure lowbyte of FR is never < 2
                LDA (FR,X)
                ASL
                STA TEMP_PARAM_COUNT_IN_BYTES
                ADC #$02 ;; compensate 2xdec fr
                ADC FR
                STA FR ;; set FR to first value after parameters
                LDA TEMP_VSSIZE
                SBC TEMP_PARAM_COUNT_IN_BYTES
                STA TEMP_VSSIZE
                TAY
                DEY
                LDX #$00
         LOOP:
                LDA (FR),Y  ;; high byte
                STA VS+1,X
                DEY
                LDA (FR),Y  ;; low byte
                STA VS,X
                DEY
                INX
                INX
                DEC TEMP_VSSIZE
                BNE LOOP

                ;; --- put old tos on value stack (if there is one, and the caller wants it!)
                LDA TEMP
                STA VS,X
                LDA TEMP+1
                STA VS+1,X
                INX
                INX

                ;; get old pc
                LDA FR
                SBC #$06 ;; FR points to old FR
                LDY #$02
                LDA (FR),Y
                STA PC
                INY
                LDA (FR),Y
                STA PC+1

                LDA FR
                STA PTR
                LDA FR+1
                STA PTR+1

                ;; get old call frame pointer
                LDY #$00
                LDA (FR),Y
                STA NFR
                INY
                LDA (FR),Y
                STA FR+1
                LDA NFR
                STA FR
                DEY ;; y = 0

                ;; PTR = call frame that can be freed
                JSR deallocate ;; should now the amount of bytes allocated, and can thus free this block

                JMP NEXT-FETCH





      #+end_src
  - IDEA: think about quicker/simpler call/ret mechanisms (optimizations for common cases)
    - reduce copying
    - e.g. reuse value stack if possible (e.g. keep parameters on value stack, still needs copying, but accessing parameters is cheaper?)
- tail call implementation
  get number of parameters
  write value stack -> parameter
  clear value stack
  set pc to start of function
  replace parameters with value stack and set pc to start of function
  #+begin_src asm
    ;; get function pointer and set pc to start of byte code of that function (could be cached in zero page, set upon call)
            lda fr
            sbc #$06
            sta fr
            ldy #$00
            lda (fr),y
            sta pc
            iny
            lda (fr),y
            sta pc+1

    ;; get number of parameters of this function (could be cached in zero page, set upon call)

            lda fr
            adc #$04
            sta fr ;; (fr),0 pointing to #parameters
            dey ;; 0 again
            lda (fr),y ;; number of parameters
            asl ;; number of bytes used by parameters
            inc fr ;; increment just once, such that (fr),y points to high byte of last parameter

            tay
            beq NO_COPY ;; tail call has no parameter

     ;; copy values from stack to parameters

     LOOP:
            lda vs+1,x         ;; tos = last parameter of function
            sta (fr),y
            dey
            lda vs,x
            sta (fr),y
            dex
            dex
            dey
            bne LOOP

     NO_COPY:
            inc fr ;; restore fr to point to first parameter

            ldx #$00
            ;; y already is zero
            JMP FETCH-NEXT
  #+end_src
- memory
  general ideas:
    floats, cells and list-cell-pairs are organized in free-lists
    each allocation type uses full pages => running out of space for a certain type require allocating a new page for that type
    structure/array need some best fit algorithm (per page)
      e.g. pages use power of 2 sized slots to hold arrays/structures of that size (e.g. smallest slots are 8 bytes, 16 32 64 128 256) other memory sizes are not supported yet.
      each page has a header
        00: first slot (if free, 1 byte offset to next free slot || $FF if this is the last free slot),
        00+slot-size: second slot ...
      pages are organized in two lists per type, list with pages with free slots (and the offset to the first free slot on that page) and list with fully allocated pages
      e.g. 1/2 page used for page meta data => high byte = page = index into meta data?

    _Data layout_ (for fixed non struct/array)
      ~FREEPAGE~   (byte) on zero page :: page with free slot(s) for list-pair-cell [0 = no free page available]
      ~FREEPAGE+1~ (byte) on zero page :: page with free slot(s) for cells          [0 = no free page available]
      ~FREEPAGE+2~ (byte) on zero page :: page with free slot(s) for floats         [0 = no free page available]

      (whole page used for freeslots)
      first two bytes can be used for meta data
      ~FREESLOT+2~ (byte) on some regular page :: offset to first free slot on page 2  [value 255 = no more free slots]
      ~FREESLOT+3~                             :: offset to first free slot on page 3
      ...
      ~FREESLOT+255~                           :: offset to first free slot on page 255

      (whole page used for next page)
      first two bytes can be used for meta data
      ~NEXT_​FREE​_PAGE+2~ (byte) on some regular page :: page id of a page of same type (as page 2) that holds free slots [value 0 = no next page]
      ~NEXT​_​FREE_PAGE+3~                             :: page id of a page of same type (as page 3) that holds free slots
      ...
      ~NEXT​_​FREE​_PAGE_+255~                          :: page id of a page of same type (as page 255) that holds free slots

  - allocate (new) page for type x
    #+begin_src asm
      ALLOCATE_NEW_PAGE: ;; Y = page type (0 list-cell-pair ,1 cell, 2 float), return A = page idx
              STY TEMP_TYPE
              LDY #$1F
      CHECK_PAGE_BITMAP:
              LDA PAGE_USE_BITMAP,Y
              CMP #$FF
              BNE FP_FOUND
              DEY
              BPL CHECK_PAGE_BITMAP
              JMP OUT_OF_MEMORY_ERROR ;; TODO if there are enqueued ref count decs, check those first

      FP_FOUND:
              PHA
              TYA
              ASL
              ASL
              ASL
              ;; now a has the topmost 5 bits set
              STA PAGE
              ;; now get the lower three bits
              LDX #$07
              PLA ;; get bit map
       SHIFT_OUT:
              LSR
              BCC UNSET_BIT_FOUND
              DEX
              BPL SHIFT_OUT
        UNSET_BIT_FOUND:
              TXA
              ORA PAGE ;; combine with bits
              STA PAGE

              LDA PAGE_USE_BITMAP,Y
              ORA BITS,X
              ;; make sure to set the bit of allocated page in page bitmap
              STA PAGE_USE_BITMAP,Y
              LDA PAGE
              RTS

        BITS: 0b10000000
              0b01000000
              0b00100000
              0b00010000
              0b00001000
              0b00000100
              0b00000010
              0b00000001

       ALT_UNSET_BUT_FOUND: ;; 4 bytes less, mean 28 cycles more
              TXA
              ORA PAGE ;; combine with bits
              STA PAGE

              LDA #$01
       SHIFT_AGAIN:
              ASL
              DEX
              BPL SHIFT_AGAIN
              ROR
              ORA PAGE_USE_BITMAP,Y
              STA PAGE_USE_BITMAP,Y
              LDA PAGE
              RTS
    #+end_src
  - initialize page of type x (setup free list within)
    - initialize list-cell-pairs page (without reference counts)
      #+begin_src asm
        ;; each slot is 4 byte SLOTSIZE = 4
                LDA #SLOTSIZE
                LDY #$00
        LOOP:
                STA (PTR),Y
                TAY
                ADC #SLOTSIZE
                BCC LOOP
                RTS
      #+end_src
  - list cell pair allocation [same for all slot - types]
    TODO: check for queued refcount decreases, execute x times until free cell is identified, if not stop that and continue with default behaviour
    find page with free list-cell-pair (type -> first free page || no free page then allocate new page)
    use free list-cell-pair
    adjust meta data to new first free slot of this page
    adjust meta data if page has no more free slots

    there are some pages that are automatically *unavailable: page 0 (zero page), page 1 (cpu stack)*
    #+begin_src asm
            ;; TYPE if cell is in Y (00 = list-pair-cell, 01 = cell, 02 = float)
                    STY TEMP
                    LDA FREEPAGE,Y ;; get page id of page with free slots (in zero page)
                    ;; now get the offset into the page of the first free slot
              GOT_PAGE:
                    TAY
                    LDA FREESLOT,Y ;; get offset w/i page of the first free slot (of the page idx in y)
                    BNE SLOT_AVAILABLE

                    ;; current page has no slot available, maybe next free does
                    LDA NEXT_FREE_PAGE,Y
                    BNE NEXT_FREE_OK

                    ;; next free is 0 => there is no page with free slots known => allocate new page of this type
                    STY TEMP+1
                    LDY TEMP
                    JSR ALLOCATE_NEW_PAGE
                    LDY TEMP+1
                    STA NEXT_FREE_PAGE,Y

                    LDY TEMP
          NEXT_FREE_OK:
                    STA FREEPAGE,Y
                    JMP GOT_PAGE

          SLOT_AVAILABLE:
                    STA PTR
                    STY PTR+1 ;; now PTR (on  zero page) points to the free slot

                    LDY #$00
                    LDA (PTR),y  ;; next free slot offset
                    CMP #$FF
                    BNE FREE_AVAIL_SLOT
                    LDA #$00 ;; value to indicate, that no free slot is available
      FREE_AVAIL_SLOT:
                    LDY PTR+1       ;; get page idx
                    STA FREESLOT,Y ;; store offset of (new) first free slot on page
                    RTS ;; that was it
    #+end_src

  - list cell pair ref allocation [same for all slot - types]
    inc reference count
    (e.g. list cell pair 51 (max 64 without rc)
    - memory layout (list-pair-cells-page)
      00 : reserved (next page with free cells)?
      01 : rc for cell-pair1 $04
      02 : rc for cell-pair2 $08
      03 : rc for cell-pair3 $0C
      04 : cell-pair1
      08 : cell-pair2
      0C : cell-pair3
      10 : rc for cell-pair4 $40
      11 : rc for cell-pair5 $44
      ...
      3F : rc for cell-pair51 $FC
      40 : cell-pair4
      ...
      FC : cell-pair51

      0000 0100 => 0000 0001 : $01 rc for cell $04
      0000 1000 => 0000 0010 : $02 rc for cell $08
      0000 1100 => 0000 0011 : $03 rc for cell $0C

      0100 0000 => 0001 0000 : $10 rc for cell $40
      1111 1100 => 0011 1111 : $3F rc for cell $FC

    - memory layout (8 bytes slots) 28 (max 32 without RZ)
      00 : reserved
      ...
      04 : rc cell 1
      ...
      1F : rc cell 28
      20 : cell 1
      ...
      F8 : cell 28

    - memory layout (16 bytes slots) 15 (max 16 without RZ)
      00: reserved
      01: rc cell 1
      0F: rc cell 15
      10: cell 1
      ...
      F0: cell 15

    - memory layout (32 bytes slots) 7 (max 8 without RZ)
      00: reserved
      ...
      02: rc cell 1
      04: rc cell 2
      ...
      0E: rc cell 7
      0F..1F: reserved
      20: cell 1
      40: cell 2
      ...
      E0: cell 7

    - memory layout (62 bytes slots) 4
      00: reserved
      01: rc cell 1
      02: cell1
      40: reserved
      41: rc cell 2
      42: cell2
      80: reserved
      81: rc cell 3
      82: cell3

    - memory layout (127 bytes slot) 2
      00: slot1
      7F: rc slot 1
      80: slot2
      FF: rc slot 2

    - memory layout (255 bytes) 1
      00: slot
      FF: rc for slot

    - memory layout (cells-page) 85 cells (max 128 without RZ)
      00 : reserved
      01 : rc for cell 1
      02 : cell1
      04 : rc for cell 2
      ...
      07 : rc for cell 5
      08 : cell 2
      0e : cell 5
      10 : rc for cell 6
      ...
      1F : rc for cell 21
      20 : cell 6
      ..
      3E : cell 21
      40 : rc for cell 22
      ...
      7F : rc for cell 85
      80 : cell 22
      ..
      FE : cell 85
        #+begin_src asm
          ;; is in PTR
                  LDA PTR ;; low byte
                  LSR
                  LSR
                  STA DEC_LABEL+1
                  LDA PTR+1
                  STA DEC_LABEL+2 ;; copy high byte (page idx)
                  ;; -------------------------------------
           DEC_LABEL:
                  DEC $0000

                  ;; LDY #$00
                  ;; LDA #$01                ;; LDA (PTR+2),y
                  ;; SBC (PTR+2),Y           ;; DEC
                                          ;; STA (PTR+2),y
                  ;; -------------------------------------
                  BNE DONE

                  ;; free this cell
                  ;; copy car and cdr to possible add them to cells to free, too
                  LDY #$03
           COPY_CARNCDR:
                  LDA (PTR),Y
                  STA CAR,Y
                  DEY
                  BPL COPY_CARNCDR

                  LDA CAR
                  AND #$03
                  BEQ CAR_NO_PTR
                  LDA CAR
                  JSR ENLIST_FOR_FREE_IF_PTR ;; if CAR is a PTR mark for ref count decrease and potential free
             CAR_NO_PTR:
                  LDA CAR+2 ;; cdr
                  AND #$03
                  BEQ CDR_NO_PTR
                  LDA CAR+2
                  JSR ENLIST_FOR_FREE_IF_PTR ;; if CAR is a PTR mark for ref count decrease and potential free
    CDR_NO_PTR:

                  ;; put into the given cell the offset of the last first free cell of this page
                  LDY DEC_LABEL+2 ;; page idx
                  LDA FREE_SLOT,Y ;; current slot offset
                  LDY #$00
                  STA (PTR),Y ;; set (old) free slot offset in now freed cell!
                  LDA PTR ;; low-byte = free new offset (of now freed cell)
                  LDY PTR+1 ;; page idx
                  STA FREE_SLOT,Y ;; set new free offset of this page
          DONE:
                  RTS

        #+end_src
  - list cell pair ref deallocation [same for all slot - types]
    dec reference count
    if <0 mark let old first free cell of this page point to this one
          mark this one the first free cell in the page
***** algorithm to free list-cell-pairs using no additional memory
- basic sketch
  - each cell type has its own to-free structure
    - list-cell-pair  :: tree
    - cell-ptr        :: nothing necessary
    - array/structure :: array
    - float           :: nothing necessary
- the algorithm must work without allocating new space
  - free list-cell-pair
    - case 1 and only: cell1 (C) is a list-cell-pair (don't care about cell2)
      - start
             cell-pair that dropped to zero A[C|o,B|o]
                                                |   +-->
                                                +---->
             to-free-tree -> D[o,o]
                               | |
      - end
             recursive tail call: free C|o
             to-free-tree -> A[o,B|o]
                               |   +-->
                             D[o,o]
                               | |
  - free cell-ptr (no free list necessary)
    - case 1 and only: points to anything (B)
      - start
              cell-ptr that dropped to zero A[o]
                                              +--> B
      - end
              recursive tail call: free B
  - free array/structure
    - case 1 and only:
      - start
              array/structure that dropps to zero A[B,o,o,....]
              to-free-array C[o,o,o,o,o,o]
      - end
              recursively tail call: free B (first entry)
              to-free-array A[o,o,o, ....]
                              |
                              C[o,o,o,o,o,o]
**** DONE add profiler for code length
- simply count bytecode length
**** DONE enable restting cpu cycle count (e.g. via extended byte codes)
- done through magic jsr address (used by BNOP operation)
**** DONE reference count (only pointers to cells and pointers to cell-pais)
- increase on allocation
- increase duplication
  - write stack -> local
  - write local -> stack
- decrease
  - return and tail call (all locals are discarded) <- detection might make init of locals necessary
  - operations that operate on the stack
    - cdr (decrease node, increase node pointed to by tail which is now tos)
    - car (decrease node, increase node pointed to by head which is now tos)
    - equal (decrease both operands, if they are pointers)
    - nil? (decreases operand)
- neither nor
  - some operations on the stack
    - cons (since head and tail are still in use), just increase pointer to new cell (through allocation)
  - pop to local
  - return local
- TODO
   allocation of local stack should fill the lowbyte page with #xff to indicate bytes <- anything != ptr should work!
   DONE first complete all commands to increment the ref count,
   once this is complete, watch the refcount numbers during commands <- need debugger info
   the decrement can be implemented (and checked)
   WRITE​_TO​_LOCAL​_x  (BC​_PUSH​_LOCAL​_SHORT)
   - check whether local holds a ptr, if so dec ref (of pointed to), before overwriting it
   - check if rt holds ptr, if so inc ref (of pointed to)
   NIL? (BC​_NIL​_P)
   - check if rt holds ptr, if so dec ref (of pointed to)
   NIL?​_RET​_LOCAL​_0​_POP​_x (BC​_NIL​_P​_RET​_LOCAL​_N​_POP)
   - check whether x - stack elements are ptrs, if so dec respectively
   - overwrite local0 with 0 (no refcount change necessary then)
   CDR (BC​_CDR)
   - check if rt holds ptr, if so dec ref (of pointed to)
   - check if CDR (rt) holds ptr, if so inc ref (of pointed to)
   CAR (BC​_CAR)
   - check if rt holds ptr, if so dec ref (of pointed to)
   - check if CAR (rt) holds ptr, if so inc ref (of pointed to)
   CDDR, CDAR, CADR, CAAR, likewise (BC​_CxxR)
   PUSH​_LOCAL (BC​_PUSH​_LOCAL​_SHORT)
   - check if local is a ptr, inc ref (of pointed to)
   PUSH_​LOCAL​_x​_CAR (BC​_PUSH​_LOCAL​_CXR)
   - check if car of local is a ptr, inc ref (of pointed to)
   PUSH​_LOCAL​_x​_CDR (BC​_PUSH​_LOCAL​_CXR)
   - check if cdr of local is a ptr, inc ref (of pointed to)
   RET (BC​_RET)
   - cleanup locals
   FALSE​_P​_BRANCH :: do nothing <- only int should be on the stack
   TRUE​_P​_BRANCH :: do nothing <- only int should be on the stack
   PUSH​_NIL :: do nothing (nil is not ref counted)
   PUSH​_INT​_x :: do nothing (int is not ref counted)
   CALL :: do nothing
   TAIL​_CALL :: do nothing
   GOTO :: do nothing
   POP (BC​_POP)
   - if rt is ptr, dec ref
   POP​_TO​_LOCAL​_x  (BC​_POP​_TO​_LOCAL​_SHORT)
   - if local​_x is a ptr, dec ref of local x (before overwriting it)
   CONS (BC​_CONS)
   - no adjust of consed elements (since they are referenced by cons cell, no longer by stack)
   - set ref count to 1 on new allocated cell
   COONS (BC​_COONS)
   - no adjust of consed elements (since they are referenced by cons cells, no longer by stack)
   - set ref count on both allocated cells to 1 each (last cons is on stack, previous cons is referenced by last cons)
   DUP (BC​_DUP)
   - check if rt is ptr, inc ref (of pointed to)
   SWAP :: do nothing
   BNOP :: do nothing

 VM​_REFCOUNT​_DECR​_RT                                ;; generic decrement of refcount (dispatches depending on type)
 VM​_REFCOUNT​_INCR​_RT                                ;; generic increment of refcount (dispatches depending on type)

 VM​_REFCOUNT​_DECR​_RT​_​_CELL​_PAIR​_PTR                 ;; decrement refcount, calling vm_free_cell_pair_in_zp_ptr if dropping to 0
 VM​_REFCOUNT​_DECR​_RT​_​_CELL​_PTR                      ;; decrement refcount, calling vm_free_cell_in_zp_ptr if dropping to 0

 VM​_REFCOUNT​_INCR​_RT​_​_CELL​_PAIR​_PTR                 ;; increment refcount of cell-pair
 VM​_REFCOUNT​_INCR​_RT​_​_CELL​_PTR                      ;; increment refcount of the cell, rt is pointing to

**** DONE memory information
- get free pages
- get empty pages <- listed to be reused
- get used pages <- currently in use (1 or more slots in use or in free list)
- get used cells, cell-pairs <- currently in use
- get cells/cell-pairs in free list <- freed and ready for reuse
- for tests: get numbers globally (and per page)
**** DONE implement function to reclaim elements of the free list (cel-pairs)
**** DONE optimize reference counting
- [X] (not completely possible) get rid of refcount​_decr​_rt (only use 'ra')
- [X] reduce impact/cpu cycles
**** DONE redesign vm-memory-manager
- State "DONE"       from "IMPLEMENT"  [2025-05-09 Fri 11:59]
- identify things that still make the redesign difficult
- goal should be to allow for incremental improvements that should not take any longer than e.g. 30m
- make improvement measurable (% done/list)
- divide renaming from restructuring
- make composition obvious
- insights:
  - work by conceptual level
    => implement all functions for page, then cell, then cell-pair etc.
  - keep conceptual redesign to a low level
  - incrementally write commits after thoroughly testing the changes
  - rethink testing after complete redesign (more granular)
  - rethink file level separation of code after complete redesign
  - don't do too much thinks in parallel
- see [[file:src/nmil/vm-memory-manager.org::*modularize functions using naming convention][modularize functions using naming convention]]
**** IMPLEMENT what part of the 6510 vm design should be implement w/ racket to validate design?
implement all necessary to do a reverse function tail called implementation with space optimized byte code
see [[file:src/nmil/svm-compiler.rkt::(m-fun-def (reverse (a-list cell*) (b-list cell* '()) -> cell*][test with reverse function]]
this will include the implementation of
- [X] function call
- [X] function selection (index vs. ptr to actual function), first impl use ptr (low bits indicate direct ptr / index)
  - [X] currently only selection through direct pointers
- [X] call frame construction
- [X] parameter passing
- [X] local vars
- [X] tail call recursion
- [X] returning from a call
- [X] optimization idea: no parameter ptr, just cell-stack
  - example reverse list
    (def (reverse (a-list cell*) (b-list cell* '()))
      "reverse the a-list into b-list"
       (if (nil? a-list)
           b-list
           (reverse (cdr a-list) (cons (car a-list) b-list)))

    push nil
    push a-list
    call reverse

    entry without
    push nil
    swap
    entry with default explicitly set
    nil? return pop1       ;; one behind tos (if nil pop1 and return)
    write-to-fast-local #0 ;; a-list b-list
    car                    ;; car-a-list b-list
    cons                   ;; new b-list
    push fast local #0     ;; a-list new-b-list
    cdr                    ;; new-a-list new-b-list
    tail-call
  - inline code
    expected stack: a-list nil

    loop:
      nil? bra done
      write-to-local #n ;; a-list b-list   (local #n = a-list)
      car               ;; car-a-list b-list
      cons              ;; new b-list
      push local #n     ;; a-list new-b-list
      cdr               ;; new-a-list new-b-list
      bra loop
    done:
      pop               ;; new-b-list
  - other parameter order

    push a-list
    push nil
    call reverse

    ;; push nil ;; <- entry if default is not set
                           ;; resulting stack
                           ;; b-list a-list
    pop to local#0         ;; a-list
    write to local#1       ;; a-list
    nil? return local#0 pop 1 ;; a-list    ;; a-list = nil? => return b-list and pop one value
    cdr                    ;; new-a-list
    push local#0           ;; b-list new-a-list
    push local#1           ;; a-list b-list new-a-list
    car                    ;; car-a-list b-list new-a-list
    cons                   ;; new b-list new-a-list
    tail-call              ;; ...call into no defaults

  - check out other functions to check validity of this optimization
    - function 1: fibonacci
      (def (fib n (a 0) (b 1))
        (cond [(= n 0) a]
              [(= n 1) b]
              [else (fib (- n 1) b (+ a b))]))

      bytecode:
      caller:
      push int n
      call fib

      function:
      push int 0  ;; default for a
      push int 1  ;; default for b
      
      pop to local#0              ;; b
      pop to local#1              ;; a
      write to local #2           ;; n
      zero? ret local#1           ;;
      push int 1                  ;; 1
      push local#2                ;; n 1
      eq? ret local#0 and pop 2   ;;
      push local #2               ;; n
      push int -1                 ;; -1 n
      add                         ;; n-1
      push local #0               ;; b n-1
      push local #0               ;; b b n-1
      push local #1               ;; a b b n-1
      add                         ;; a+b b n-1
      tail-call                   ;; just a goto
    - alternative with parameters and other order
      ;; push int 1
      ;; push int 0
      push n
      call-defaults#2 fib       ;; use 2 more param slots for this call and jump @ -4

      fib-def-2
      push int 1                ;; fill param slots
      pop-to-param#2
      push int 0
      pop to param#1

      push param#0              ;; n
      zero? ret param#1         
      push param#0              ;; n
      push int 1                ;; 1 n
      eq? ret param#2           ;;
      push param#2              ;; b
      push param#1              ;; a b
      add                       ;; a+b
      push param#2              ;; b a+b
      push param#0              ;; n b a+b
      push int -1               ;; -1 n b a+b
      add                       ;; n-1 b a+b
      tail-call
    - function 2: 
    - function 3:
    - function 4:
- [X] optimizations for call stack/frame
  - [X] spread low/high over two pages
    - allocation needs to allocate two pages for stack
    - there need to be two zero page pointers, one for lowbyte-stack, one for highbyte-stack
  - [X] allow fast call frames (less copying, less space consumption)
  - [X] fix call-frame functions in vm-interpreter
- [X] implement simple tree algorithms
  - [X] ordered (not sorted) binary tree (of editor strings)
    see [[file:src/nmil/vm-validate-bt-naive.rkt][scheme implementation]]
    node: car = (ptr = level down | value) <- may not be nil
          cdr = (ptr = level down | value | nil)
          binary tree:   "1"
          maps to: (->"1" . NIL)

          binary tree:   o        ---- level_0
                        / \
                       1   2      ---- level_1
          maps to: (l_1 "1" .  "2")

          binary tree:     o      ---- level_0
                          / \
                         o   3    ---- level_1
                        / \
                       1   2      ---- level_2
          maps to: (l_1 (l_2 "1" . "2") . "3")
  
          binary tree:   o        ---- level_0 
                        / \                  
                       o   o      ---- level_1
                      /|   |\               
                     1 2   o 5    ---- level_2
                          / \               
                         3   4    ---- Level_3
          maps to: (l_1 (l_2 "1" . "2") . (l_2 (l_3 "3" . "4") . "5"))
  - [X] translate scheme implementation to nmil byte code functions
  - [X] tree algorithms + gc implementation (rc)
    - add/remove/cut/paste ... (as in editors)
  - [X] reverse order of binary tree + implementation of refcounting
  - [X] depth of binary tree (travers full tree, tail-call-recursively, keeping max depth)
- [ ] implement debugger commands 
- [ ] implement dereference?
- [ ] implement concept of exception
- [ ] implement concept of constants
  be aware of pointer tagging that should still work
  constants do not need reference counting and must never be put on the free-list (free-tree)
  (use constant pages w/o refcounts? <- too much waste)
  (use code space <- loader may have to resolve due to relocatable constants)
  (constants->heap [and inc ref count] upon loading?)
  - lists
  - arrays, native-arrays (strings)
  - structures
- [X] allocation/deallocation of lists, cells, structures, strings
  - [X] cells
  - [X] lists
  - [X] arrays/structures
  - [X] strings/native arrays
- [-] field access to
  - [-] structures
    - [X] by index
    - [ ] by name/id
  - [ ] strings/native arrays
  - [X] arrays
- [X] get a notion on when to do ref-counting inc/dec and garbage collection
  - [X] refcount primitives (inc/dec/free)
  - [X] implement refcount gc for revers function

    cell2: [int2 . cell1: [int1 . cell0: [int0 . NIL]]]
    cell5: [int0 . cell4: [int1 . cell3: [int2 . NIL]]]

    refcounts on enter: cell2 refcount = 1, cell1: recount = 1, cell0: refcount = 1

    iteration1: enter stack: [NIL][cell2], leave stack: [cell3][cell1]     : local0 := NIL,   local1 := cell2
    | code                    | cell2-i1 | cell1-i1 | cell3-i1 |
    |-------------------------+----------+----------+----------|
    | POP​_TO​_LOCAL​_0         |          |          |          |
    | WRITE​_TO​_LOCAL​_1       |       +1 |          |          |
    | NIL?​_RET​_LOCAL​_0​_POP​_1 |        0 |          |          |
    | CDR                     |       -1 |       +1 |          |
    | PUSH​_LOCAL​_0           |          |          |          |
    | PUSH​_LOCAL​_1           |       +1 |          |          |
    | CAR                     |       -1 |          |          |
    | CONS                    |          |          |       +1 |
    | TAIL​_CALL              |          |          |          |

    iteration2: enter stack: [cell3][cell1], leave stack: [cell4][cell0]   : local0 := cell3, local1 := cell1
    | code                    | cell2-i2 | cell1-i2 | cell0-i2 | cell4-i2 | cell3-i2 |
    |-------------------------+----------+----------+----------+----------+----------|
    | POP​_TO​_LOCAL​_0         |          |          |          |          |        0 |
    | WRITE​_TO​_LOCAL​_1       |       -1 |       +1 |          |          |          |
    | NIL?​_RET​_LOCAL​_0​_POP​_1 |          |        0 |          |          |          |
    | CDR                     |          |       -1 |       +1 |          |          |
    | PUSH​_LOCAL​_0           |          |          |          |          |       +1 |
    | PUSH​_LOCAL​_1           |          |       +1 |          |          |          |
    | CAR                     |          |       -1 |          |          |          |
    | CONS                    |          |          |          |       +1 |        0 |
    | TAIL​_CALL              |          |          |          |          |          |

    iteration3: enter stack: [cell4][cell0], leave stack: [cell5][NIL]     : local0 := cell4, local1 := cell0
    | code                    | cell1-i3 | cell0-i3 | cell5-i3 | cell4-i3 | cell3-i3 |
    |-------------------------+----------+----------+----------+----------+----------|
    | POP​_TO​_LOCAL​_0         |          |          |          |        0 |       -1 |
    | WRITE​_TO​_LOCAL​_1       |       -1 |       +1 |          |          |          |
    | NIL?​_RET​_LOCAL​_0​_POP​_1 |          |        0 |          |          |          |
    | CDR                     |          |        -1 |          |          |          |
    | PUSH​_LOCAL​_0           |          |          |          |       +1 |          |
    | PUSH​_LOCAL​_1           |          |       +1 |          |          |          |
    | CAR                     |          |       -1 |          |          |          |
    | CONS                    |          |          |        0 |          |          |
    | TAIL​_CALL              |          |          |          |          |          |

    iteration4: enter stack: [cell5][NIL] -> return                        : local0 := cell5, local1 := NIL
    | code                    | cell0-i4 | cell5-i4 | cell4-i4 |
    |-------------------------+----------+----------+----------|
    | POP​_TO​_LOCAL​_0         |          |        0 |       -1 |
    | WRITE​_TO​_LOCAL​_1       |       -1 |          |          |
    | NIL?​_RET​_LOCAL​_0​_POP​_1 |          |          |          |
  - [X] implement refcount gc for tree functions (having pointers in both cells)
- [X] implement basic byte code debugger on top of 6510 debugger
  - [X] single step
  - [X] run to next call/return
  - [X] step over call
**** TODO write new tests for call-stack to verify local allocation/free on same page and over pages
**** IMPLEMENT implement some code for arrays (structures)
- cell arrays are put into the appropriate m1 slot pages
  => max size of a cell array is in profile 3 m1 page (slot size 83 bytes => 1 byte cell-type, 1 byte array len, 81 bytes for cells => 40 cells)
- arrays may hold one cell at each index
- each cell may be an atomic cell only (just: byte, int, cell-ptr, cell-pair-ptr)
- a cell-ptr may point to one cell, but depending on this cell, more cells may follow (cell-header + ..)
- a cell-pair-ptr points to a cell-pair
- functions
  - write to @/read from @
  - copy subarray
  - concatenate arrays
  - to-list/from-list
**** IMPLEMENT implement prime sieve (using native array)
**** IMPLEMENT implement some code for native arrays (strings)
- native-array/string functions
  - write to @/read from @
  - copy subarray (substring)
  - concatenate/append arrays
  - to-list / from-list
**** refcount qualities
- provide function w/ ref and w/o ref counting <- for optimization
  - name-convention: function w/ ref counting: ...​_RZ
- optimize check for ref-count applicable | atomic value
  cell-stack and RT may only hold
  - xxxxxxx0 -> ptr to cell or more complex structure, could be pointer to a cell-page, or a m1-page
  - xxxxxx01 -> cell pair ptr
  - 0xxxxx11 -> atomic int
  - 11111111 -> atomic byte
  => ptr check here can be done by: and $03; cmp $03; bne is-a-ptr; rts;
     alternatively: lsr; bcc is-ptr; lsr; bcc is-pair-ptr; rts; <- benefit, a is index to refcount byte
     or a combination of the two
  heap cells may also be:
  - 10000111 -> cell array + more
  - 10001111 -> native array + more  
- provide additional info for ref counting (e.g. knowledge about the data)
**** enable easy byte code modification
the byte code and its usage should be implemented flexible enough to make adjustments that either provide space or speed benefits (or even
both)
- combine cmds :: create one byte code for two one byte commands
- prefix :: make less common one byte command a two byte (prefixed) command
- remove prefix :: make more common two byte (prefixed) command a single byte command
- combine cmd op :: combine common byte operand combinations into a 'fast' single byte command
- decombine :: undo a combined command
**** IMPLEMENT optimize byte code
- push_​local_​0, write_​to_​local_​0 :: make this a one byte command (not a short instruction) => speeds up decoding
- [X] cadr cdar caar cddr :: could be put into a fast instruction
- cxyzr :: 2 byte instruction, where the second byte is encoded to do
  lldddddd : ll = 0..3 => 3..6 times apply car/cdr depending on bit d at position 0..5
             d = 1 = cdr, d = 0 = car.
- [X] true?-ret false?-ret :: combine true?-branch ret, false?-branch ret
- [X] coons :: two conses ?
- move inc_​int, max_​int into single byte opcodes
- [X] push_​local_​n_​car, push_​local_​n_​cdr :: push and car or cdr
- nil?_​branch, not_​nil?_​branch :: branch on (not) nil
- int_​0_​branch, not_​int_​0_​branch :: branch on (not) int = 0
- int_​1_​branch, not_​int_​1_​branch :: branch on (not) int = 1
- byte_​0_​branch, not_​byte_​0_​branch :: branch on (not) byte = 0
- byte_​1_​branch, not_​byte_​1_​branch :: branch on (not) byte = 1
- string_​empty_​branch, not_​string_​empty_​branch :: branch on (not) string empty
- pop + push :: can be done by a write
- call + ret :: can be combined to a jump
  iff enough locals are available (in current function)
  careful! function pointer must be adjusted (for tail calls of the called function)
**** IMPLEMENT enhance debugger
- [X] pretty print the next x byte code instructions
- [X] make inspection routines fail safe (ignore exceptions)
- [X] switch from/to bc/assembler debugger
- [X] send command to surface interactor
- [X] use colors to separate prompt, output, disassembly
- [X] allow setting breakpoints on bytecode (at a certain address)
- [X] allow in place execution of bytecode
- [X] going back bc steps
- [ ] print (shortened) call stack (w/ function names) [ function-name : pc : #locals ]
- [ ] add watch on memory <- continuous output of this value after each step
- [ ] add watch on variable <- implementation could be a trace point (like a breakpoint, but not stopping)
- [ ] add page view (continuous update) during execution
- [ ] add breakpoint on memory change
- [ ] add stack view (continuous update) 
- [ ] add call-frame view (continuous update)
- [X] inspection of vm variables (zp_​vm_​pc, zp_...)
- [ ] inspect/manipulate call frame
- [ ] inspect/manipulate value stack
- [-] inspect/manipulate memory - cells/lists/structures/strings/native arrays/arrays
  - [X] cells
  - [X] lists
  - [ ] structures
  - [ ] strings/native arrays
  - [ ] arrays
**** how much of the 6510 code should be actually written and tested with the interpreter (and actually used to interpret byte code)?
**** design persisted byte code (constants, unlinked symbols, bytecode), linker/loader
**** generate persisted byte code (single module, multi module in mind)
**** implement loader/linker
**** IMPLEMENT glue together mil + vm + loader and linker
- (m-def ...) -> vm, execute, debug?
- see [[file:src/cisc-vm/mil-svm-generator.rkt]]
**** glue together mil + 6510 vm
**** IDEA runtime profiling                    -> evaluate optimizations
- build byte code profiling from assembly profiling building blocks?
- assembly code
  - run
    - number/duration of calls of a method/label
    - number of accesses on zp_ variables
    - number of indirect accesses through zp_ variables
    - number of accesses on vm_ variables (e.g. memory map etc)
    - number of accesses on absolute variables (e.g. local function variables)
- byte code
  - static
    - usage number of byte codes for programs
  - run
    - number/duration of executions of certain byte code
    - number/duration of function calls
    - number/duration of tail calls
    - number/duration of locals accesses
    - number/duration of stack push/pop operations
    - number/duration of stack page allocations/deallocations
    - number/duration of locals stack page allocations/deallocations
    - stack sizes over time
  - gc
    - number of cell/cell-pair/cell-array/native-array alloc, free, reclaim, etc.
    - pages (type, #free cells ...) over time

**** IDEA inline native code
- enter: byte code that will simply run the following natively (jmp there)
- exit:  JSR interpreter reentrance:
  - pop next byte code address from stack into bc program counter
  - run bc interpreter from there
**** IDEA implement larger array by using a BST tree of arrays?
**** IDEA change table with dispatch addresses (for certain programs? might optimize memory footprint)
**** IDEA collect statistics for
- common two byte combinations <- byte code combinations
  - e.g. combine these into one byte commands
- number of usages of single byte codes
  - e.g. move less common to prefixed-commands, ...
**** IDEA for native code implementation of (parts of) functions
(have a rough idea of how this could be done, don't actually implement)
- replace byte code sequence with byte-code indicating switchover to native code
  then use sequences of JSR that circumvent the decoding steps
  leaving native code and going back to byte code is done by calling the interpreter loop again
- calling functions that have been replaced by native code (hot swap)
  need indirection (no direct pointer for call, rather index)
  need for data structure for mapping index to ptr
**** IDEA reduce ref counting for locals
did some experiments on branch ~optimize_rev_app_w_extra_bc~
- PULL​_FROM​_LOCAL​_n <- remove the value pulled from the local store => no ref needed counting!
- sequences of getting a ptr from locals, incrementing ref count, the doing car/cdr, decrementing pointer + incrementing new one
  can be compacted to only incrementing the final retrieved value
- incrementing ref count and then doing a destructive NIL? etc. is not necessary either
  example:
  #+begin_src scheme
    (bc WRITE_TO_L1)   ;; increment ref count
    (bc NIL?)               ;; replace tos with boolean result => decrement ref count
  #+end_src
- further analyse locals usage and how to reduce number of refcount changes in functions
- ref counts are important if calling a sub routine <- do refcounting then (and keep that info)
- leaving a function that has locals
  - it has called a subfunction => locals were refcounted => upon leaving, decrement refcounts (without deallocation!)
**** IDEA do tracing only on call and ret
- print function names, too
- print stack on call and result on ret
**** IDEA profiling (on jsr/rts) e.g. via tracing point
- use information of labels to convert addresses -> labels
- collect cycles spent
- collect number of calls
**** IDEA functions allow for metadata (could enhance tracing) and defaults
(e.g. byte 0 includes flag for existence, absence of metadata, number of defaults and number of locals)
MDDDLLLL  M : flag for metadata existence
          DDD : 0..7 default values (or just 0..3)
          LLLL: 0..15 locals        (or just 0..7)

Metadata existence means: there is an additional cell, pointing to the function string (even aligned, readonly native array)
offset   content
----------------
-2(n+1)  [cell-ptr -> native array with function string name]   <-- even aligend (so that cell-ptr is detected as such)
-2n      [cell default n]
         ...
-2       [cell default 1]
0        [MDDDLLLL] (byte)
         [Function BC 0]
         ...
         [Function BC x]
         ? possible one padding byte
?        [native array function name]                           <-- even aligned ? (really, is there a need for that), or should this be alloced during loading and linking)
?        [other default values, the default cells are pointing to (e.g. a structure)]

**** IDEA call with defaults (related to concept of constants!)
- special call instruction
  - call​_with​_1​_default ... n​_defaults
  - defaults are cells before the byte defining the # of locals
  - defaults are read only
  - defaults (since cells) must be allocated on even addresses (bit 0=0)
  - the call instruction pushes these defaults automatically in the stack before executing the function
  - the defaults are organized reverse =>
    if function accepts two defaults
      and is called with the first default explicitly set by the caller
      and call​_with​_1​_default is used
    => only the second default is pushed on the stack
**** IDEA instruction cache (see python caching) (see https://github.com/python/cpython/blob/main/InternalDocs/interpreter.md#Specialization and https://www.youtube.com/watch?v=PGZPSWZSkJI&t=1470s)
- use specialized byte code instruction (with guard to fall back to more general byte code)
- fallback/specialization rewrites bytecode
- right behind bytecode some information is 'cached'
  - fallback/specialization counts
- byte code that can be specialized is organized in 'families' that define how much extra bytes are needed
- special byte code execution should be much faster than general byte code execution
  (e.g. int-add vs. finding the right add and then use conversions + float-add?)
**** IDEA restrict function names to one case and only some special chars => function meta data as name is compact
- store 3 characters in 2 bytes (each 5 bit)
- A-Z (26) or a-z
- _-?>< and byte 0 to mark end?
- drawbacks: no numbers, no lower/upper case characters <- worth it?
  probably not! get rid of metadata if possible (e.g. through static linking?)
**** IDEA make compilation phases more explicit
- macro decomposition into an ast (this ast is worked on/rewritten during the different phases)
- transformation from ast/stack orientation -> register oriented atomic commands
- vm-register allocation + reordering sub expressions (optimization)
  - function parameters can be evaluated in any order (strict eval scheme)
- optional: others like constant folding
**** IDEA information collected/used during compilation phases
Maybe add this information as a hashmap, allowing for arbitrary information to be added any time
What information is needed for the different phases? => check the different optimization problems, collect necessary information
- precode :: used to store atomic expressions that need to run before the code for the current node can be executed
  e.g. ~(byte+ a 1)~ needs a precode instruction to load the constant 1 into a local reg such that the byte+ instruction has only references left, that can be passed to the call
- is-recursive-call :: is the given node a recursive call? (must be a ast-e-fun-call)
- parameter-id-map :: parameter id to parameter register map (to resolve parameter references), does not change w/i function
- locals-id-map :: mapping locally introduced ids to local registers, does change, whenever a new local is introduced
- globals-id-map :: mapping global ids to global registers, is setup once
- registers-usage :: description of the register use and liveliness (e.g. vm_​l0 r/w, vm_​p1 r)
  this information (of the dataflow) is used for instruction reordering
  it can be used to find out which register are free (not live anymore) for allocation for other instructions
- negated :: (on if nodes), is the given nodes' bool expression negated? => code generation needs to take this into account, may happen if else/then branches are swapped
- source code location :: location of the original source
- previous node :: reference to node before change (to track changes through compilation)
- previous note :: note that describes the transformation done from previous node to current node
*** some iteration (ideas)
**** more elaborate data structures
- OPTIONAL tree for ordered traversal/find (each node needs data to decide <=, >)
  useful for set implementation, sorted/ordered dynamic growing/shrinking data structure.
  useful for implementation of editor metadata for each line (with int = linenumber, value=line-string), but maybe n-ary tree is better suited
  useful for implementation and validation reference counting algorithm for byte code commands, stack, locals, register and heap usage!
  could be implemented as persistent data structure (rewriting parents to the root on changes)
  first implementation with overwriting through addition byte codes set-car, set-cdr operations (gc-ing overwritten pointers)
      invariant: all values of left-subtree ov level-a node A are < value of the level-a node!
                 level-a nodes do not hold value payloads (only compare values/hashes)
                 level-b nodes hold references to level-a nodes or values!
                 level-b nodes must hold either a value or a ref in car position (never NIL), cdr may be NIL (or a value or reference).
      there are level a and level b nodes. level a nodes are for holding values in car position,
      level b nodes are the actual binary tree structure
      level a nodes have the (actual) sub tree (level b) in cdr and the max left subtree value in car position
        binary tree:   o        ---- level_0
                      /
                     1  
        maps to: (l_0a c1 . (l_0b 1 . NIL))
        (these binary trees do not always map to lists, since they may hold values in cdr position)
       binary tree:   o        ---- level_0
                      / \
                     1   2      ---- level_1
        maps to: (l_0a c1 . (l_0b 1 . 2))
                     
        binary tree:     o      ---- level_0
                        / \
                       o   3    ---- level_1
                      / \
                     1   2      ---- level_2
        maps to: (l_0a c2 . (l_0b (l_1a c2 . (l_1b 1. 2)) . 3))
       binary tree:   o        ---- level_0 
                      / \
                     o   o      ---- level_1
                    /|   |\
                   1 2   o 5    ---- level_2
                        / \
                       3   4    ---- Level_3
        maps to: (l_0a c2 . (l_0b (l_1a c2 . (l_1b 1 . 2)) (l_1a c4 . (l_1b (l_2a c4 . (l_2b 3 . 4)) . 5))))
  - tree construction/update
    - (make-la level-b-sub-tree) => (cValue . B-SubTree)
      get max value of left subtree of the given b-sub-tree as cValue
    - (add level-a-root value)
      traverse tree to find right spot where to add the new value
    - (remove level-a-root value)
      travers tree to find value and remove it from the tree
     travers to node with value, returning keeping tree trail to it
      (fn (tree-trail-to la-node val (trail '()))
        (cond [(<= val (car node)) ;; search left sub tree
               (tree-left-trail-to (cdr node) value (cons node trail))]
              [else
               (tree-right-trail-to (cdr node) value (cons node trail))]))
      (fn (tree-left-trail-to lb-node value trail)
        (def new-trail (cons lb-node trail))
        (cond [(and (atomic-value? (car lb-node))
                      (= (car lb-node) value))
                 new-trail]
                [else (tree-trail-to (car lb-node) value new-trail)]))
      (fn (tree-right-trail-to lb-node value trail)
        (def new-trail (cons lb-node trail))
        (cond [(and (atomic-value? (cdr lb-node))
                    (= (cdr lb-node) value))
               new-trail]
              [else (tree-trail-to (cdr lb-node) value new-trail)]))
     to make it tail recursive, move code from tree-left/right-... to tree-trail!
  - tree traversal
- b-tree (persistent) <- keep somewhat balanced? balancing tree will enlarge undo/redo buffer usage!
  - eval b-tree compared to n-ary tree for source code (line) meta data (or multiple lines on one leaf?)
  - avl tree ? (https://en.wikipedia.org/wiki/AVL_tree)
  - read-black tree maybe, to keep it somewhat balanced ?
    how to keep the color on a car/cdr node? (could be kept in the reference count byte e.g. bit 7)
    tree may contain pointer to other tree nodes (cons pairs) or native arrays (leading spaces, total len, character data). no payload bit is free.
    red,black nodes may be used from different page sets. => there is a function to determine whether a cons pair comes from a "red" (or a "black") page => changing color = moving cons cell to other page?
- n-ary tree (non-persistent)
- n-ary tree (of editor strings)
  node: car = (ptr = level-down | value)
        cdr = ptr to sibling | NIL <- n-arry tree allows for n siblings (same level)
  - (make-node val) -> node
      creates a list: (list val)
  - (add-sibling node val) -> node
      extends list (node) by inserting (list val) as last element of the list <- cannot be put at the head, because tree structure would be lost
  - (first-child node) -> node
      is car (with result being a ptr, otherwise it has no children!)
  - (next-sibling node) -> node
      is cdr
  - (data node) -> val
      is car (with result being no ptr, otherwise it would have children!)
  - necessary lisp functions: car, cdr, cons, append <- append can be simplified in case of binary trees!
      (def (append (a list) (b list) list)
           (reverse (reverse a) b))
**** keep meta information (related to debugging)
- source code location
- default values
- types
- name -> index
**** implement text editor (mostly) in mil
  Data structures for a text editor:

  gap buffer:
  - keep text two separate portions of memory, copying between them.
  - cursor is at the end of the left buffer, inserting = adding to first buffer
  - second buffer is the text behind the cursor
  - moving cursor = copying first buffer <-> second buffer (can be delayed until insertion is done)

  - gap buffer implementation using a list of pages before cursor, list of pages after cursor
    (head of gap_pre_buffers is page with cursor) lines + text before cursor
    (head of gap_post_buffers is page right after cursor) <- text + lines after cursor

  - IDEA: no gap buffer, use screen data only, storing lines into memory when scrolling out of visibility?
          => there cannot be invisible data (scrolled out left and right)? => need for line break
             alternative: left|right invisible chars need to be saved/rendered efficiently <- is this really possible / not overly complex?
          ADVANTAGE: no dual changes (memory model + render)
          PROBLEM: undo/redo?

  - IDEA: gap buffer modification
          put current edit line (when actually editing, not if moving)
              into one extra page (text before cursor at start of page, text behind cursor, end of page),
              text is plain, without any encoding (like leading spaces or length data)
              cursor = ptr in page, typing = inserting text at cursor position
                                    erasing = deleting text before cursor position
              [<text before cursor>| ........  <text behind cursor>]
                                   /\        /\
                  pointer to cursor            pointer to text behind cursor
          once editing a line is done, it is copied into the regular text buffers
          format: [len][#leading-spaces]characters[len][0],
                  with len = total length of this line (including leading spaces) [stored two times, to do fast scanning|moving
                       #leading-spaces = number of spaces before first char starts
                       characters = actual text
                       0 = zero, marking end of line (for scanning)
                  lines are always kept completely on one page!

  - IDEA: keep current line# up to date <- needs to be updated with insertions / deletions
  - IDEA: keep line anchors (limited number of pointers to strings with their line number) <- need to be updated once lines are inserted (or invalidated)
  - IDEA: keep line anchors for all visible lines

    fast implementation:
    - render-line 'a starting from column 'b [to column 'c] at visual line 'd (two variants: 1. for currently edited line, 2. regular encoded text line)
    - scroll up/down 'n lines
    - scroll left/right 'n columns

    - insert/delete char
    - insert/delete line
    - insert/delete block
    - undo/redo (keep modifications + undo data)

  - multiple cursors (are not supported for fast operation)

  - IDEA: use mil data structures to implement the above
          => native array for currently edited line <- indexed access + copy left<->right from cursor
             tree of strings for current buffer text
             path to current line (for moving cursor line-wise through the text) = search previous/next leaf based on current node-path
             (e.g. line of a buffer = cell-pair (car = int, leading spaces + strlen, cdr = pointer to native string/array))
             buffer = n-ary tree of lines <- binary tree has advantage of using car/cdr pair only <- start out with this
             (rebalance tree once in a while)
             undo/redo = persistent tree data structure?, undo/redo organized in n-ary tree itself.
             <- when to discard? (running low on memory, discard most distant (tree distance) nodes)
                siblings are ordered last touched first

**** debugging
- level 0: debug vm code (byte code), trace, inspect, step-debugger, memory inspector
- level 1: debug mil, function/expression entry, inspect parameters, locals, etc, call stack, memory inspector
**** implement vm in mil
- precondition: all language features are implemented, debugging should be possible
- information gained: optimize execution speed + bytecode size + heap usage + c64 implementability
**** memory management
  - basic idea: don't do ref counting within a function
    - do reference counting only upon returning from a function
    - try to allocate/discard locally
  - idea: memory pages
    each page is used to allocate a certain type
    - list page (car/cdr cell-pairs)
    - array<> page (uniform type arrays)
    - structure page (page storing structures)
    - dynamicArray<> page (arrays of polymorphic types)
    - hashmap page (table for hashmaps)
    - float page (page for float numbers)
    - byte-code page
    - native-code page
  - sketch a memory usage upon function enter / leave (and during execution) to find a way to achieve this goal
  - atomic values (char, byte, int) are copied (to-from locals) without reference counting, except when used to create a list?
  - lists and arrays/strings are allocated on the heap and need to ref-count the cells
  - describe each instruction more closely to check how we can avoid reference counting
  - maybe start with explicit memory management (alloc, free)
** memory management
*** layout
**** operations
  - pass parameter to function
    - access with static offset
    - decide whether to allow overwrite (shared memory)
  - allocate local slots <- access with static offset
  - return into slot (via static offset)
**** call-frame : continuous memory allocating cells for parameters and locals
return address
no of parameter (byte)          # could be variable
parameter - cells (copied)      # is known by caller (access fast)
locals - cells (uninitialized)  # is known by callee (and known by caller if it is a static call)
=> call-frame <alloc-num> <local-num> <- only available if the function is statically known!
   copy loc/arg -> arg
   call function
   cisc code: *call functionid, #args, l/a#->a# ..., (#locals)*, (bytecode for call0 and call1 and call2 with short copy encoding) function is 16bit id / jump address
   dynamic call (getting the functionid from as symbol form a cell): *calld #args, l/a#->a# ..., func-id-l/a/g#*
- (is part of call frame) local-frame (access fastest) <- must be put onto the call frame to allow multiple instantiations of the same call
  locals - cells (uninitialized)  number is known by called function +[accessible right before bytecode] => local0 is @ function - 2+
The call frames are organized in a stack. Accessing a parameter will
c64 implementation detail:
    first parameter cell = lda (parameter),x=0 .. lda (parameter),x=1
    first local cell = lda (locals),x=0 .. lda (locals),x=1
    /parameter/ is a zero page address that is set for each activation frame
    same for /locals/
    idea: since locals should be a fixed number, they could come first such that the accessing index (x) is fixed for locals and params, even though params may vary (variadic) allowing for only on zero page "register"/pointer
**** global-frame [fixed number during program run?]
global - cells  (access not so fast)
*** data types
see [[file:src/cisc-vm/stack-virtual-machine.rkt::define CELL_PTR #b00000001) ;; xxxx xxx1 xxxx xxxx (ptr to words/cells][cell data layout]]
**** obsolete
(nil pointer should be easy to spot!, e.g. zero page has no cells => first byte 0 = nil ptr)
- cell
  - pointer to cell (need 15 bits)
    layout: [ptr (15bits)] 1 (uneven pointers?, page warp?)
  - pointer to cell-pair (list) (needs 14 bits)
    layout: [ptr (14bits)] 10
  - header (need max bits, describing the type of the header + as much information as possible)
    headers are usually followed by the bytes specific for this type
    layout: [type ()] .....0100
  - int (need max bits, low bits should all be zero to allow adding/subtraction without shifting)
    layout: [value (x bits)] ......000
    range: 0..8191, -4096..4095
  - byte/char (need 8 bits, one full byte should be used unmodified)
    layout: [value (8 bits)] .....1100
  - specialty idea: bcd encoded digits (3) for exact number maybe?
- float, exact, array/string, (hash)-map
- list = pair of cells (car + cdr=ptr to next cell-pair), car=0 => empty-list or nil
  e.g. list of bytes =
  (1 . o)->(2 . o)->(ptr0 . x)  ;; o)-> = cdr pointer, ptr0 = a pointer to cell 0 which is encoded into hex 0001
- list of pairs = (car=ptr to cell-pair of which car=key, cdr=value, + cdr=ptr to next pair)
- e.g. list of pairs, byte->string
  (o . o)->(o . o)->(ptr0 . x)
   |        |
   |        +->(5 . o)-> {header: string, length: 7, values: "at five"}
   +-->(2 . o)-> {header: string, length: 6, values: "at two" }
*** allocation
*** deallocation
** continuations
** vm registers and runtime behavior
call, tail-call, variable resolution, continuations, closures, macros?
- (later) use cpu registers for parameters (quickest)
- (later) use zero page for parameters (quick)
- use stack for parameters (slow)
- tail call should be as simple as test + branch instruction
- macros should already be resolved (no vm instructions for that, for now)
- use flattened closures to allow O(1) access to live locals and globals
** vm instructions
- use single byte for vm instruction
- use minimal length for common (short) instructions (e.g. lists with 0-3 elements)
- allow larger lengths for uncommon (long) instructions (e.g. lists with 1000 elements)
- idea
  - define vm instructions
  - optimize for size and speed of decoding later
  - keep optimizing strategies in mind
    - encode (small) values into opcode
    - use prefix byte for long commands (long running and seldom used)
    - how can table jumps be used
    - how can bits in the opcode be used for common actions (bit = micro op)
** loading/linking
** repl
* links
[[https://e-booksdirectory.com/listing.php?category=399][books about scheme]]
* additional material
** language & low level programming course
- https://web.cecs.pdx.edu/~mpj/llp/
