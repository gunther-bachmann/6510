#lang racket
(require (only-in threading ~>))

(require (for-syntax (only-in racket/list second empty? first)))
(require (for-syntax "6510-utils.rkt"))
(require (rename-in  racket/contract [define/contract define/c]))
(require "6510-utils.rkt")

(provide
 drop-meta-info
 replace-labels
 commands->bytes)

(module+ test
  (require rackunit)
  (begin-for-syntax
    (require rackunit)))

(define label/c (list/c any/c string?))
(define length-offset-list/c (list/c byte/c word/c))
(define command/c (listof any/c))
(define command-len-offset-pair/c (list/c command/c length-offset-list/c))

(define (drop-meta-info line)
  (filter (lambda (element) (not (and (list? element) (keyword? (first element))))) line))

(module+ test
  (check-equal? (drop-meta-info '(ADC (#:line 5 #:org-cmd "some") "#$10"))
                '(ADC "#$10")))

(define/c (6510-byte-length command)
  (-> command/c byte/c)
  (case (first command)
    [('rel-opcode) (if (6510-label-string? (last command))
                       2
                       (- (length command) 1))]
    [('opcode) (cond ((6510-label-string? (last command))
                      3)
                     ((6510-label-byte-string? (last command)) ;; TODO don't make this dependent on the string (use some map to find type)
                      2)
                     (else
                      (- (length command) 1)))]
    [('bytes) (length (last command))]
    [('label) 0]
    [else (error "uknown command" (first command))]))

(module+ test
  (check-eq? (6510-byte-length '('opcode 1 ":some"))
             3
             "an opcode using a label as word value is of len 3")

  (check-eq? (6510-byte-length '('opcode 1 ":other"))
             3
             "an opcode using a label as word value is of len 3")

  (check-eq? (6510-byte-length '('opcode 1 ":other-L"))
             2
             "an opcode using a label as byte value is of len 2")

  (check-eq? (6510-byte-length '('opcode 1 ":other-H"))
             2
             "an opcode using a label as byte value is of len 2")

  (check-eq? (6510-byte-length '('bytes () (1 2 3 4)))
             4
             "bytes will produce the length of the byte list")

  (check-eq? (6510-byte-length '('opcode 1 2 3))
             3
             "opcode with three bytes is of len 3")

  (check-eq? (6510-byte-length '('label () ":test"))
             0
             "labels have no generated byte len"))

;; translates a list of command lengths into a list of pairs, each holding one command length and its absolute position (relative to current-sum)
(define/c (lo-sums list current-sum)
  (-> (listof byte/c)
     word/c
     (listof length-offset-list/c))
  (if (empty? list)
      '()
      (let* ([first-num (first list)]
             [new-sum (+ current-sum first-num)])
        (append `((,first-num ,current-sum)) (lo-sums (drop list 1) new-sum)))))

(module+ test #| lo-sums |#
  (check-equal? (lo-sums '(1 2 2 0) 0)
                '((1 0) (2 1) (2 3) (0 5)))
  (check-equal? (lo-sums '() 0)
                '())
  (check-equal? (lo-sums '(1 2 2 0) 8)
                '((1 8) (2 9) (2 11) (0 13))))

;; collect from the list of pairs of command definition and command-len-absolute-offset pairs, only the labels (and their lenght-offset pairs)
(define/c (collect-label-offset-map commands-bytes-list)
  (-> (listof command-len-offset-pair/c) (listof command-len-offset-pair/c))
  (filter (lambda (command-byte-pair)
            (match-let ([(list (list command-type _ ...) _) command-byte-pair])
              (equal? ''label command-type)))
          commands-bytes-list))

(module+ test #| collect-label-offset-map |#
  (check-equal? (collect-label-offset-map '((('opcode 1 2) (2 0))
                                            (('label ":some") (0 2))
                                            (('opcode 1 -2) (2 2))
                                            (('label ":other") (0 4))
                                            (('opcode 5 ":some") (3 4))
                                            (('label ":end") (0 7))))
                '((('label ":some") (0 2)) (('label ":other") (0 4)) (('label ":end") (0 7)))
                "filter only those commands that are labels, keeping their offset information in the code"))

;; get the offset of a given label
(define/c (get-label-offset labels-byte-list label)
  (-> (listof (list/c label/c length-offset-list/c))
     string?
     word/c)
  (let ([filtered (filter (lambda (label-byte-pair)
                            (equal? label (last (first label-byte-pair))))
                          labels-byte-list)])
    (when (empty? filtered)
      (error "label not found in list" label filtered))
    (last (last (last filtered)))))

(module+ test #| get-label-offset |#
  (check-equal? (get-label-offset '((('label ":some") (0 2))
                                    (('label ":other") (0 4))
                                    (('label ":end") (0 7)))
                                  ":some")
                2)

  (check-equal? (get-label-offset '((('label ":some") (0 2))
                                    (('label ":other") (0 4))
                                    (('label ":end") (0 7)))
                                  ":other")
                4)

  (check-exn
   exn:fail?
   (lambda () (get-label-offset '((('label ":some") (0 2))
                             (('label ":other") (0 4))
                       l      (('label ":end") (0 7)))
                           ":unknown"))))

;; construct a list of commands and their command-length-absolute-offset pairs
(define/c (commands-bytes-list commands)
  (-> (listof command/c) (listof command-len-offset-pair/c))
  (let* ([byte-lengths (map 6510-byte-length commands)]
         [byte-lengths/w-offset (lo-sums byte-lengths 0)])
    (map list commands byte-lengths/w-offset)))

(module+ test #| commands-byte-list |#

  (check-equal? (commands-bytes-list '(('opcode 10 10 10)
                                       ('label ":some")
                                       ('opcode 0)
                                       ('opcode 10 10)))
                '((('opcode 10 10 10) (3 0))
                  (('label ":some") (0 3))
                  (('opcode 0) (1 3))
                  (('opcode 10 10) (2 4)))))


(define label-high-byte-suffix "-H")
(define label-low-byte-suffix "-L")
(define (main-label-string label-string)
  (regexp-replace #rx"#?(:[a-zA-Z][a-zA-Z0-9_]*)(-H|-L)?" label-string "\\1"))

(module+ test #| main-label-string |#
  (check-equal? (main-label-string ":some")
                ":some")
  (check-equal? (main-label-string ":some-H")
                ":some")
  (check-equal? (main-label-string ":some-L")
                ":some")
  (check-equal? (main-label-string "#:some-L")
                ":some"))

;; replace label references in opcode list command-len-absolute-offset pairs with their absolute / relative offsets
(define/c (replace-label command-byte-pair labels-bytes-list address)
  (-> command-len-offset-pair/c any/c word/c (listof any/c))
  (let* ([command (first command-byte-pair)]
         [current-offset (last (last command-byte-pair))]
         [command-length (first (last command-byte-pair))])
    (if (>= 1 (length command))
        command-byte-pair
        (if (and (not (equal? ''label (first command))) (or (6510-label-string? (last command))
                                                       (6510-label-byte-string? (last command))
                                                       (6510-label-immediate-byte-string? (last command))))
            (let* ([label-string (last command)]
                   [main-label-string (main-label-string label-string)]
                   [label-offset (+ address (get-label-offset labels-bytes-list main-label-string))]
                   [rel-label-offset (- (get-label-offset labels-bytes-list main-label-string) current-offset command-length)])
              (case (first command)
                [('rel-opcode)
                 (list (append (drop-right command 1)
                               (list (low-byte rel-label-offset)))
                       (last command-byte-pair))]
                [('opcode)
                 (cond ((string-suffix? label-string label-low-byte-suffix)
                        (list (append (drop-right command 1)
                                      (list (low-byte label-offset)))
                              (last command-byte-pair)))
                       ((string-suffix? label-string label-high-byte-suffix)
                        (list (append (drop-right command 1)
                                      (list (high-byte label-offset)))
                              (last command-byte-pair)))
                       (else
                        (list (append (drop-right command 1)
                                      (list (low-byte label-offset) (high-byte label-offset)))
                              (last command-byte-pair))))]
                [else (error (string-append "unknown label reference in opcode" (symbol->string (first (command)))))])
              )
            command-byte-pair))))

(module+ test #| replace-label |#
  (check-equal? (replace-label '(('opcode 20 ":some") (3 10))
                               '((('label ":some") (0 8)))
                               100)
                '(('opcode 20 108 0) (3 10)))

  (check-equal? (replace-label '(('opcode #xa9 ":some-L") (2 10))
                               '((('label ":some") (0 8)))
                               100)
                '(('opcode #xa9 108) (2 10)))

  (check-equal? (replace-label '(('opcode #xa9 ":some-H") (2 10))
                               '((('label ":some") (0 8)))
                               #xc000)
                '(('opcode #xa9 #xc0) (2 10)))

  (check-equal? (replace-label '(('rel-opcode #xf0 ":some") (2 10))
                               '((('label ":some") (0 8)))
                               100)
                '(('rel-opcode #xf0 #xfc) (2 10)))

  (check-equal? (replace-label '(('rel-opcode #xf0 ":some") (2 10))
                               '((('label ":some") (0 20)))
                               100)
                '(('rel-opcode #xf0 8) (2 10)))

  (check-equal? (replace-label '(('opcode 20 30 80) (3 10))
                               '((('label ":some") (0 8)))
                               100)
                '(('opcode 20 30 80) (3 10))))

;; replace labels in the opcode list (using intermediate rep with commandlen-absolute-offset- pairs)
(define (replace-labels commands address)
  (let* ([commands-bytes-list (commands-bytes-list commands)]
         [labels-bytes-list (collect-label-offset-map commands-bytes-list)])
    (map first
         (map (lambda (command-byte-pair) (replace-label command-byte-pair labels-bytes-list address))
              commands-bytes-list))))

(module+ test #| replace-labels |#
  (check-equal? (replace-labels '(('opcode 1 2)
                                  ('label ":some")
                                  ('rel-opcode #xf0 ":end")
                                  ('opcode 1 ":some")
                                  ('label ":other")
                                  ('opcode 5 ":other")
                                  ('label ":end"))
                                10)
                '(('opcode 1 2)
                  ('label ":some")
                  ('rel-opcode #xf0 6)
                  ('opcode 1 12 0)
                  ('label ":other")
                  ('opcode 5 17 0)
                  ('label ":end")))

  (check-equal? (replace-labels '(((quote label) ":some")
                                  ((quote opcode) 169 65)
                                  ((quote rel-opcode) #xf0 ":some")
                                  ((quote opcode) 32 ":some")
                                  ((quote opcode) 0)) 10)
                '(((quote label) ":some")
                  ('opcode 169 65)
                  ('rel-opcode #xf0 #xfc)
                  ('opcode 32 10 0)
                  ('opcode 0))))



;; is the given command a label (placeholder)
(define (command-is-label? command)
  (case (first command) [('label) #t] [else #f]))

(define/c (label-of-command command)
  (-> command/c (or/c string? void? byte/c))
  (last command))

(define/c (label-string-of-label command)
  (-> command/c (or/c string? void?))
  (when (command-is-label? command)
    (last command)))

;; is this command using a label?
(define/c (command-uses-label? command)
  (-> command/c boolean?)
  (let ((operand (label-of-command command)))
    (and (string? operand)
       (or  (6510-label-string? operand)
           (6510-label-byte-string? operand)
           (6510-label-immediate-byte-string? operand)))))

(module+ test #| command-uses-label? |#
  (check-true (command-uses-label? '('opcode 20 ":some")))
  (check-true (command-uses-label? '('rel-opcode #xd0 ":some")))
  (check-true (command-uses-label? '('opcode #xe6 ":some-L")))
  (check-true (command-uses-label? '('opcode #xee ":some")))
  (check-true (command-uses-label? '('opcode #x69 "#:some-H")))
  (check-false (command-uses-label? '('opcode 20 #xff #xa0)))
  (check-false (command-uses-label? '('rel-opcode #xd0 #xfe))))

;; remove information from command list (leaving just a list of byte lists for each command line)
(define/c (remove-resolved-statements commands)
  (-> (listof command/c) (listof (listof (or/c byte/c (listof byte/c)))))
  (filter-not command-is-label?
              (map (lambda (command)
                     (case (first command)
                       [('opcode) (drop command 1)]
                       [('bytes) (drop command 1)]
                       [('rel-opcode) (drop command 1)]
                       [else command]))
                   commands)))

(module+ test
  (check-equal? (remove-resolved-statements '((1 2 3)
                                              ('opcode 2 3 4)
                                              ('rel-opcode #xF0 12)
                                              ('bytes (1 2 3))
                                              (0)))
                '((1 2 3)
                  (2 3 4)
                  (#xF0 12)
                  ((1 2 3))
                  (0))))

;; translate commands to bytes
(define/c (commands->bytes memory-address commands )
  (-> word/c (listof command/c) (listof byte/c))
  (flatten (~>  (replace-labels commands memory-address)
               remove-resolved-statements)))

(module+ test #| commands->bytes |#
  (check-equal? (commands->bytes #xa000 '(('opcode 20 #xff #xa0)))
                '(20 #xff #xa0))
  (check-equal? (commands->bytes #xa000 '(('opcode #x14 ":absadr")
                                         ('label ":absadr")))
                '(20 #x03 #xa0))
  (check-equal? (commands->bytes #xa000 '(('label ":before")
                                         ('rel-opcode #xd0 ":before")))
                '(#xd0 #xfe)))

(define-struct reloc-entry
  (label         ;; label used   
   use-position  ;; relative to code start (which is 0)
   byte-width    ;; target entry width (1 or 2 bytes)
   )
  #:transparent)

;; filter the list of commands-bytes-list to only those commands using labels
(define/c (collect-commands-using-labels commands-bytes-list)
  (-> (listof command-len-offset-pair/c) (listof command-len-offset-pair/c))
  (filter (lambda (cb)
            (match-let* ([(list command _) cb]
                         [(list opcode _ ...) command])
              (and (command-uses-label? command)
                 (equal? ''opcode opcode))))
          commands-bytes-list))

;; collect all absolute references to labels w/i commands
(define/c (collect-absolute-reloc-entries commands)
  (-> (listof command/c) (listof reloc-entry?))
  (unless (empty? commands)
    (let* ([commands-bytes-list (commands-bytes-list commands)]
           [cbl-with-labels (collect-commands-using-labels commands-bytes-list)])
      (map (lambda (cb)
             (match-let ([(list command (list command-width rel-address)) cb])
               (reloc-entry (label-of-command command)
                            (add1 rel-address)
                            (sub1 command-width))))
           cbl-with-labels))))

(module+ test #| collect-absolute-reloc-entries |#
  (check-equal? (collect-absolute-reloc-entries '(('opcode 20 ":some")))
                (list (reloc-entry ":some" 1 2)))
  (check-equal? (collect-absolute-reloc-entries '(('opcode 20 ":some")
                                                  ('rel-opcode #xd0 ":before")
                                                  ('opcode #x69 "#:some-H")
                                                  ('opcode #x14 ":absadr")))
                (list (reloc-entry ":some" 1 2) ;;      0 [1 2]
                      ;;    3 [4]
                      (reloc-entry "#:some-H" 6 1) ;;   5 [6]
                      (reloc-entry ":absadr" 8 2)))) ;; 7 [8 9]

(define/c (collect-labels-matching-reloc-entry commands-bytes-list reloc-entry)
  (-> (listof command-len-offset-pair/c) reloc-entry? (listof command-len-offset-pair/c))
  (filter (lambda (command-bytes)
            (match-let ([(list command _) command-bytes])
              (and (command-is-label? command)
                 (string=? (main-label-string (reloc-entry-label reloc-entry))
                           (label-string-of-label command)))))
          commands-bytes-list))

;; generate the bytes of the relocation table of these commands
;; offset       data
;; 0            rel-position-low, rel-position-high, width (byte), (if width = 1 0:lowbyte 1:highbyte)?, rel-value-low, rel-value-high
(define/c (commands->reloc-table-bytes commands-bytes-list reloc-entries)
  (-> (listof command-len-offset-pair/c) (listof reloc-entry?) (listof byte/c))
  (flatten
   (map (lambda (reloc-entry)
          (define labels (collect-labels-matching-reloc-entry commands-bytes-list reloc-entry))
          (match-let ([(list _ (list _ offset)) (first labels)])
            (define label-str (reloc-entry-label reloc-entry))
            (list (low-byte (reloc-entry-use-position reloc-entry))
                  (high-byte (reloc-entry-use-position reloc-entry))
                  (reloc-entry-byte-width reloc-entry)
                  (cond ((= 1 (reloc-entry-byte-width reloc-entry))
                         (list (if (string-suffix? label-str "-H") 1 0) (low-byte offset) (high-byte offset) ))
                        ((= 2 (reloc-entry-byte-width reloc-entry))
                         (list (low-byte offset) (high-byte offset)))
                        (else raise-user-error (format "unknown byte width  ~a for label" (reloc-entry-byte-width reloc-entry)))))))
        reloc-entries)))

(module+ test #| commands->reloc-table-bytes |#
  (check-equal? (commands->reloc-table-bytes
                 '((('opcode 20 ":some")   (3 0))
                   (('label '()  ":some")    (0 3))
                   (('opcode 55 ":some-L") (2 3))
                   (('opcode 56 ":some-H") (2 5)))
                 `(,(reloc-entry ":some" 1 2)
                   ,(reloc-entry ":some-L" 4 1)
                   ,(reloc-entry ":some-H" 6 1)))
                '(1 0 2 3 0
                  4 0 1 0 3 0
                  6 0 1 1 3 0)))

;; write commands into this structure
;; offset       data
;; 0            rl = reloc-len (word, low-then-high byte)
;; 2            relocation table
;; 2+rl         cbl = cmd-bytes-len (word, low-then-high byte)
;; 4+rl         command bytes
;; 4+rl+cbl-1
(define/c (commands->relocatable-bytes commands)
  (-> (listof command/c) (listof byte?))
  (define cbl (commands-bytes-list commands))
  (define reloc-entries (collect-absolute-reloc-entries commands))
  (define reloc-table-bytes (commands->reloc-table-bytes cbl reloc-entries))
  (define reloc-table-bytes-len (length reloc-table-bytes))
  (define command-bytes (commands->bytes 0 commands))
  (define command-bytes-len (length command-bytes))
  (flatten
   (list
    (low-byte reloc-table-bytes-len)
    (high-byte reloc-table-bytes-len)
    reloc-table-bytes
    (low-byte command-bytes-len)
    (high-byte command-bytes-len)
    command-bytes)))

(module+ test #| commands->relocatable-bytes |#
  (check-equal? (commands->relocatable-bytes '(('opcode 20 #xff #xa0)))
                (list 0 0
                      3 0 20 #xff #xa0))
  (check-equal? (commands->relocatable-bytes '(('opcode #x14 ":absadr")
                                              ('label ":absadr")))
                (list 5 0 1 0 2 3 0
                      3 0 #x14 3 0))
  (check-equal? (commands->relocatable-bytes '(('label ":before")
                                              ('rel-opcode #xd0 ":before")))
                (list 0 0
                      2 0 #xd0 #xfe)))

;; read relocatable bytes and locate them at origin
(define/c (relocatable-bytes->bytes origin reloc-bytes)
  (-> word/c (listof byte/c) (listof byte/c))
  ;; (loop over relocation table and apply modification to command bytes)
  (define reloc-table-len (absolute (second reloc-bytes) (first reloc-bytes)))
  (if (zero? reloc-table-len)
      (cddr reloc-bytes)
      (let ((reloc-table-start (cddr reloc-bytes)))
        (define command-bytes (drop reloc-table-start (+ 2 reloc-table-len)))
        (apply-reloc-table-to origin (take reloc-table-start reloc-table-len) command-bytes))))

;; rel-position-low[byte], rel-position-high[byte], width[byte], (if width = 1 0:lowbyte 1:highbyte)? rel-value-low[byte] rel-value-high[byte] ...
;; -> ((rel-pos[word] width[1/2] (if width = 1 0:lowbyte 1:highbyte)? rel-value-low[byte] rel-value-high[byte]) ...)
(define/c (list-of-reloc-entries reloc-table)
  (-> (listof byte/c) (listof (listof word/c)))
  (if (empty? reloc-table)
      '()
      (let* ((byte-ind (third reloc-table))
             (rel-entry
              (list (absolute (second reloc-table) (first reloc-table))
                    byte-ind
                    (cond ((= 1 byte-ind)
                           (list (fourth reloc-table) (fifth reloc-table) (sixth reloc-table)))
                          ((= 2 byte-ind)
                           (list (fourth reloc-table) (fifth reloc-table)))
                          (else (raise-user-error (format "unknown byte indicator ~a" byte-ind)))))))
        (cons (flatten rel-entry) (list-of-reloc-entries (drop reloc-table (- 7 byte-ind)))))))

(module+ test #| list-of-reloc-entries |#
  (check-equal? (list-of-reloc-entries (list 3  0 1 0 15 0
                                             5  2 2 0 255
                                             10 0 1 1 12 10))
                '((3 1 0 15 0)
                  (517 2 0 255)
                  (10 1 1 12 10))))

(define/c (apply-reloc-table-to origin reloc-table command-bytes)
  (-> word/c (listof byte/c) (listof byte/c) (listof byte/c))
  (define sorted-reloc-entries (sort (list-of-reloc-entries reloc-table) < #:key (lambda (entry) (first entry))))
  (apply-reloc-entries-to- origin 0 sorted-reloc-entries command-bytes))

(define/c (apply-reloc-entries-to- origin at reloc-entries command-bytes)
  (-> word/c word/c (listof (listof byte/c)) (listof byte/c) (listof byte/c))
  (if (empty? command-bytes)
      '()
      (if (empty? reloc-entries)
          command-bytes
          (let ((reloc-entry (first reloc-entries)))
            (if (not (= at (first reloc-entry)))
                (cons (car command-bytes) (apply-reloc-entries-to- origin (add1 at) reloc-entries (cdr command-bytes)))
                (let ((byte-ind (second reloc-entry)))
                  (cond ((= byte-ind 1)
                         (let ((rel-offset (absolute (fifth reloc-entry)(fourth reloc-entry))))
                           (if (zero? (third reloc-entry))
                               (cons (low-byte (+ origin rel-offset))
                                     (apply-reloc-entries-to- origin (+ 1 at) (cdr reloc-entries) (cdr command-bytes)))
                               (cons (high-byte (+ origin rel-offset))
                                     (apply-reloc-entries-to- origin (+ 1 at) (cdr reloc-entries) (cdr command-bytes))))))
                        ((= byte-ind 2)
                         (let ((rel-offset (absolute (fourth reloc-entry)(third reloc-entry))))
                           (cons (low-byte (+ origin rel-offset))
                                 (cons (high-byte (+ origin rel-offset))
                                       (apply-reloc-entries-to- origin (+ 2 at) (cdr reloc-entries) (cddr command-bytes))))))
                        (else (raise (format "unknown byte indicator ~a" byte-ind))))))))))

(module+ test #| apply-reloc-entries-to- |#
  (check-equal? (apply-reloc-entries-to- #xc000 0
                                         '((1 2 3 0)
                                           (4 2 8 1))
                                         '(#x4c 0 0
                                           #x14 0 0
                                           #xea))
                (list #x4c #x03 #xc0
                      #x14 #x08 #xc1
                      #xea))
  (check-equal? (apply-reloc-entries-to- #xc000 0
                                         '((1 1 0 3 0)
                                           (3 1 1 8 1))
                                         '(#xa2 0 
                                           #xa2 0
                                           #xea))
                (list #xa2 #x03
                      #xa2 #xc1
                      #xea)))

(module+ test #| relocatable-bytes->bytes |# 
  (define program
    '(('opcode #x14 #xd2 #xff)
      ('label ":some")
      ('opcode #xca)
      ('rel-opcode #xd0 ":some")
      ('opcode #x4c ":some")
      ('opcode #xa2 "#:some-H")
      ('opcode #xa2 "#:some-L")))

  (check-equal?
   (relocatable-bytes->bytes #xc000 (commands->relocatable-bytes program))
   (list #x14 #xd2 #xff
         #xca
         #xd0 #xfd
         #x4c #x03 #xc0 ; <- #xc000 + 3
         #xa2 #xc0
         #xa2 #x03)
   "ensure that relocating will modify absolute label references")
  
  (check-equal?
   (relocatable-bytes->bytes #xf0fe (commands->relocatable-bytes program))
   (list #x14 #xd2 #xff
         #xca
         #xd0 #xfd
         #x4c #x01 #xf1 ; <-  #xf0fe + 3
         #xa2 #xf1      
         #xa2 #x01)
   "ensure that relocating to the end of a page will wrap correctly (low and high bytes, too)")

  (check-equal?
   (relocatable-bytes->bytes #xf0fe (commands->relocatable-bytes program))
   (commands->bytes #xf0fe program)
   "fixing the location of relocatable code should produce the same as generating code for the location directly"))
