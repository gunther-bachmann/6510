#lang racket
(require (rename-in  racket/contract [define/contract define/c]))
(require readline/readline)
(require "6510-interpreter.rkt")
(require "6510-reader.rkt")
(require "6510-utils.rkt")
(require "6510.rkt")
(require "6510-disassembler.rkt")

;; run an read eval print loop debugger on the passed program
(define/c (run-interpreter-single-step-loop org raw-bytes)
  (-> word/c (listof byte/c) any/c)
  (displayln (format "loading program into debugger at ~a" org))
  (define states (list (6510-load (initialize-cpu) org raw-bytes)))
  (define breakpoints (list))
  (readline ">")
  (for ([i (in-naturals)])
    (displayln "")
    (display "Step-Debugger> ")
    (let ((input (begin (readline ">"))))
      (define pm-regex #px"^pm *\\[([[:xdigit:]]{1,4}), *([[:xdigit:]]{1,2})\\]$")
      (define sm-regex #px"^sm *\\[([[:xdigit:]]{1,4})\\] *= *([[:xdigit:]]{1,2})$")
      (define sa-regex #px"^sa *= *([[:xdigit:]]{1,2})$")
      (define spc-regex #px"^spc *= *([[:xdigit:]]{1,4})$")
      (define x-regex #px"^xf? *\\{(.*)\\}$")
      (define stop-pc-regex #px"^stop *pc *= *([[:xdigit:]]{1,4})$")
      (define pp-regex #px"^pp *([[:xdigit:]]{1,2})? *([[:xdigit:]]{1,4})?")
      (cond ((string=? input "q") (exit))
            ((string=? input "b") (set! states (cdr states)))
            ((string=? input "s") (set! states (cons (execute-cpu-step (car states)) states)))
            ((string=? input "p") (displayln "") (print-state (car states)))
            ((regexp-match? pm-regex input)
             (match-let (((list _ addr len) (regexp-match pm-regex input)))
               (displayln (memory->string (string->number addr 16)
                                         (+ -1 (string->number addr 16) (string->number len 16))
                                         (car states)))))
            ((regexp-match? sm-regex input)
             (match-let (((list _ addr value) (regexp-match sm-regex input)))
               (set! states (cons (poke (car states) (string->number addr 16) (string->number value 16)) states))))
            ((regexp-match? sa-regex input)
             (match-let (((list _ value) (regexp-match sa-regex input)))
               (set! states (cons (with-accumulator (car states) (string->number value 16)) states))))
            ((regexp-match? spc-regex input)
             (match-let (((list _ value) (regexp-match spc-regex input)))
               (set! states (cons (with-program-counter (car states) (string->number value 16)) states))))
            ((string=? input "sfc") (set! states (cons (set-carry-flag  (car states)) states)))
            ((string=? input "cfc") (set! states (cons (clear-carry-flag  (car states)) states)))
            ((string=? input "sfb") (set! states (cons (set-brk-flag  (car states)) states)))
            ((string=? input "cfb") (set! states (cons (clear-brk-flag  (car states)) states)))
            ((string=? input "sfn") (set! states (cons (set-negative-flag  (car states)) states)))
            ((string=? input "cfn") (set! states (cons (clear-negative-flag  (car states)) states)))
            ((string=? input "sfv") (set! states (cons (set-overflow-flag  (car states)) states)))
            ((string=? input "cfv") (set! states (cons (clear-overflow-flag  (car states)) states)))
            ((string=? input "sfd") (set! states (cons (set-decimal-flag  (car states)) states)))
            ((string=? input "cfd") (set! states (cons (clear-decimal-flag  (car states)) states)))
            ((string=? input "sfz") (set! states (cons (set-zero-flag  (car states)) states)))
            ((string=? input "cfz") (set! states (cons (clear-zero-flag  (car states)) states)))
            ((string=? input "sfi") (set! states (cons (set-interrupt-flag  (car states)) states)))
            ((string=? input "cfi") (set! states (cons (clear-interrupt-flag  (car states)) states)))
            ((regexp-match? x-regex input)
             (match-let (((list _ value) (regexp-match x-regex input)))
               (let ((byteList (compile-opcode (string-trim value))))
                 (if (or (string-prefix? input "xf")
                        (eq? (let-values (((_ commandBytes) (disassemble-single (car states)))) commandBytes)
                             (length byteList)))
                     (set! states (cons (-pokem (car states) (cpu-state-program-counter (car states)) byteList) states))
                     (displayln "byte length differs (use xf to force)")))))
            ((regexp-match? stop-pc-regex input)
             (match-let (((list _ value) (regexp-match stop-pc-regex input)))
               (displayln (format "breakpoint set at $~a" value))
               (set! breakpoints (cons (lambda (state) (eq? (cpu-state-program-counter state) (string->number value 16))) breakpoints))))
            ;; ((string=? input "stop") (set! breakpoints (cons (lambda (state) (eq? (cpu-state-program-counter state) #xC002)) breakpoints)))
            ((string=? input "clear") (set! breakpoints '()))
            ((string=? input "commit") (set! states (take states (min (length states) 10))))
            ;; stop a=ff :: stop at accumulator = ff
            ;; stop sp=ff :: stop at stack pointer = fff
            ((string=? input "r") (let-values (((breakpoint new-states) (run-until-breakpoint states breakpoints)))
                                    (set! states new-states)))
            ((string=? input "c") ;; continue over current breakpoint to the next one
             (begin
               (set! states (cons (execute-cpu-step (car states)) states))
               (let-values (((breakpoint new-states) (run-until-breakpoint states breakpoints)))
                 (set! states new-states))))
            ;; so :: step over (jsr)
            ((regexp-match? pp-regex input)
             (match-let (((list _ len address) (regexp-match pp-regex input)))
               (displayln (disassemble (car states) (if address (string->number address 16)  (cpu-state-program-counter (car states))) (if len (string->number len 16) 1) ))))
            ;; ((string=? input "pp") (displayln (let-values (((str _) (disassemble (car states)))) str)))
            ((or (string=? input "h")
                (string=? input "?")) (displayln " q = quit,\n s = single step forward,\n p = print cpu state,\n b = backward step,\n pp = pretty print current command"))
            (#t (display "? not understood ?"))))))

;; (run-interpreter-single-step-loop #xc000 (list #xa9 #x41 #x48 #x20 #xd2 #xff #x00))

;; return nil or the breakpoint that hit
;; breakpoint is a function that takes a single argument the state
(define (breakpoint-hits state breakpoints)
  (if (empty? breakpoints)
      #f
      (begin
        (if (apply
             (car breakpoints)
             (list state))
            (car breakpoints)
            (breakpoint-hits state (cdr breakpoints))))))

;; run until a break point hits or the cpu is on a BRK statement
(define (run-until-breakpoint states breakpoints)
  (let ((breakpoint (breakpoint-hits (car states) breakpoints)))
    (if (or breakpoint (eq? 0 (peek-pc (car states))))
        (begin
          (displayln (format "hit breakpoint ~a" breakpoint))
          (values breakpoint states))
        (begin
          (let ((next-states (cons (execute-cpu-step (car states)) states)))            
            (run-until-breakpoint next-states breakpoints))))))
